<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的个人poxi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的个人poxi">
<meta property="og:url" content="http://blog.ouronghui.com/page/2/index.html">
<meta property="og:site_name" content="我的个人poxi">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的个人poxi">
  
    <link rel="alternate" href="/atom.xml" title="我的个人poxi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的个人poxi</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">种一棵树最好的时间是十年前，其次是现在。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.ouronghui.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-n2n点对点通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/04/n2n点对点通信/" class="article-date">
  <time datetime="2018-01-04T03:23:12.000Z" itemprop="datePublished">2018-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/04/n2n点对点通信/">n2n点对点通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="N2N介绍"><a href="#N2N介绍" class="headerlink" title="N2N介绍"></a>N2N介绍</h4><p>通过N2N即可组成局域网，在外面可以访问家里的路由器、机器。</p>
<ul>
<li>Supernode 中心节点，并不参与两台主机间直接通信, 只是起到媒人的作用。</li>
<li>Edge 节点都会建立tun/tap虚拟网卡，用作n2n网络的入口，Edge节点就可以互通了。</li>
</ul>
<h4 id="V1-与-V2"><a href="#V1-与-V2" class="headerlink" title="V1 与 V2"></a>V1 与 V2</h4><p>n2n有V1和V2两个版本， 两个版本不兼容，据说V1的性能还略高于V2,V2是增加了一些安全相关的提升。</p>
<p>所以我这里都是<strong>基于V1版本</strong>搭建的。</p>
<h4 id="Linux-Supernode-的安装"><a href="#Linux-Supernode-的安装" class="headerlink" title="Linux Supernode 的安装"></a>Linux Supernode 的安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/meyerd/n2n</span><br><span class="line">$ <span class="built_in">cd</span> n2n/n2n_v1</span><br><span class="line">$ make</span><br><span class="line">$ make install 2&gt;&amp;1 | tee  make.log</span><br></pre></td></tr></table></figure>
<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup supernode -l 86 -v -f &gt; supernode.log &amp;</span><br></pre></td></tr></table></figure>
<p>#### </p>
<h4 id="Ubuntu-Edge-的安装"><a href="#Ubuntu-Edge-的安装" class="headerlink" title="Ubuntu Edge 的安装"></a>Ubuntu Edge 的安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/meyerd/n2n</span><br><span class="line">$ <span class="built_in">cd</span> n2n/n2n_v1</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo su</span><br><span class="line">$ apt install uml-utilities</span><br><span class="line">$ tunctl -t tun0</span><br><span class="line">$ sudo edge -d n2n0 -c orh -k 123 -m c2:27:ad:05:b3:a5 -a 10.8.1.7 -l 104.128.82.194:86 -r -f</span><br></pre></td></tr></table></figure>
<h4 id="Openwrt-Edge的安装"><a href="#Openwrt-Edge的安装" class="headerlink" title="Openwrt  Edge的安装"></a>Openwrt  Edge的安装</h4><p>这里我是在虚拟机中安装的<code>Openwrt</code>可以先下载虚拟机文件，虚拟机</p>
<p><code>http://downloads.openwrt.org/attitude_adjustment/12.09/x86/generic/openwrt-x86-generic-combined-ext4.vdi</code></p>
<p>安装与配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ opkg update</span><br><span class="line">$ opkg install n2n</span><br><span class="line">$ </span><br><span class="line">$ vim /etc/config/n2n</span><br><span class="line">$ option ipaddr           <span class="string">'10.2.5.1'</span></span><br><span class="line">$ option supernode        <span class="string">'104.128.82.194'</span></span><br><span class="line">$ option port             <span class="string">'86'</span></span><br><span class="line">$ <span class="comment"># 为自己的N2N网络组织机构取个名字</span></span><br><span class="line">$ option community        <span class="string">'orh'</span></span><br><span class="line">$ <span class="comment"># 其他设备要使用相同的组织机构名和密码才能加入</span></span><br><span class="line">$ option key              <span class="string">'123'</span></span><br><span class="line">$ option route            <span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<p>启用，启动、停止：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/n2n <span class="built_in">enable</span></span><br><span class="line">/etc/init.d/n2n start</span><br><span class="line">/etc/init.d/n2n stop</span><br></pre></td></tr></table></figure>
<p>参考文章：</p>
<ul>
<li><a href="http://gohom.win/2016/09/03/n2n-p2pnet/" target="_blank" rel="noopener">P2P网络-n2n穿墙</a></li>
<li><a href="https://wiki.openwrt.org/zh-cn/doc/techref/opkg" target="_blank" rel="noopener">OPKG包管理</a></li>
<li><a href="http://openwrt.jaru.eu.org/chaos_calmer/ar71xx/packages/" target="_blank" rel="noopener">Openwrt离线包</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2018/01/04/n2n点对点通信/" data-id="ck2n0fsj5004webrjq6qm3pc1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/n2n/">n2n</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于那道Integer-1000-1000-返回false，100-100-返回-true的题目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/25/关于那道Integer-1000-1000-返回false，100-100-返回-true的题目/" class="article-date">
  <time datetime="2017-10-25T03:10:56.000Z" itemprop="datePublished">2017-10-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/25/关于那道Integer-1000-1000-返回false，100-100-返回-true的题目/">关于那道Integer: 1000 == 1000 返回false，100 == 100 返回 true的题目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间看到了那篇<a href="http://mp.weixin.qq.com/s?__biz=MzUxOTMyMzE2Mg==&amp;mid=2247492934&amp;idx=1&amp;sn=81e40f81110d4239bd1bdfe28d51bc09&amp;source=41&amp;ascene=2&amp;devicetype=android-23&amp;version=26051035&amp;nettype=WIFI&amp;abtest_cookie=AgABAAgADAADAJ6GHgAKiB4AJIgeAAAA&amp;wx_header=1" target="_blank" rel="noopener">为什么1000 == 1000返回为False，而100 == 100会返回为True?</a></p>
<h4 id="一、现象：主要代码如下，请先猜测-1、2的结果输出"><a href="#一、现象：主要代码如下，请先猜测-1、2的结果输出" class="headerlink" title="一、现象：主要代码如下，请先猜测 1、2的结果输出"></a>一、现象：主要代码如下，请先猜测 1、2的结果输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 1000, b = 1000; </span><br><span class="line">System.out.println(a == b);//1</span><br><span class="line">Integer c = 100, d = 100; </span><br><span class="line">System.out.println(c == d);//2</span><br></pre></td></tr></table></figure>
<p><strong>一般</strong>你会拿到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<p>这里我强调了是在<strong>一般情况下</strong>，原文中并没有写到是一般，我们不更改代码，第一个<code>a == b</code>结果也可能返回<code>true</code>，修改<code>jvm</code>参数配置就可以达到这种效果，文章的最后我提供了测试代码。</p>
<p>其实出现不同的原因是在这里：</p>
<ul>
<li><code>Integer a = 100</code> ==&gt; 创建了<code>Integer</code>对象 <code>Integer.valueOf(i)</code>，方法经过判断会是下面两种情况的一种：<ol>
<li><code>IntegerCache.cache[n]</code> </li>
<li><code>new Integer(i)</code></li>
</ol>
</li>
</ul>
<p>会有两种情况：一种会新建对象，一种返回一个缓存的对象</p>
<p><code>==</code> 用来比较值的，对象的值是否相等请使用 <code>obj.equals(o)</code>，这里两个<code>Integer</code>对象使用<code>==</code>来比较本身就是一种<strong>“不正当使用”</strong>，对象<code>==</code>取的是对象内存地址。</p>
<p>下面我们看下这个<code>IntegerCache.cache</code>的缓存区间：</p>
<ul>
<li><code>cache[]</code>: <code>final int low = -128</code> ， <code>final int high</code>: <code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code> or <code>127</code></li>
</ul>
<h4 id="二、为什么默认是-128-127-呢？"><a href="#二、为什么默认是-128-127-呢？" class="headerlink" title="二、为什么默认是[-128...127]呢？"></a>二、为什么默认是<code>[-128...127]</code>呢？</h4><p>个人认为可能主要有以下两个原因：</p>
<ul>
<li>日常生活经常使用到的数字，比如年龄，成绩，物品个数等等</li>
<li>“科学边界” 一个字节，即 <code>2^8</code>，256个数字，带上符号就是 [-128…127]</li>
</ul>
<h4 id="三、总结强调下"><a href="#三、总结强调下" class="headerlink" title="三、总结强调下"></a>三、总结强调下</h4><p>使用科学的方法来判断相等：</p>
<ul>
<li>值类型相等比较没得选 用 <code>==</code></li>
<li>对象相等比较使用<code>.equals</code></li>
</ul>
<p>另外，如果你的程序比较特殊，有大量的 <code>&lt; 128</code> 或 <code>&gt; 127</code> 的数字存在，你可以尝试考虑调节下参数<code>java.lang.Integer.IntegerCache.high</code>，当然这是一种锱铢必较的手段，会带来一些交付上的问题，就是每个环境可能都要加上此配置，这里只是一种优化上的思路假设。</p>
<h4 id="四、附加-测试"><a href="#四、附加-测试" class="headerlink" title="四、附加-测试"></a>四、附加-测试</h4><p><strong>测试 场景：1 千万的 Integer数组，将每个设值为[0, 1000]的随机整数，对比初始时间、各代空间占比</strong><br>总的对比结果如下（前者代表默认，后者代表–XX:AutoBoxCacheMax=1000）：</p>
<ol>
<li>申请1千万数组空间时间无差异，都是在 10ms 左右</li>
<li>遍历设值初始值，前者会隐式的使用 new，耗时 3000ms左右，后者会隐式命中 cache，耗时 300ms, 相差10倍</li>
<li>各空间使用对比<ul>
<li>前者 eden 空间 使用比后者 eden 空间 大出 1倍</li>
<li>前者 old 空间使用了 126M，后者没有使用 old空间</li>
</ul>
</li>
</ol>
<p>源码请看<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/basic/IntegerCacheTest.java" target="_blank" rel="noopener">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/10/25/关于那道Integer-1000-1000-返回false，100-100-返回-true的题目/" data-id="ck2n0fski006uebrjfhwalrj1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-再读数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/17/再读数据结构/" class="article-date">
  <time datetime="2017-10-17T05:25:17.000Z" itemprop="datePublished">2017-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/17/再读数据结构/">再读数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>再次读《大话数据结构》这本书，回过头再跟着书系统的走一遍，记录巩固下基础。</p>
<h4 id="1-数据结构绪论"><a href="#1-数据结构绪论" class="headerlink" title="1. 数据结构绪论"></a>1. 数据结构绪论</h4><p>数据结构是相互之间存在一种或多种特定关系的数据元素集合。</p>
<h5 id="1-1-基本概念与术语"><a href="#1-1-基本概念与术语" class="headerlink" title="1.1 基本概念与术语"></a>1.1 基本概念与术语</h5><ul>
<li>数据： 描述客观事物的符号，是计算机中可以操作的对象。包括数值、字符、声音、图像、视频等等。</li>
<li>数据元素：组成数据的、有一定意义的基本单位。如人类中，数据元素是人，畜类中 牛、马、羊都是数据元素。</li>
<li>数据项：一个数据元素可以由若干个数据项组成。比如人这样数据元素，可以有眼、鼻、嘴、手等等这些数据项。<strong>数据项是数据不可分割的最小单位</strong>。在数据结构中，我们把数据项定义为最小单位，有助于更好的解决问题。</li>
<li>数据对象：是性质相同的数据元素的集合，是数据的子集。</li>
<li>数据结构：结构，简单的理解就是关系，即数据元素相互间关系形成的集合。</li>
</ul>
<h5 id="1-2-逻辑结构与物理结构"><a href="#1-2-逻辑结构与物理结构" class="headerlink" title="1.2 逻辑结构与物理结构"></a>1.2 逻辑结构与物理结构</h5><p><strong>物理结构是面向计算机的，逻辑机构是面向问题的。</strong> 其基本目标就是将数据及其逻辑关系存储到计算机的内存中。</p>
<h6 id="1-2-1-物理结构"><a href="#1-2-1-物理结构" class="headerlink" title="1.2.1 物理结构"></a>1.2.1 物理结构</h6><p>数据在计算机内的存储形式，也称之为存储结构。</p>
<ul>
<li><p><strong>顺序存储</strong> : 数据元素存放在地址连续的储存单元中。<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgmtzre5ouj20b402agm0.jpg" alt=""></p>
</li>
<li><p><strong>链式存储</strong>: 把数据元素存放在任意的存储单元里。数据元素的存储关系不能反映其逻辑关系，需要指针存放数据元素的地址。<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgmu3lswuwj209207v74z.jpg" alt=""></p>
</li>
</ul>
<h6 id="1-2-2-逻辑结构"><a href="#1-2-2-逻辑结构" class="headerlink" title="1.2.2 逻辑结构"></a>1.2.2 逻辑结构</h6><p>数据对象中数据元素之间的关系，逻辑结构分为以下四种：</p>
<ul>
<li><p><strong>集合结构</strong>：集合结构中的数据元素同属一个集合，他们之间没有任何关系。<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgmu3m85mdj208b07uq3p.jpg" alt=""></p>
</li>
<li><p><strong>线性结构</strong>: 线性结构中的数据元素之间是一对一的关系。<br><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3ml3gfj207a05nq3a.jpg" alt=""></p>
</li>
<li><p><strong>树形结构</strong>: 树形结构中的数据元素是一对多的关系。<br><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3n1lylj208f05gjru.jpg" alt=""></p>
</li>
<li><p><strong>图形结构</strong>: 图形结构中的数据元素是多对多的关系。<br><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fgmu3nm4wjj207y06kt99.jpg" alt=""></p>
</li>
</ul>
<p>另外，我们用示意图表示数据的逻辑结构时，要注意两点：</p>
<ul>
<li>每个数据元素看做一个节点，用圆圈表示</li>
<li>元素间的逻辑关系用节点之间的连线表示，如果这个关系是有方向的，那么用带箭头连线表示</li>
</ul>
<h5 id="1-3-抽象数据类型"><a href="#1-3-抽象数据类型" class="headerlink" title="1.3 抽象数据类型"></a>1.3 抽象数据类型</h5><h6 id="1-3-1-数据类型"><a href="#1-3-1-数据类型" class="headerlink" title="1.3.1 数据类型"></a>1.3.1 数据类型</h6><p>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<p>我的理解中，数据类型分一下：</p>
<ul>
<li>计算机只认0、1数值类型</li>
<li>编程语言既要面向计算机、又要面向开发人员，则基于0、1包装了便于开发使用的类型：整形、长整形、字符型、字符串等等</li>
<li>开发人员基于开发语言为了满足业务需要，可能需要包装更多的数据类型</li>
</ul>
<h6 id="1-3-2-抽象数据类型"><a href="#1-3-2-抽象数据类型" class="headerlink" title="1.3.2 抽象数据类型"></a>1.3.2 抽象数据类型</h6><p>对已有的数据类型进行抽象，就有了抽象数据类型。<br><strong>抽象数据类型（Abstract Data Type, ADT）: 是指一个数学模型及定义在该模型上的一组操作</strong>，后面会用以下格式来表示抽象数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名称</span><br><span class="line">DATA</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作1</span><br><span class="line">        初始条件</span><br><span class="line">        操作结果描述</span><br><span class="line">    操作2</span><br><span class="line">        ...</span><br><span class="line">    操作n</span><br><span class="line">        ...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure></p>
<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h4><h5 id="2-1-算法的定义"><a href="#2-1-算法的定义" class="headerlink" title="2.1 算法的定义"></a>2.1 算法的定义</h5><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h5 id="2-2-算法的特性"><a href="#2-2-算法的特性" class="headerlink" title="2.2 算法的特性"></a>2.2 算法的特性</h5><p>五个基本特性：输入、输出、有穷性、确定性和可行性</p>
<h5 id="2-3-算法效率的度量方法"><a href="#2-3-算法效率的度量方法" class="headerlink" title="2.3 算法效率的度量方法"></a>2.3 算法效率的度量方法</h5><h6 id="2-3-1-事后统计方法"><a href="#2-3-1-事后统计方法" class="headerlink" title="2.3.1 事后统计方法"></a>2.3.1 事后统计方法</h6><p>所谓“是骡子是马，拉出来溜溜”。比较容易想到的方法就是，通过对算法的数据测试，利用计算机的计时功能，来度量不同算法效率的高低，平常见到的<code>benchmark</code>就应该属于此类。</p>
<h6 id="2-3-2-事前统计方法"><a href="#2-3-2-事前统计方法" class="headerlink" title="2.3.2 事前统计方法"></a>2.3.2 事前统计方法</h6><p>为了对算法的评判更加科学，计算机前辈们研究出一种叫做事前分析估算的方法。<strong>事前分析估算方法：在计算机程序编制之前，依据统计方法对算法进行估算</strong><br>如以下有两种方法实现的指定范围内的求和实现：<br>第一种算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;        <span class="comment">/* 执行 1 次 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;      <span class="comment">/* 执行 n+1 次 */</span></span><br><span class="line">    sum = sum + i;              <span class="comment">/* 执行 n 次 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);              <span class="comment">/* 执行 1 次*/</span></span><br></pre></td></tr></table></figure></p>
<p>第二种算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;           <span class="comment">/* 执行 1 次*/</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>;            <span class="comment">/* 执行 1 次*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);              <span class="comment">/* 执行 1 次*/</span></span><br></pre></td></tr></table></figure></p>
<p>显然第一种算法执行了 <code>2n + 3</code>次，第二种算法是<code>3</code>次; 事实上两个算法的首、尾语句都是一样的，我们把循环看作一个整体，那么两个算法其实就是<code>n</code>次与<code>1</code>次的差距。算法好坏显而易见。</p>
<h5 id="2-4-函数的渐进增长"><a href="#2-4-函数的渐进增长" class="headerlink" title="2.4 函数的渐进增长"></a>2.4 函数的渐进增长</h5><p><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fgn1bv8smqj20fx046mye.jpg" alt=""><br>随着n的增加，算法A比算法B越来越好(执行的次数比B少)。于是我们可以得出结论，算法A总体上要算法B。 此时我们给出这样的定义，输入规模n，在没有限制的情况下，只要超过一个数值N，这个函数总是大于另一个函数，我们称函数是渐进增长的。<br>从中可以发现，随着n的增大，后面的<code>+3</code>、<code>+1</code>其实不影响最终算法变化，所以，<strong>我们可以忽略这些加法常数</strong>。<br>我们来看第二个例子，算法C是<code>4n + 8</code>，算法D是<code>2n² + 1</code>:<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgn1wgesojj20fq04pmyl.jpg" alt=""><br>对比可以看出：<strong>最高次项相乘的常数并不重要</strong></p>
<p><strong>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)</strong></p>
<h5 id="2-5-算法时间复杂度"><a href="#2-5-算法时间复杂度" class="headerlink" title="2.5 算法时间复杂度"></a>2.5 算法时间复杂度</h5><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的数量。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。<br>用大写的<code>O()</code>来体现算法时间复杂度的记法，称之为<code>大O记法</code>。比如<code>O(n)</code>、<code>O(1)</code>、<code>O(n²)</code>我们取的非官方名称分别为：线性阶、常数阶、平方阶。</p>
<h5 id="2-6-推导大O阶方法"><a href="#2-6-推导大O阶方法" class="headerlink" title="2.6 推导大O阶方法"></a>2.6 推导大O阶方法</h5><p>推导大O阶：</p>
<ol>
<li>用常数 1 取代运行时间中所有的加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶</li>
<li>如果最高阶存在且不为1，则去除与这个项相乘的常数</li>
</ol>
<h5 id="2-7-常见的时间复杂度"><a href="#2-7-常见的时间复杂度" class="headerlink" title="2.7 常见的时间复杂度"></a>2.7 常见的时间复杂度</h5><p><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fgqhynlnhuj208m05uq40.jpg" alt=""></p>
<h4 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3 线性表"></a>3 线性表</h4><p><strong>线性表：零个或多个数据元素的有限序列</strong><br>特点：</p>
<ul>
<li>序列，即元素间有顺序，若存在多个元素，则第一个元素无前驱，最后一个无后继，其他每个元素有且只有一个前驱和后继</li>
<li>有限</li>
</ul>
<h5 id="3-1-线性表的抽象数据类型"><a href="#3-1-线性表的抽象数据类型" class="headerlink" title="3.1 线性表的抽象数据类型"></a>3.1 线性表的抽象数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a₁,a₂...an&#125;，每个元素的类型均为DataType。其中第一个元素除外，每一个元素有且只有一个直接前驱元素；最后一个元素除外，每一个元素有且只有一个直接后继元素。数据之间的关系是一对一。</span><br><span class="line">Operation</span><br><span class="line">    InitList(*L): 初始化操作，建立一个空的线性表 L。</span><br><span class="line">    ListEmpty(L): 若线性表为空，返回true，否则返回false。</span><br><span class="line">    ClearList(*L): 将线性表清空。</span><br><span class="line">    GetElem(L, i, *e): 将线性表L中的第i个元素返回给e。</span><br><span class="line">    LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。</span><br><span class="line">    ListInsert(L*, i, e): 在线性表L中的第i个位置插入新元素e。</span><br><span class="line">    ListDelete(L*, i, *e): 删除线性表L中第i个位置的元素，并用e返回其值。</span><br><span class="line">    ListLength(L): 返回线性表L的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>对于实际问题中涉及的更复杂的操作，完全可以基于以上的基本操作的组合来实现。</p>
<h5 id="3-2-线性表的顺序存储结构"><a href="#3-2-线性表的顺序存储结构" class="headerlink" title="3.2 线性表的顺序存储结构"></a>3.2 线性表的顺序存储结构</h5><p>下面看一下线性表的两种物理存储结构的第一种，顺序存储结构：<strong>用一段连续的存储单元依次存储线性表的数据元素。</strong><br>顺序存储示意图：<br><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fgqj7mkv1hj20b901rt8p.jpg" alt=""><br>在内存中申请一段连续的地址，用来存储元素，那么这段地址长度意味着这个线性表的长度，实际使用个数代表元素实际长度。</p>
<h6 id="3-2-1-顺序结构的插入与删除"><a href="#3-2-1-顺序结构的插入与删除" class="headerlink" title="3.2.1 顺序结构的插入与删除"></a>3.2.1 顺序结构的插入与删除</h6><p>排队插入示意图：<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgqjl5xa81j20ce07n0uc.jpg" alt=""><br>插入算法思路：</p>
<ul>
<li>检查插入位置</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(java ArrayList Arrays.copy 新开辟空间)</li>
<li><strong>从最后元素向前遍历至第i个位置，分别将他们向后移动一位</strong> ——(插入位置的后面的元素都需要站起来往后挪位置)</li>
<li>新元素插入位置i处</li>
<li>表长加1</li>
</ul>
<p>删除示意图：<br><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fgqjl6i8dcj20eg08tmys.jpg" alt=""><br>删除算法思路：</p>
<ul>
<li>检查删除位置</li>
<li>去除删除元素</li>
<li><strong>从删除元素位置开始遍历到最后一个元素，分别将他们向前移动一个位置</strong> </li>
<li>表长减1</li>
</ul>
<p>优点：</p>
<ul>
<li>无需为表达元素间的逻辑关系而增加存储空间</li>
<li>可以快速地取表中任一位置的元素</li>
</ul>
<p>缺点:</p>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>确定存储空间大小的问题(多了浪费，少了不够用，再申请影响性能)</li>
</ul>
<h5 id="3-4-线性表的链式存储结构"><a href="#3-4-线性表的链式存储结构" class="headerlink" title="3.4 线性表的链式存储结构"></a>3.4 线性表的链式存储结构</h5><p>线性表顺序结构存储最大的问题就是插入、删除时，其他位置的元素需要挪位置，链式存储结构的线性表能够解决此问题。链式存储结构不考虑相邻位置，那有空位就到哪里，只是让每个元素知道它的下一个元素的位置在哪里。<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgmu3lswuwj209207v74z.jpg" alt=""></p>
<ul>
<li><strong>节点（Node）分为两部分，数据域与指针域，数据域存储元素数据信息，指针域存储下一个节点地址。</strong><br>单链表中，用C语言描述如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/*定义LinkList*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="3-4-1-单链表的读取"><a href="#3-4-1-单链表的读取" class="headerlink" title="3.4.1 单链表的读取"></a>3.4.1 单链表的读取</h6><p>在顺序存储结构的线性表中，我们根据元素位置取元素是非常容易的。但在单链表中，没有办法一开始就知道，必须得从头开始找。<br>获取链表第i个数据的算法思路：</p>
<ul>
<li>声明一个节点p指向链表第一个节点，初始化j从1开始；</li>
<li>当 j&lt;i 时，就遍历链表，让p的指针向后移动，不断指向下一节点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在</li>
<li>否则查找成功，返回节点p的数据</li>
</ul>
<p>单链表中没有定义表长，所以事先不知道要循环多少次，其核心思想就是<strong>工作指针后移</strong></p>
<h6 id="3-4-2-单链表的插入与删除"><a href="#3-4-2-单链表的插入与删除" class="headerlink" title="3.4.2 单链表的插入与删除"></a>3.4.2 单链表的插入与删除</h6><p>插入示意图：<br><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fgqlowjswxj207n04t3yr.jpg" alt=""><br>我们可以看出来，新元素的插入，主要操作：新元素指针域指向后一个元素，更新前一个元素的指针域指向新元素。</p>
<p>删除示意图：<br><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fgqlowx93ej20ax04vaan.jpg" alt=""><br>同样可以看出来，元素的删除，主要操作：被删除元素的前一个元素更新指针域为被删除元素的指针域地址、销毁(返回)被删除元素</p>
<h5 id="3-5-静态链表"><a href="#3-5-静态链表" class="headerlink" title="3.5 静态链表"></a>3.5 静态链表</h5><p><strong>用数组描述的链表叫做静态链表</strong> ，数组元素由两个数据域组成：</p>
<ul>
<li>data 存放数据元素</li>
<li>cur 游标，相当于单链表中的next指针，存放该元素的后继元素在数组中的下表</li>
</ul>
<h5 id="3-6-循环链表"><a href="#3-6-循环链表" class="headerlink" title="3.6 循环链表"></a>3.6 循环链表</h5><p><strong>将终端节点的指针指向头结点</strong>，是整个单链表形成一个环，这种头尾相连的单链表称为单循环链表。</p>
<h5 id="3-7-双向链表"><a href="#3-7-双向链表" class="headerlink" title="3.7 双向链表"></a>3.7 双向链表</h5><p><strong>在单链表的节点中增加一个指针，将其指向前驱节点</strong></p>
<h5 id="3-8-线性表总结"><a href="#3-8-线性表总结" class="headerlink" title="3.8 线性表总结"></a>3.8 线性表总结</h5><p><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgsrksslsdj20fd047jsl.jpg" alt=""></p>
<h4 id="4-栈与队列"><a href="#4-栈与队列" class="headerlink" title="4 栈与队列"></a>4 栈与队列</h4><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong></p>
<p><strong>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表</strong></p>
<h5 id="4-1-栈"><a href="#4-1-栈" class="headerlink" title="4.1 栈"></a>4.1 栈</h5><p>手枪的弹匣就像是栈，放子弹进弹匣就是入栈，开枪打出子弹则是出栈。<br><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fgsrzqdlw9j20fh05g3zd.jpg" alt=""></p>
<h6 id="4-1-1-栈的抽象数据类型"><a href="#4-1-1-栈的抽象数据类型" class="headerlink" title="4.1.1 栈的抽象数据类型"></a>4.1.1 栈的抽象数据类型</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(stack)</span><br><span class="line">DATA</span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素有前驱、后继关系。</span><br><span class="line">Operation</span><br><span class="line">    InitStack(*s): 初始化操作，建立一个空栈S。</span><br><span class="line">    DestoryStack(*S): 若栈存在，则销毁它。</span><br><span class="line">    ClearStack(*S): 将栈清空。</span><br><span class="line">    StackEmpty(*S): 若栈为空，返回true，否则返回false。</span><br><span class="line">    GetTop(S, *e): 若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">    Push(*S, e): 若栈存在，则插入新元素e到S中，并成为栈顶元素。</span><br><span class="line">    Pop(*S, *e): 删除栈S中的栈顶元素，并用e返回其值。</span><br><span class="line">    StackLength(S): 返回栈S中的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>由于<code>栈</code>本身是一个线性表，所以之前提到过的线性表的顺序存储和链式存储，对于<code>栈</code>也同样适用。</p>
<h6 id="4-1-2-栈的顺序存储结构"><a href="#4-1-2-栈的顺序存储结构" class="headerlink" title="4.1.2 栈的顺序存储结构"></a>4.1.2 栈的顺序存储结构</h6><p>看下栈的结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElementType; <span class="comment">/* SElementType 类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElementType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;    <span class="comment">/* 用于记录栈顶 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p>
<p>栈就像”阉割”版的线性表，强调的是栈顶的操作，高级语言中一般会提供<code>push</code>、<code>pop</code>、<code>peek</code>这样的方法。<br>这里用java简单的实现了顺序存储的栈<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/MyStack.java" target="_blank" rel="noopener">MyStack</a></p>
<h6 id="4-1-3-栈的链式存储结构"><a href="#4-1-3-栈的链式存储结构" class="headerlink" title="4.1.3 栈的链式存储结构"></a>4.1.3 栈的链式存储结构</h6><p>栈的链式存储结构，简称链栈。<br>栈的操作都是在栈顶上的，那链式存储的栈将栈顶放到链表的头部还是尾部呢？ 链表本身有头指针，栈也需要栈顶指针，所以合二为一，将栈顶放在单链表的头部。<br>这里就不过多介绍链式存储的栈了，其对比顺序存储栈的特点体现在链式存储上。</p>
<h5 id="4-2-队列"><a href="#4-2-队列" class="headerlink" title="4.2 队列"></a>4.2 队列</h5><p>队列就像排队买票，强调的是新来的人排在队尾，买票的人在队头，强调先进先出。</p>
<h6 id="4-2-1-队列的抽象数据类型"><a href="#4-2-1-队列的抽象数据类型" class="headerlink" title="4.2.1 队列的抽象数据类型"></a>4.2.1 队列的抽象数据类型</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">DATA</span><br><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱、后继关系。</span><br><span class="line">Operation</span><br><span class="line">    InitQueue(*Q): 初始化队列Q。</span><br><span class="line">    DestoryQueue(*Q): 销毁队列Q。</span><br><span class="line">    ClearQueue(*Q): 清空队列Q。</span><br><span class="line">    QueueEmpty(Q): 若队列为空，则返回false，否则返回true。</span><br><span class="line">    GetHead(Q, *e): 若队列Q非空，则用e返回队列Q的队头元素。</span><br><span class="line">    EnQueue(*Q, e): 入队列，插入新的元素e至队列Q中并成为队尾。</span><br><span class="line">    DeQueue(*Q, e): 出队列，删除队列Q中的队头元素，并用e返回。</span><br><span class="line">    QueueLength(Q): 返回队列Q的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h6 id="4-2-2-循环队列"><a href="#4-2-2-循环队列" class="headerlink" title="4.2.2 循环队列"></a>4.2.2 循环队列</h6><p>同样，队列也是一种特殊的线性表，也有顺序存储和链式存储。</p>
<p>队列顺序存储的问题：与顺序存储的线性表不同，如果单纯用数组首个元素作为队列头，最后一个元素作为队列尾，那么元素出队列，数组内的元素就需要往前移动，很明显队列就是专门用来处理入队、出队的数据类型，不像线性表的数据是单调读多、单调写多。所以就有了循环队列来解决这个问题。<br>头尾相连顺序存储结构的队列。<br>使用<code>front</code>表示头，<code>rear</code>表示尾。<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgv54pvgd7j209z040glq.jpg" alt=""><br>这样有一个问题，空队列时 <code>front == rear</code>、队列满时也是如此，那怎么区分呢？<br>有两种方法：</p>
<ul>
<li>另外定义一个flag，用来记录队列为空或已满</li>
<li>队列留空一格，也就是说队列满时，数组中还有一个空闲单元</li>
</ul>
<p>用java实现的循环队列：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/MyArrayQueue.java" target="_blank" rel="noopener">MyArrayQueue.java</a></p>
<h4 id="5-串"><a href="#5-串" class="headerlink" title="5. 串"></a>5. 串</h4><p><code>串</code>是由零个或多个字符组成的有限序列，又名字符串。</p>
<h5 id="5-1-串的比较"><a href="#5-1-串的比较" class="headerlink" title="5.1 串的比较"></a>5.1 串的比较</h5><p>两个数字很容易比较大小。<code>2 &gt; 1</code>，这完全正确，可是两个字符串比较呢？比如“silly”、“stupid”这样同样表达“愚蠢的”单词字符串，它们在计算机中的大小取决于挨个字母的前后顺序。首个字母“s”忽相等，第二个字母“i”字母比“t”字母靠前，所以<code>i &lt; t</code>，故 <code>silly &lt; stupid</code>。<br>实际上，串的比较是通过组成串的字符之间的编码来进行的，比如这里的纯英文字母可以采用<code>ascii</code>编码来比较。</p>
<h5 id="5-2-串的抽象数据类型"><a href="#5-2-串的抽象数据类型" class="headerlink" title="5.2 串的抽象数据类型"></a>5.2 串的抽象数据类型</h5><p>串的逻辑结构和线性表和相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕串的字符是“123”，或者“2010-10-10”，其中每个元素都是字符，它们只能理解为长度为3和长度为10的字符串。<br>因此，对于串的基本操作与线性表的操作是由很大差别的。线性表关注的是单个元素的操作，比如操作一个元素、插入或删除一个元素，但字符串更多的是查找字符串位置、得到指定位置子串、替换子串等操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(String)</span><br><span class="line">Data</span><br><span class="line">    串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    StrAssign(T, *chars): 生成一个其值等于字符串常量chars的串T。</span><br><span class="line">    StrCopy(T, S): 由串S复制得串T。</span><br><span class="line">    ClearString(S): 将串清空。</span><br><span class="line">    StringEmpty(S): 若串S为空，返回true，否则返回false。</span><br><span class="line">    StrLength(S): 返回串S的元素个数，即串长度。</span><br><span class="line">    StrCompare(S, T): 若S&gt;T，返回值大于0，若S=T，返回0，若S&lt;T，返回值小于0。</span><br><span class="line">    Concat(T, S1, S2): 用T返回S1和S2联接而成的新串。</span><br><span class="line">    SubString(Sub, S, Pos, len): 串S存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1，用Sub返回串S的第pos个字符起长度为len的子串。</span><br><span class="line">    Index(S, T, Pos): 串S和T存在，T是非空串，1≤pos≤StrLenght(S)。若主串S中存在和串T值相等的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则为0。</span><br><span class="line">    Replace(S, T, V): 串S、T、V存在，T是非空串。用V替换主串S中出现的所有与T相等不重叠的子串。</span><br><span class="line">    StrInsert(S, pos, len): 串S、T存在，1≤pos≤StrLength(S)+1。在串S的第pos个字符之前插入串T。</span><br><span class="line">    StrDelete(S, pos, len): 串S存在，1≤pos≤StrLenght(S)-len+1。从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure></p>
<h5 id="5-3-串的存储结构"><a href="#5-3-串的存储结构" class="headerlink" title="5.3 串的存储结构"></a>5.3 串的存储结构</h5><h6 id="5-3-1-串的顺序存储结构"><a href="#5-3-1-串的顺序存储结构" class="headerlink" title="5.3.1 串的顺序存储结构"></a>5.3.1 串的顺序存储结构</h6><p>串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符串序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长的数组来定义。</p>
<h6 id="5-3-2-串的链式存储结构"><a href="#5-3-2-串的链式存储结构" class="headerlink" title="5.3.2 串的链式存储结构"></a>5.3.2 串的链式存储结构</h6><p>串的链式存储结构与线性表是相似的，实际中链式存储的串除了在连接串有一定方便之外，总的来说不如顺序存储灵活。</p>
<h5 id="5-4-朴素的模式匹配算法"><a href="#5-4-朴素的模式匹配算法" class="headerlink" title="5.4 朴素的模式匹配算法"></a>5.4 朴素的模式匹配算法</h5><p><strong>子串的定位操作通常称作串的模式匹配</strong>，比如要从主串S=”goodgoogle”中，找到T=”google”这个子串的位置。我们通常需要下面的的步骤：</p>
<ol>
<li>主串S第1位开始，S与T前三个字母都匹配成功，但第4个字母d与g匹配失败。<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgyoi52ttdj20al030glv.jpg" alt=""></li>
<li>主串S从第2位开始，o与g匹配失败<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgyoi5ec6yj20al039wer.jpg" alt=""></li>
<li>主串S从第3位开始，o与g匹配失败<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgyoi5qwdyj20ar02yaad.jpg" alt=""></li>
<li>主串S从第4位开始，d与g匹配失败<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgyoi6b3vaj20al039glv.jpg" alt=""></li>
<li>主串S从第5位开始，6个字母全部匹配，匹配成功<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgyoi6q87qj20aj02x74j.jpg" alt=""><br>总的来说，就是对主串的每一个字符串作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完为止。<br>下面我们用基本的数组来实现这个算法：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/CharSequenceCompare.java" target="_blank" rel="noopener">CharSequenceCompare.java</a><br>最好的情况就是一开始就匹配成功，比如“googlegood”中去找“google”时间复杂度为O(1)。平均是(n+m)/2次查找，复杂度为O(n+m)，最坏的情况O((n-m+1)*m)。对于计算机来说，都是处理的二进制0和1的串，一个字符的ASCII码看成是8位的二进制位01，模式匹配操作可说是随处可见，刚才的算法显得太过低效了。</li>
</ol>
<h5 id="5-5-KMP模式匹配算法"><a href="#5-5-KMP模式匹配算法" class="headerlink" title="5.5 KMP模式匹配算法"></a>5.5 KMP模式匹配算法</h5><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作，简称KMP算法。</p>
<h6 id="5-5-1-KMP模式匹配算法原理"><a href="#5-5-1-KMP模式匹配算法原理" class="headerlink" title="5.5.1 KMP模式匹配算法原理"></a>5.5.1 KMP模式匹配算法原理</h6><p>如果主串<code>S=abcdefgab</code>，匹配串<code>T=abcdex</code>，如果用前面的朴素算法的话，前5个字母，两个串完全相等，直到第6个字母，“f”与“x”不等，如图：<br><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fgzrnphd0zj20jk08w0v6.jpg" alt=""><br>接下来，按照朴素算法，2、3、4、5、6，首字符与子串T的首字符均不等。<br>似乎这也是理所当然，原来的算法就是这么设计的。仔细观察发现，对于要匹配的子串T来说，“abcdex”首字母“a”与后面的串“bcdex”中任意一个字符都不相等，那么对于图中①来说，前5位字符分别相等，意味着子串T的首字符“a”不可能与S串的第2位到第5位字符相等。即②、③、④、⑤的判断都是多余的。<br>注意这里是理解KMP算法的关键。如果我们知道T串中<strong>首字符“a”与T中后面的字符均不相等(注意这是前提)</strong>。而T串的第二位的“b”与S串中的“b”在图中①已经判断是相等的，那么也就意味着T串中首字符“a”与S串中第二位“b”是不需要判断也知道他们是不可能相等的，这样上图中②这一步就可以省略。如下：<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fgzst8a4l1j20g30523zr.jpg" alt=""><br>同样道理，在我们知道T串首字符“a”与T中后面的字符均不相等的前提下，T串的“a”与S串后面的“c”、“d”、“e”也都可以在①之后就可以确定不相等，所以算法②③④⑤没有必要，只保留①⑥即可，如下图：<br><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fh0pzm8kh6j20l003ygmf.jpg" alt=""><br>跟着书中的这些文字转的有些晕了，停顿耗费了不少时间，跟着例子敲了以下的实现，就此带过了！<br>java实现：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/CharSequenceKMPCompare.java" target="_blank" rel="noopener">CharSequenceKMPCompare.java</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/10/17/再读数据结构/" data-id="ck2n0fsj60050ebrjrbvhwllu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程/">编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端与后端的HTTP通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/12/前端与后端的HTTP通信/" class="article-date">
  <time datetime="2017-07-12T07:10:20.000Z" itemprop="datePublished">2017-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>►<a class="article-category-link" href="/categories/HTTP/通信/">通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/12/前端与后端的HTTP通信/">前端与后端的HTTP通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理解了，不用了又淡忘了，渐渐模糊混淆，感觉耗费大把的经历。</p>
<h2 id="前端与后端的通信方式"><a href="#前端与后端的通信方式" class="headerlink" title="前端与后端的通信方式"></a>前端与后端的通信方式</h2><p>通信，其实也就是网络通信，所以从<code>Chrome</code>的控制台的<code>Network</code>可以看到前端与后端的通信，如下图：<br><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fhfr4aok4rj20au00udfn.jpg" alt=""></p>
<p>我暂时打算记录一下开发经常碰到的问题。</p>
<h2 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h2><p>这里的介绍不会一应俱全，如果有需要你可以去参考一些权威指南。跟着自己的思考，带着一些问题来记录。</p>
<h4 id="HTTP-是无状态"><a href="#HTTP-是无状态" class="headerlink" title="HTTP 是无状态"></a>HTTP 是无状态</h4><p>就像你在围墙外面，我在围墙里面，我们通过扔纸条的方式来通信，我不知道你是谁。<br>无状态带来的问题很明显，如果有两个人站在墙外，我不知道你是谁，那我们就不能聊一些私密的话题了。<br>在互联网，乃至整个现实世界，要绝对的确认一个人的身份是不可能的，网络上的信息可以被截取、模仿，现实世界有人工智能，就像那句“我不是李开复,我是人工智能。”</p>
<h4 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h4><p>请求与响应就类似传递的信件，一部分是正文，一部分是必要的附加信息比如地址、身份等等。所以HTTP的“信件”分为了head、body部分。像一封信一样，虽然分为head、body但是他们是在一个报文内的。</p>
<p>HTTP/1.1 head 是文本(ASCII编码), body 可以是文本，也可以是二进制。<br>HTTP/2 则是一个彻底的二进制协议，头、数据体都是二进制，并且统称为“帧”（frame）：头信息帧、数据帧，因为帧可以方便的扩展，解析更为方便，HTTP/2已经定义了近十种帧。</p>
<p>来看下一个Ajax完整的请求报文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.tzb360.com/tzb-api/api/public/login HTTP/1.1</span><br><span class="line">Host: www.tzb360.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 47</span><br><span class="line">Origin: https://www.tzb360.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Accept: */*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Referer: https://www.tzb360.com/html/common/login.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Cookie: userId=test01; io=j8nS4_Ph2Jaq1aSWAFX4</span><br><span class="line"></span><br><span class="line">loginName=cqtl123&amp;password=tk110234&amp;imgVefCode=</span><br></pre></td></tr></table></figure></p>
<p>可以看出：</p>
<ul>
<li><strong>14行前的是请求头，即head；14行之后的是请求体，即body</strong></li>
<li><strong>14行本身是分隔，其内容是<code>空行</code>，即CR+LF（Carriage Return 回车， Line Feed 换行）</strong><ul>
<li>打字机，在纸张上打印字时，分为纵向移动、横向移动。纸张的一行打满后，横向位置回到起点，即携带纸张的车子回到起点即回车；纵方向上向下移动一行，即换行。</li>
<li>unix 结尾只有换行“\n”，window下是“\r\n”。现象就是：win下的文件在unix下会出现“^M”符号；unix下的文件到win下会连接成一行。</li>
<li><a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html?bsh_bid=705296311" target="_blank" rel="noopener">关于回车与换行的参考</a></li>
</ul>
</li>
<li><strong>请求地址、cookie、请求内容长度等等都是在请求头内的</strong></li>
</ul>
<p>响应头报文如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.9.9</span><br><span class="line">Date: Tue, 11 Jul 2017 06:02:51 GMT</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 928</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: TZB_SESSIONID=5788439a2c524880a5f79c6b81e97fcf; Path=/; HttpOnly</span><br><span class="line"></span><br><span class="line">&#123;&quot;code&quot;:&quot;0000&quot;,&quot;data&quot;:&#123;&#125;,&quot;msg&quot;:&quot;操作成功&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样可以看出，也是使用<code>\r\n</code>作为头、体的分隔符的。</p>
<h4 id="发起请求与后台接收请求"><a href="#发起请求与后台接收请求" class="headerlink" title="发起请求与后台接收请求"></a>发起请求与后台接收请求</h4><p>编码方面这前端请求主要用：<code>XMLHttpRequest/fetch</code>来实现，后台用<code>Spring MVC</code>来实现，只涉及到POST与GET方式的请求。<br>首先有必要讲下请求头中易忘、易混淆的字段：</p>
<ol>
<li><code>Content-type</code> ，内容类型，即描述body，作为请求头时，一般有以下4种分类来描述body：<ul>
<li><code>multipart/form-data;</code> 类似页面表单，支持多字段、多类型。此类型请求体中会有对每个子段的的描述，就像请求体中分了多个子的请求头、请求体。</li>
<li><code>application/x-www-form-urlencoded</code> “=”号相隔的ascii键值串，非ascii字符与特殊字符需要转码，js中可以使用<code>encodeURIComponent</code>。请求体格式：<code>a=value-a&amp;b=value-b</code></li>
<li>raw: <code>text/plain</code>、<code>application/json</code>、<code>text/xml</code>，这一类请求意味着请求体是一块整体，告诉服务器按照<code>Content-type</code>来解析这块整体。</li>
<li>binary: 可以上传单个文件，其body中存储了二进制内容，默认没有设置<code>Content-type</code>。</li>
</ul>
</li>
<li>Request Method <ul>
<li>POST/PUT/PATCH 可以包含请求体，而其他如<strong>GET是不包括请求体的</strong>。页面上的<code>form</code>如果<code>不科学</code>的使用，会引起误解，比如<code>method=GET</code>，提交时会忽略action问号后的参数，自动将表单内的input转换为地址的QueryString。当<code>method=POST</code>提交时，如果action的QueryString与表单内的字段都会被提交，后台可以从两个来源中得到同样的参数，而可能值不同。</li>
</ul>
</li>
</ol>
<p>所以有必要强调的是，一般意义上的参数取法是当后台判断请求方法是<code>GET</code>时，取参从QueryString中取，当判断请求的方法是<code>POST</code>时，取参从FormData中取。后台<strong>可以</strong>取到<code>POST</code>请求的QueryString，GET请求是无body的。</p>
<p>错误的请求头设置，会导致后台不能正常的接收数据，请根据具体的场景选择请求方式、<code>Content-type</code>。</p>
<p>开发中会碰到一些复杂嵌套的对象需要传输，一般是前端设置<code>ContentType: application/json</code> 也就是body是一个raw，作为一个整体，后端使用<code>@RequestBody</code>描述对象。</p>
<h6 id="XMLHttpRequest-与-fetch"><a href="#XMLHttpRequest-与-fetch" class="headerlink" title="XMLHttpRequest 与 fetch"></a>XMLHttpRequest 与 fetch</h6><p>使用<code>jquery</code>发起ajax请求时，会有<code>data</code>部分的参数设置，jquery发现请求是get时，会把data对象作为head的queryString提交，如果是POST，则会将data放置到body部分。</p>
<p><code>fetch</code>方法默认情况下不会发送本地的cookie到服务器，注意如果需要依赖cookie，需要配置<code>credentials</code>，其配置值有：<code>omit</code>、<code>same-origin</code>、<code>include</code>，其意分别为不携带、同源携带、一直携带。更多关于fetch的信息可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener">MDN-GlobalFetch</a></p>
<h4 id="HTTP-协议版本"><a href="#HTTP-协议版本" class="headerlink" title="HTTP 协议版本"></a>HTTP 协议版本</h4><p>这里再简单的记录下HTTP的几个版本的区别: （需要明白协议的实现要客户端、服务端共同完成，即新的浏览器、新的Web服务（Nginx/Apache/IIs等））</p>
<ul>
<li>HTTP/1.0 每个TCP只能发送一个请求。发完数据就关闭</li>
<li><p>HTTP/1.1 (当今主流) </p>
<ul>
<li>持久连接<code>Connection: keep-alive</code>，TCP默认不关闭，可以供多个请求复用，不用手动声明。连接没有活动，客户端就可以主动关闭连接了。规范的请求是，客户端发送最后一个请求时发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。一般对于同一个域名，浏览器允许建立6个持久连接。</li>
<li>管道机制（pipelining），同一个TCP中可发送多个请求</li>
<li>Content-Length字段，一个TCP连接中有多个请求或响应，用长度区分数据边界</li>
<li>分块传输编码，<code>Content-length</code>的前提是在传输之前就得知道要传输的数据长度，对于一些耗时久、数据块大的操作来说，意味长时等待，这不太合理。更好的办法是产生一块数据，发送一块数据。使用<code>Transfer-Encoding: chunked</code>来表明数据是数量未定的数据块组成，每个非空数据块之前，会有一个16进制的数值，表示这个块的长度，最后一个大小为0的块，表示本轮数据传输完毕。下面有个<code>chunked</code>的响应例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 12 Jul 2017 05:47:23 GMT</span><br><span class="line"></span><br><span class="line">7a</span><br><span class="line">&#123;&quot;paramters&quot;:&#123;&quot;key-a&quot;:[&quot;value-a&quot;],&quot;a&quot;:[&quot;value-a&quot;],&quot;b&quot;:[&quot;value-b&quot;]&#125;,&quot;queryString&quot;:&quot;key-a=value-a&quot;,&quot;autoInject-a&quot;:&quot;value-a&quot;&#125;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTTP/2 </p>
<ul>
<li>二进制协议</li>
<li>多工，复用的TCP不要求请求与应答顺序一一对应，避免了“队头阻塞”，这样能达到双向、实时，即多工（Multiplexing）</li>
<li>数据流，一个连接内的数据包，可能归属不同的请求或响应，每个请求或响应的所有数据包，称之为一个数据流（stream）。每个stream都有一个编号，客户端请求的stream编号为奇数，服务端发起的stream为偶数。</li>
<li>头信息压缩，无状态导致很多字段都是重复的，比如Cookie和UserAgent等。因此引入了头信息压缩机制（header compression），一方面压缩传输，一方面server与client共同维护一张头表，所有字段存入这个表，生成一个索引号，只发索引号来减少传输。</li>
<li>服务器推送，允许服务器未经请求，主动向客户端发送资源。以前是请求-返回网页，解析网页源码，请求网页依赖的静态资源；而现在可以主动把这些依赖的静态资源随着网页一起发给客户端。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/07/12/前端与后端的HTTP通信/" data-id="ck2n0fsj80054ebrjbcjqnzak" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java多线程补充-LockSupport类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/java多线程补充-LockSupport类/" class="article-date">
  <time datetime="2017-06-21T02:32:32.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/java多线程补充-LockSupport类/">java多线程补充-LockSupport类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在之前的<a href="http://blog.ouronghui.com/2017/04/06/java多线程编程核心技术">java多线程编程核心技术</a>文章中，主要是记录了书<code>《Java多线程编程核心技术》</code>的一些内容，其中没有介绍到<code>LockSupport</code>类，但是这个类在<code>jdk</code>源码中也经常会碰到，所以特意拿出来再看一番。</p>
<h5 id="既然已经有了ReentrantLock，为什么还需要LockSupport呢？"><a href="#既然已经有了ReentrantLock，为什么还需要LockSupport呢？" class="headerlink" title="既然已经有了ReentrantLock，为什么还需要LockSupport呢？"></a>既然已经有了<code>ReentrantLock</code>，为什么还需要<code>LockSupport</code>呢？</h5><p>主要区别在于他们面向的对象不同。</p>
<p>我们先简单来回顾下<code>ReentrantLock</code>的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reviewReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"thread-A doXX"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 记得 finally 中 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"thread-A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"thread-B doXX"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"thread-B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>lock 通常需要在finally中释放</li>
<li>其它线程取锁将被阻塞</li>
</ul>
<p>接下来看下<code>LockSupport</code>要怎么使用，看了下<code>LockSupport</code>的源码有以下特点：</p>
<ul>
<li>构造函数是私有的，说明不可手动实例化</li>
<li>其它的方法都是静态的，说明不用实例化可以直接拿来使用</li>
</ul>
<h5 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useLockSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，如果许可可用将立即返回，否则线程将进入休眠状态</span></span><br><span class="line">    System.out.println(<span class="string">"block."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行此方法会发现，控制台的Terminate一直是红色，”block”也不会输出，说明当前线程在park后就被阻塞了</li>
<li><strong>线程许可默认是被占用的</strong></li>
</ul>
<p>可以使用<code>unpark(thread)</code>先取的许可，再执行<code>park</code>,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useLockSupport2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    LockSupport.unpark(thread); <span class="comment">// 为给定的线程提供许可；如果线程在park上被阻塞，那么它将被解除阻塞。否则它的下一次 park 执行将不会被阻塞</span></span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，因为上一步已经提供了，所以会直接往下执行</span></span><br><span class="line">    System.out.println(<span class="string">"block"</span>);  <span class="comment">// 像没事人样，正常输出</span></span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，前面的许可已经被使用了，故此线程将会进入休眠，等待许可</span></span><br><span class="line">    System.out.println(<span class="string">"block 2"</span>);  <span class="comment">// 阻塞，不会被输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>“block”会正常输出。</li>
<li>“block 2”不会输出，线程如果重复调用<code>park</code>，那么线程将会一直阻塞下去，故<strong>LockSupport是不可重入的</strong> ，对比而言<code>ReentrantLock</code>是可重入的，一个线程可以多次获取同一把锁，<code>lock.getHoldCount()</code>方法会得到当前线程持有该锁的个数，也就是<code>lock()</code>方法的次数。总的来说就是：<strong><code>lock.lock()</code>可以重复调用(线程内执行相应的<code>lock.unlock()</code>)，而<code>LockSupport.park()</code>则是单次不重复的，只可等待其他线程<code>LockSupport.unpark(t)</code></strong></li>
</ul>
<h5 id="线程等待许可时，被打断时会怎样？"><a href="#线程等待许可时，被打断时会怎样？" class="headerlink" title="线程等待许可时，被打断时会怎样？"></a>线程等待许可时，被打断时会怎样？</h5><p>下面我们看下线程对应中断会怎样响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end - start &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            end = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"after 1 second: acount=%s\n"</span>, count);</span><br><span class="line">        </span><br><span class="line">        LockSupport.park(); <span class="comment">// 等待许可</span></span><br><span class="line">        System.out.println(<span class="string">"thread-child over."</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;, <span class="string">"thread-child"</span>);</span><br><span class="line">    </span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    t.interrupt(); <span class="comment">// 中断线程</span></span><br><span class="line">    System.out.println(<span class="string">"main over!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after 1 second: acount=85732003</span><br><span class="line">main over!</span><br><span class="line">thread-child over.true</span><br></pre></td></tr></table></figure></p>
<ul>
<li>并没有抛出异常，程序照常往下执行</li>
</ul>
<h4 id="跳回前面的问题小结下-ReentrantLock-与-LockSupport"><a href="#跳回前面的问题小结下-ReentrantLock-与-LockSupport" class="headerlink" title="跳回前面的问题小结下 ReentrantLock 与 LockSupport"></a>跳回前面的问题小结下 ReentrantLock 与 LockSupport</h4><p><code>ReentrantLock</code> 关注线程内部取锁<code>lock()</code>，<code>unlock()</code>的问题，都是<strong>线程内部代码</strong>在掌控锁，自己关注方法内的业务逻辑。<br><code>LockSupport</code> 更倾向线程间的协作，一个线程“LockSupport.park()”等待许可，另外一个线程来“唤醒”等待的线程。</p>
<p><code>LockSupport</code>像是站在线程间的指挥家，可以指定唤醒哪个线程(<code>LockSupport.unpark(thread)</code>)、什么时候唤醒等。</p>
<p>更准确的理解可以去查看<code>LockSupport</code>的源码注释。</p>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://blog.csdn.net/aitangyong/article/details/38373137" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></li>
<li><a href="https://www.zhihu.com/question/26471972/answer/74773092" target="_blank" rel="noopener">Java中Lock和LockSupport的区别到底是什么？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/21/java多线程补充-LockSupport类/" data-id="ck2n0fsih0040ebrjjvvi6t7a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/字符编码/" class="article-date">
  <time datetime="2017-06-21T02:31:46.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/字符编码/">字符编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从刚接触计算机理论起，就被灌输这是一台只认识0、1的机器，数字、字符串、声音、图像、视频等都可以在计算机中表示，这就是所谓的数字化吧。</p>
<h3 id="大于0、1的整数表示"><a href="#大于0、1的整数表示" class="headerlink" title="大于0、1的整数表示"></a>大于0、1的整数表示</h3><p>既然说到了，字符编码，想必已经理解了这个问题<code>只有0、1怎么表示2、3、4这些数字呢？</code>，表示如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000 -&gt; 0</span><br><span class="line">0001 -&gt; 1</span><br><span class="line">0010 -&gt; 2</span><br><span class="line">0011 -&gt; 3</span><br><span class="line">0100 -&gt; 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>采用进位使用多个bit位来表示就可以了，小数的表示这里就不展开说了，有兴趣的可以从这里看。</p>
<h4 id="TODO-内存位置"><a href="#TODO-内存位置" class="headerlink" title="TODO: 内存位置,"></a>TODO: 内存位置,</h4><p>bit 单元格，内存里面茫茫一片的<code>01...</code>， 内存并不去区分这个<code>01</code>是<code>十进制1中的01</code>，还是<code>10进制2中的01</code>  ，怎么区分这个交由具体的程序去做， <a href="http://www.cnblogs.com/little-YTMM/p/5058354.html" target="_blank" rel="noopener">关于CPU位数，OS位数以及内存大小关系</a></p>
<p>内存位置16进制编号，一个网格，网格上每个都有编号，用16进制表示，<code>0x....</code>表示</p>
<p>程序指引 int a = 1; int b = 1</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>进入今天的正题<code>字符编码</code>，同样的问题<code>0、1怎么来表示字符呢，比如hello、你好？</code></p>
<p><strong>抽象的字符编码层面：把一个字符“编码”到一个数字</strong></p>
<p><strong>具体的字符编码层面：把抽象层面的数字“编码”成最终的储存形式，明确是定长还是变长；定长的话是定几个字节；用变长的话有哪几种字节长度，具体如何实现；</strong></p>
<h4 id="Unicode-与-UTF-X"><a href="#Unicode-与-UTF-X" class="headerlink" title="Unicode 与 UTF-X"></a>Unicode 与 UTF-X</h4><p><a href="http://naotu.baidu.com/file/91e22aa3101b248bb9fb207c7d878826" target="_blank" rel="noopener">脑图</a></p>
<ul>
<li>Unicode 只是符号集，规定了符号与二进制代码的关系，没有规定二进制代码应该如何存储</li>
<li>UTF-X 根据Unicode来进行存储，涉及具体的编码; <ul>
<li>最终的存储形式 定长还是变长；</li>
<li>如果是变长有哪几种字节长度，具体如何实现；</li>
</ul>
</li>
</ul>
<p>一般来说，字符集(关系表) 与 具体实现的编码是，1对1的关系，像ASCII、GB2312(EUC-CN存储)等，但是 Unicode 与 UTF-X 是1对多的，UTF-X 有UTF-8、UTF-16、UTF-32等</p>
<h4 id="Unicode-码点-code-point"><a href="#Unicode-码点-code-point" class="headerlink" title="Unicode 码点(code point)"></a>Unicode 码点(code point)</h4><ul>
<li>码点格式：表现形式<code>U+[XX]XXXX</code>，X为16进制数字，<strong>4-6位表示</strong>。</li>
<li>码点范围：码点范围: <code>U+0000~U+10FFFF</code>；两种理解思路:<ol>
<li><code>U+10FFFF</code> 1*16^5 + 16^4 = 1114112</li>
<li><code>U+10FFFF + 1 = U+110000</code>个，前一个1是后一个1的16倍，<code>(16+1) * 65536 = 1114112</code></li>
</ol>
</li>
<li>17个面，每个面可表示65536个符<ul>
<li>BMP(Basic Multilingual Plan 基本多语言平面) <a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a></li>
<li>SP(Supplementary Plans 增补平面)</li>
</ul>
</li>
</ul>
<h4 id="编码单元-code-unit"><a href="#编码单元-code-unit" class="headerlink" title="编码单元 (code unit)"></a>编码单元 (code unit)</h4><p><code>UTF-X</code> 中<code>X</code>就代表了多少个比特位表示一个编码单元。<code>Unicode</code>码点最大<code>10FFFF</code>最大21位</p>
<p>UTF-8: 8bit即单字节为1个编码单元，UTF-16: 16bit即2个字节为1个编码单元, UTF-32：32bit即4个字节为1个编码单元</p>
<h4 id="定长编码-与-变长编码"><a href="#定长编码-与-变长编码" class="headerlink" title="定长编码 与 变长编码"></a>定长编码 与 变长编码</h4><p>定长编码：意味着这类编码使用固定长度的字节，如<code>ASCII</code>固定占1个字节长度、<code>UTF-32</code>固定占4个字节长度。特点：复杂度低，其存在的问题是<strong>定多长，定少了不够用，定多了浪费空间</strong></p>
<p>变长编码：字符所占长度不固定，如<code>UTF-8</code>占1/2/3/4个字节长度、<code>UTF-16</code>占2/4个字节长度。特点：具有一定复杂度，其核心解决的问题是<strong>如何区分不同的变长字节</strong></p>
<p>定长编码的读取我们好理解，一次读固定长度的字节，根据码表将二进制翻译字符显示即可；写入时根据字符翻译成二进制，不足固定长度，向前补0即可；</p>
<p>那变长编码的读取和写入呢？</p>
<h4 id="变长编码的实现一——UTF-8"><a href="#变长编码的实现一——UTF-8" class="headerlink" title="变长编码的实现一——UTF-8"></a>变长编码的实现一——UTF-8</h4><p><code>UTF-8</code>：<code>UTF-8</code>利用高位保留来做区分来解决上面提到的<strong>如何区分不同的变长字节</strong>问题，缺点就是减少了有效编码空间</p>
<p>这种编码方式类似<code>前缀编码</code>：<strong>设计长短不等的编码，则必须是任一字符不是另一字符编码的前缀</strong> ,就像压缩算法中应用的<code>哈夫曼编码</code></p>
<p><code>UTF-8</code>单个字节字符的字节<code>0开头</code>，<code>n</code>个字节的字符高字节是<code>n个1开头</code>，其中开头字节就像前缀一样。由于高位不同，<strong>多字节不会包含一字节的模式</strong>，0开头的字节不会出现在多字节字符编码中，二字节的模式不会出现在三字节模式中，也不会出现在四字节模式中；三字节的模式中也不会出现在四字节模式中；</p>
<table>
<thead>
<tr>
<th>UNICODE码点范围</th>
<th>UTF-8</th>
<th>UTF-8二进制</th>
<th>有效编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+0000~U+007F</td>
<td>1字节</td>
<td>0XXXXXXX</td>
<td>2^7=128个(ASCII)</td>
</tr>
<tr>
<td>U+0080~U+07FF</td>
<td>2字节</td>
<td>110XXXXX 10XXXXXX</td>
<td>2^11=2048个</td>
</tr>
<tr>
<td>U+0800~U+FFFF</td>
<td>3字节</td>
<td>1110XXXX 10XXXXXX 10XXXXXX</td>
<td>2^16=65536个</td>
</tr>
<tr>
<td>U+010000~U+10FFFF</td>
<td>4字节</td>
<td>11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
<td>2^21=2097152个</td>
</tr>
</tbody>
</table>
<ul>
<li>UTF-8多字节二进制规则：<strong>首字节前n位为1，n+1位为0；后面字节前两位为0</strong></li>
<li>UTF-8多(n)字节有效编码位：<code>(n*8)-(n+1+(n-1)*2)=5n+1</code></li>
</ul>
<p>上面有效编码可以看出来，ASCII段占1个字节、大多数字符是占1或者3个字节的，一些生僻极其罕见的才会占4个字节</p>
<h4 id="变长编码的实现二——UTF-16"><a href="#变长编码的实现二——UTF-16" class="headerlink" title="变长编码的实现二——UTF-16"></a>变长编码的实现二——UTF-16</h4><p><code>UTF-16</code>: <code>UTF-16</code>是使用所谓的代理区来实现。从<a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a>可以看到<code>D8-D9</code>整行都是空，这块空白就是所谓的<strong>代理区(Surrogate Area)</strong>。</p>
<p>代理区实现原理：我们来自己实现一种字符编码来体验下<code>代理区</code>吧</p>
<p>大多数占2个字节，生僻极其罕见的占4个字节。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>ASCII: 计算机早期应用，只在美国，33个计算机控制字符、33个英文标点字符、10个数字字符、52个大小写字母字符，33+33+10+52=128 用一个字节的后7位表示，还空闲一个高位<code>0XXX XXXX</code></p>
</li>
<li><p>EASCII: 计算机发展至欧洲，欧洲国家128个字符不够用，利用ASCII字节空闲的最高位扩展128个.</p>
</li>
<li><p>GB2312: 国标，每个汉字及符号以两个字节来表示，第一个字节为“高位字节”，第二个字节为“低位字节”</p>
</li>
<li><p>GBK: 国标扩展</p>
</li>
<li><p>EUC: EUC-CN ，Extended Unix Code，是一个使用8位编码来表示字符的方法</p>
</li>
<li><p>BIG5: 港澳台同胞</p>
</li>
<li><p>两个独立的尝试创立单一字符集的组织:</p>
<ul>
<li>国际标准化组织（ISO）</li>
<li>由Xerox、Apple等软件制造商于1988年组成的统一码联盟</li>
</ul>
</li>
<li><p>UNICODE: Unicode是Unicode Standard（Unicode标准）,定义了码点与字符的关系</p>
</li>
<li><p>ISO: 国际标准化组织 </p>
</li>
<li><p>UCS: <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">通用字符集(Universal Character Set)</a>，由ISO制定的<code>ISO 10646</code>标准；</p>
<ul>
<li>UCS-4: <code>ISO 10646</code>标准定义了一个32位的编码形式，称作UCS-4。<a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a>和UCS4能表示的字符是相同的。</li>
<li>UCS-2: 类似<code>UCS-4</code>，使用16位的编码形式。<a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>可看成是UCS-2的父集</li>
</ul>
</li>
<li><p>BOM: Byte Order Mark，UTF-8采用字节为编码单元，没有字节序问题，常见的是UTF-16的字节序问题。</p>
<ul>
<li>UTF-16LE, 小尾序，Little Endian，也叫小端序，这里的端是指末端的意思， BOM 标记 <code>FF EE</code>， 小的作为尾巴在后面。<code>windows txt 另存时的Unicde 为UTF-16LE</code></li>
<li>UTF-16BE, 大尾序, Big  Endian，也叫大端序，这里的端也是指末端的意思，BOM 标记 <code>EE FF</code>， 大的作为尾巴在后面。<code>很多编码语言如java、javascript内码采用UTF-16BE</code></li>
<li>另外UTF-32也有大端小端的问题</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/21/字符编码/" data-id="ck2n0fsjm005debrj9eq9te0d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java线程池实现原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/15/java线程池实现原理分析/" class="article-date">
  <time datetime="2017-06-15T02:48:12.000Z" itemprop="datePublished">2017-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/15/java线程池实现原理分析/">java线程池实现原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>沉下心，才会远离烦恼。</p>
</blockquote>
<p><code>java</code>提供了多线程，用户只要继承<code>Thread</code>类或实现<code>Runnable</code>接口就能轻松达到多线程的目的。简单的应用时，我们硬编码固定的线程数可能就能满足要求，但是涉及到线程资源的重复利用、管理、响应性能等，我们就需要线程池来协助了。类似数据库连接池，线程池主要有以下优点：</p>
<ol>
<li>创建线程也需要消耗，池中线程可重复利用，降低资源消耗</li>
<li>线程提前创建，提高响应速度</li>
<li>提高线程可管理性</li>
</ol>
<p><code>Java 1.5</code>中引入了<code>Executor</code>框架把任务的<strong>提交</strong>和<strong>执行</strong>进行了解耦。只需要<strong>定义好任务</strong>，然后<strong>提交</strong>给线程池。而不用关心任务如何被执行、被哪个线程执行、以及什么时候执行等。</p>
<p><code>Executor</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Executor</code>只是一个简单的接口，但它为灵活而强大的框架创造了基础，<code>Executor</code> 基于 <strong>生产者-消费者模式</strong>。如果你在程序中实现一个生产者-消费者的设计，使用<code>Executor</code>通常是最简单的方式。</p>
<h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 2. 创建一个包含10个线程的线程池 executor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task()); <span class="comment">// 3. 20个任务提交给 线程池 executor 来执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 1. 定义任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>Executors</code>是java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池，如<code>Executors.newFixedThreadPool</code>方法产生一个拥有固定数量的线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ExecutorService</code>接口继承接口<code>Executor</code>，方法内本质是通过不同参数初始化<code>ThreadPoolExecutor</code>，下面看下这个方法是怎么定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最准确的注释，你还可以查看<code>jdk</code>源码中的英文注释。</p>
<h5 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h5><p>要保存在池中的线程数，包括空闲的。除非<code>allowCoreThreadTimeOut</code>参数被设置。如果执行了<code>prestartAllCoreThreads()</code>方法，将提前创建并启动所有核心线程。</p>
<h5 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h5><p>线程池允许的最大线程数，超出的提交将进入<code>BlockingQueue</code>阻塞队列，故<code>executor.execute(xxTask)</code>之后的代码不会因线程数量的限定而阻塞。</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>线程的空闲存活时间。该参数只在线程数大于核心线程数时起作用，结合<code>corePoolSize</code>的注释理解。</p>
<h5 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h5><p><code>keepAliveTime</code>的单位。</p>
<h5 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h5><p>保存任务的阻塞队列，限定了队列中只能存储实现了<code>Runnable</code>接口的任务。<code>BlockingQueue&lt;Runnable&gt;</code>接口在<code>JDK</code>中有以下实现：</p>
<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>: 基于链表机构的阻塞队列。</li>
<li><code>SynchronusQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入一直处于阻塞状态。</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列。</li>
</ul>
<p>前两者的味道类似于<code>ArrayList</code>与<code>LinkedList</code>，主要是具有数据结构<code>Array</code>、<code>链表</code>的特点。而<code>SynchronusQueue</code>则类似于<code>CSP</code>场景中，一个没有<code>buffer</code>缓冲的<code>channel</code>，《七周七并发模型》中一书中的<code>CSP</code>模型中提到<code>新手往往会认为有缓存的channel会比无缓存的channel应用更广泛，但实际情况却恰恰相反。</code>，虽然这不一定对，但是这提醒了我们一定要根据场景去选择使用。<code>PriorityBlockingQueue</code>则是更接近场景需求优先级的解决办法。</p>
<h5 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h5><p>创建线程的工厂，具有名称前缀<code>pool-</code>,主要实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    SecurityManager s = System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                            Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                    poolNumber.getAndIncrement() +</span><br><span class="line">                    <span class="string">"-thread-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h5><p>任务队列达到限制的饱和处理策略。线程池提供了4中策略：</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在线程来执行任务</li>
<li><code>DiscardOldesPolicy</code>: 丢弃队列最前面的任务，执行新的任务。类似于<code>CSP</code>模型中的<code>sliding</code>方式</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务。类似于<code>CSP</code>模型中的<code>dropping</code>方式<br>如果以上都不满足你的需求，你还可以自己实现<code>RejectedExecutionHandler</code>接口，自定义饱和处理策略，比如日志记录、邮件提醒等。</li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><code>Executors</code>工厂类提供了线程的初始化接口，主要有如下几种：</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能如其名，入参只有一个数字。指定固定的线程个数，其中 <code>corePoolSize == maximumPoolSize</code>，<code>0L</code>代表不会释放<code>core</code>线程，使用<code>LinkedBlocingQueue</code>作为任务队列。</p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个缓存限定时间线程的线程池，默认缓存60s，线程空闲超过60s时会自动释放线程，不会保留<code>core</code>线程。</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建单个工作线程的<code>Executor</code>，等同于<code>newFixedThreadPool(1, threadFactory)</code>，返回的<code>Executor</code>不可再重新配置。</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期同步数据。</p>
<h5 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jdk 1.8</code>中出现，创建一个<code>work-stealing</code>的线程池，内部<code>ForkJoinPool</code>使用一个并行因子来创建，默认为主机CPU的可用核心数。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>可以从方法内部的实例化代码看出，前三者都是<code>ThreadPoolExecutor</code>类实现的，<code>newScheduledThreadPool</code>返回类型都发生了变化，其实现是<code>ScheduledThreadPoolExecutor</code>，另外<code>newWorkStealingPool</code>返回值没有变化，说明暴露给外部的使用上没有变，内部使用<code>ForkJoinPool</code>来做了优化。</p>
<h4 id="ThreadPoolExecutor-线程池内部状态"><a href="#ThreadPoolExecutor-线程池内部状态" class="headerlink" title="ThreadPoolExecutor 线程池内部状态"></a>ThreadPoolExecutor 线程池内部状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); <span class="comment">// ctl 包含了两个概念，因为两个的关联关系，巧妙的组合在一起；高3位表示线程池状态； 低29位 表示workerCount </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3为为011</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>RUNNING</code> : 线程池会接收新任务，并处理排队的任务 </li>
<li><code>SHUTDOWN</code>: 线程池不接收新任务，但会处理队列中的任务</li>
<li><code>STOP</code>: 线程池不接收新人无，不处理队列中的任务，并中断正在运行的任务</li>
<li><code>TIDYING</code>:  所有任务已经终止，workCount为零，线程过渡到TIDYING状态</li>
<li><code>TERMINATED</code>: terminated() 钩子方法运行完毕</li>
</ul>
<h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>线程池框架提供了两种方式提交任务：</p>
<ul>
<li><p><code>Executor.execute(Runnable command)</code>  返回void, 不关心返回值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ExecutorService.submit(Callable&lt;T&gt; task)</code> 返回<code>Future&lt;T&gt;</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ThreadPoolExecutor-execute-的实现"><a href="#ThreadPoolExecutor-execute-的实现" class="headerlink" title="ThreadPoolExecutor.execute 的实现"></a>ThreadPoolExecutor.execute 的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取原子变量的值</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 统计 workerCount 如果小于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 则 addWorker 来创建线程来执行任务</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get(); <span class="comment">// 如果上面的 command没有被执行，则再获取一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 判断线程池当前状态为运行，并且成功将任务插入到 阻塞队列中</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 再次取新值判断</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池停止了，并且任务被成功移除</span></span><br><span class="line">        reject(command); <span class="comment">// reject handler</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// workerCount 为 0 </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// ？经过上面内部的层层判断，逻辑不太会走到这里，不太理解此处的 null，在我看来这是一种“弃疗”的表现。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 再次使用 maximun 作为限定数尝试添加</span></span><br><span class="line">    reject(command); <span class="comment">// 线程池饱和处理 reject handler</span></span><br></pre></td></tr></table></figure>
<h5 id="addWorker的实现"><a href="#addWorker的实现" class="headerlink" title="addWorker的实现"></a>addWorker的实现</h5><p><code>addWorker</code>方法主要是创建线程，执行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry: <span class="comment">// 重试标记层级</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限定条件的for</span></span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 线程池状态不满足则直接返回 false</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY || <span class="comment">// 如果 workerCount 大于 容量</span></span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize)) </span><br><span class="line">                   <span class="comment">// 如果 workerCount 大于 核心线程数（外部以核心线程数作为判断依据时） 或 workerCount 大于 最大线程数(外部以最大线程数作为判断依据时)</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 容量受限，返回false</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 通过上面的检测，并更新数值成功</span></span><br><span class="line">                   <span class="keyword">break</span> retry; <span class="comment">// 跳出 多层循环，往方法的下半部分继续执行</span></span><br><span class="line">               c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 上面未设值成功，状态 没有变化</span></span><br><span class="line">                   <span class="keyword">continue</span> retry; <span class="comment">// 继续外部循环</span></span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是这个方法的前半部分，主要是线程池状态检测、线程池数量限制检测、线程池相关数量与状态的更新。以下是下半部分代码，主要是创建线程，执行任务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 线程池的工作 通过 Worker 类，Worker 类继承了 AQS （AbstractQueuedSynchronizer）</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 线程是取的 worker中的线程，而worker中的线程是线程池初始化的 线程工厂创建的</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; <span class="comment">// ReentrantLock 锁的保证下，插入到 workers(HashSet结构)中</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">            <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">            <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                workers.add(w); <span class="comment">// 加入 hashSet 中</span></span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start(); <span class="comment">// 添加成功 开始 运行</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure></p>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123; <span class="comment">// </span></span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">// 初始化线程池的 线程工厂来创建线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">// runnable 接口的实现，启动线程 运行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="runWorker实现"><a href="#runWorker实现" class="headerlink" title="runWorker实现"></a>runWorker实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts // 线程启动后通过unlock释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 首次进入会执行 firstTask，后面则主要通过getTask()方法取队列中的任务</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 前置任务</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run(); <span class="comment">// 开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 后置任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getTask-实现"><a href="#getTask-实现" class="headerlink" title="getTask 实现"></a>getTask 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 在指定时间内，阻塞队列没有新的任务，则会返回null</span></span><br><span class="line">                workQueue.take(); <span class="comment">// 如果阻塞队列为空，当前线程被挂起；队列中有任务加入时，线程被唤醒，返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Future-和-Callable-的实现"><a href="#Future-和-Callable-的实现" class="headerlink" title="Future 和 Callable 的实现"></a>Future 和 Callable 的实现</h4><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Task()); <span class="comment">// 提交异步任务</span></span><br><span class="line">        System.out.println(<span class="string">"do other things"</span>);</span><br><span class="line">        </span><br><span class="line">        String result = future.get(); <span class="comment">// 线程阻塞</span></span><br><span class="line">        System.out.println(<span class="string">"asynchronus result:"</span> + result); <span class="comment">// 后面跟随的代码，等待上面的阻塞解除执行完后，才会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 睡眠2s，模拟异步耗时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"this is future case"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际业务场景中，<code>Future</code>与<code>Callable</code>一般是成对出现的，<code>Callable</code>负责执行任务产生结果，<code>Future</code>则是负责获取结果</p>
<ol>
<li><code>Callable</code>接口类似<code>Runnable</code>接口，只是<code>Runnable</code>没有返回值。所以如果你关心你每个任务的执行返回结果，就可以采用<code>Callable</code>，否则你就直接使用<code>Runnable</code>就好了。</li>
<li><code>Callable</code>执行的任务如果发生异常，该异常也会被返回，即<code>Future</code>可以拿到异步执行任务的各种结果。</li>
<li><code>Future.get</code>方法是阻塞的，直到<code>Callable</code>任务执行完成</li>
</ol>
<h5 id="submit实现"><a href="#submit实现" class="headerlink" title="submit实现"></a>submit实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable</code>任务通过<code>submit()</code>方法被封装为一个<code>RunnableFuture</code>的<code>FutureTask</code>.</p>
<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>state 存储 <code>FutureTask</code>的状态，</li>
<li>构造初始状态为<code>NEW</code>，构造函数使用<code>callable</code>成员变量存储了入参<code>callable</code>任务</li>
<li><code>FutureTask</code>实现了<code>Runnable</code>接口，最终实际执行的是<code>FutureTask</code>中的<code>run</code>方法</li>
</ul>
<h5 id="FutureTask-get实现"><a href="#FutureTask-get实现" class="headerlink" title="FutureTask.get实现"></a>FutureTask.get实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING) <span class="comment">// 状态检查</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部通过<code>awaitDone</code>方法阻塞，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果线程被中断，则抛出异常</li>
<li>如果状态大于<code>COMPLETING</code>说明已经完成，直接返回状态即可</li>
<li>如果状态等于<code>COMPLETING</code>说明已经完成，使用<code>yield</code>让渡一下<code>cpu</code>，<code>state</code>则会过度到<code>NORMAL</code>了</li>
<li>通过<code>WaitNode</code>简单链表封装当前线程，并通过<code>UNSAFE</code>添加到<code>waiters</code>链表</li>
<li>最终通过<code>LockSupport</code>的<code>park</code>或<code>parkNanos</code>来挂起线程，另外<code>finishCompletion</code>方法中会<code>unpark</code></li>
</ul>
<h5 id="FutureTask-run-实现"><a href="#FutureTask-run-实现" class="headerlink" title="FutureTask.run 实现"></a>FutureTask.run 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>run</code> 方法是线程池中的线程来执行的，而非主线程</li>
<li>执行<code>callable.call</code>方法来运行任务</li>
<li><code>call</code>通过时用<code>set</code>方法来保存结果</li>
<li><code>call</code>出现异常时用<code>setException</code>方法来保持异常信息</li>
</ul>
<h5 id="set-setException"><a href="#set-setException" class="headerlink" title="set/setException"></a>set/setException</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>UNSAFE</code>修改了<code>FutureTask</code>的状态，最终都通过调用<code>finishCompletion</code>方法通知主线程任务完成。</p>
<h5 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新<code>waiters</code>的值</li>
<li><code>LockSupport.unpark(t)</code>唤醒主线程</li>
</ul>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/87bff5cc8d8c" target="_blank" rel="noopener">占小狼-深入分析java线程池的实现原理</a> </li>
<li>《JAVA并发编程实践》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/15/java线程池实现原理分析/" data-id="ck2n0fsij0044ebrjuk597cg4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-好文推荐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/好文推荐/" class="article-date">
  <time datetime="2017-05-24T03:08:56.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/好文推荐/">好文推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一些总结的好，不一定是要文笔有多好，或者涵盖广泛。只要是能给我提供一些想法，或者是能帮助完善自己的一些想法，这里存储下链接，做一下简要记录，希望不要像书签一样，存的多却看的少。</p>
<ul>
<li><a href="http://www.zcfy.cc/article/how-to-get-node-js-logging-right-518.html" target="_blank" rel="noopener">如何让Node.js正确地日志</a> - 2017年5月24日11:14:46：<blockquote>
<p>虽然写的是Node.js的，但是提到<strong>日志的几个要点</strong>、<strong>日志的应用范围</strong>，在其他语言中同样也是适用的，抽象出概念能帮助理解日志。<br>要点：时间戳、格式、日志目标、日志级别<br>应用范围：库类型、单个应用程序、分布式系统<br><a href="https://github.com/eggjs/egg-logger" target="_blank" rel="noopener">egg-logger的图也助于理解主流日志框架</a></p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/24/好文推荐/" data-id="ck2n0fsjj005bebrjod7izcg3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javascript模块化方式简记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/javascript模块化方式简记/" class="article-date">
  <time datetime="2017-05-23T03:19:46.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/javascript模块化方式简记/">javascript模块化方式简记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a><code>CommonJS</code> 规范</h5><p><code>node.js</code>是服务端的编程，需要与操作系统、其他应用互动，需要模块化，否则无法编程，而在浏览器其复杂性有限，没有模块化也不是特别大的问题。而<code>node.js</code>的模块系统就是操作<code>CommonJS</code>规范实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./A'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a><code>AMD</code> 规范</h5><p>有了服务端模块化后，很自然地，大家就想要客户端模块化。而且最好能与服务端兼容，模块都不用修改，在服务器和浏览器都可以运行。但是<strong>浏览器加载<code>模块文件</code>是跨网络的</strong>，加载可能会造成假死，后面的代码无法运行。而服务端是在本地硬盘的，这对服务端不是问题。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p><code>AMD</code>是”Asynchronous Module Definition”，意识就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响他后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等模块加载完成后，这个回调函数才会运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖前置，提前执行</span></span><br><span class="line">    a.xx();</span><br><span class="line">    b.xx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://requirejs.org/" target="_blank" rel="noopener"><code>require.js</code></a>是<code>AMD</code>规范的一个实现。</p>
<h5 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a><code>CMD</code> 规范</h5><p><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.xxx();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>); <span class="comment">//依赖就近书写</span></span><br><span class="line">    b.xxx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="静态加载与动态加载"><a href="#静态加载与动态加载" class="headerlink" title="静态加载与动态加载"></a>静态加载与动态加载</h4><p><code>es6</code>之前模块加载的两种方式</p>
<ul>
<li>静态加载：在编译阶段进行，把所有需要的依赖打包到一个文件</li>
<li>动态加载：在运行时加载</li>
</ul>
<p><code>AMD</code>标准是动态加载的代表，而<code>CommonJS</code>是静态加载的代表。</p>
<p><code>AMD</code>主要用在浏览器上，是异步加载的，而<code>NodeJS</code>在服务端，同步加载的方式更易被接收，所以用的是<code>CommonJS</code>。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><code>ES6</code></h5><p><code>ES6</code>采用哪种加载机制了？ <code>ES6</code>既希望用简单的声明来完成静态加载，有不愿放弃动态加载的特性，而这两种方式几乎不能简单的同时实现，所以<code>ES6</code>提供了两种独立的模块加载方法。</p>
<ol>
<li><p>声明的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> some_module;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>System.import</code> API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.import(<span class="string">'some_module)</span></span><br><span class="line"><span class="string">    .then(some_module =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    .catch(error =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>模块导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export 一个命名 function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export default function</span></span><br><span class="line"><span class="keyword">export</span> num = <span class="number">123</span> <span class="comment">// export 一个数值</span></span><br><span class="line"><span class="keyword">export</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; obj <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// default export</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> myModule&#125; <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// rename</span></span><br><span class="line"><span class="keyword">import</span> &#123;abc, num, obj&#125; <span class="keyword">from</span> <span class="string">'some_module'</span></span><br></pre></td></tr></table></figure></p>
<p>参考自：</p>
<ul>
<li><a href="https://blog.wilddog.com/?p=587" target="_blank" rel="noopener">写了十年JS却不知道模块化为何物？</a></li>
<li><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">Sea.js 与 RequireJS 的异同</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/23/javascript模块化方式简记/" data-id="ck2n0fsig003xebrjqv39uvh7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AMD/">AMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CMD/">CMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字节序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/字节序/" class="article-date">
  <time datetime="2017-05-16T01:31:57.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/字节序/">字节序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实已经有几次写到过有关字节序的问题了，这里单独拎出来再写一次，是因为又淡忘了，特意抽象其根本问题再做一个简要的记录。</p>
<p>抽象出的两个概念：</p>
<ol>
<li>存储地址：内存地址“从左至右”递增，可以理解往左是低位地址，往右是高位地址</li>
<li>要存的值：比如1个数字 112233(十进制)、1个字符串 “112233”  —(这里两处的33都是尾巴)</li>
</ol>
<p>注意：1个xx需要多个字节表示的时候，才会有字节序的问题</p>
<h4 id="面临的问题：-尾巴放到高的位置还是低的位置？"><a href="#面临的问题：-尾巴放到高的位置还是低的位置？" class="headerlink" title="面临的问题： 尾巴放到高的位置还是低的位置？"></a>面临的问题： 尾巴放到高的位置还是低的位置？</h4><p><strong>高尾端：高的位置存尾巴</strong></p>
<p><strong>低尾端：低的位置存尾巴</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1ffmybwhwrwj20jm0ax0sr.jpg" alt="字节序"></p>
<h4 id="比拟"><a href="#比拟" class="headerlink" title="比拟"></a>比拟</h4><p>一个<code>词</code>中<code>字</code>的顺序 (普遍：从左至右念，牌匾：从右至左念)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">法语，公主，四十</span><br></pre></td></tr></table></figure></p>
<p>一行文字中字的读取顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严管妻是本；妇顺夫为实.</span><br></pre></td></tr></table></figure></p>
<p>解析的顺序不一样意义就大不一样咯。</p>
<h4 id="其他叫法"><a href="#其他叫法" class="headerlink" title="其他叫法"></a>其他叫法</h4><p><code>高尾端/大端序/大尾序</code></p>
<p><code>低尾端/小端序/小尾序</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/16/字节序/" data-id="ck2n0fsjo005hebrjx8s6m8dp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/通信/">通信</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/PostgreSQL/">PostgreSQL</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Openresty/">Openresty</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/">PostgreSQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/数据库/">数据库</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全/">安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript语言/">javascript语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/测试/">测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/英语/">英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMD/">AMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMD/">CMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Centos软件安装/">Centos软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL基础/">PostgreSQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cassandra/">cassandra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript函数/">javascript函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript基础/">javascript基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/n2n/">n2n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/压力测试/">压力测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/意志/">意志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/授权/">授权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务/">服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/灰度发布/">灰度发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/英语/">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运动/">运动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程/">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/Centos软件安装/" style="font-size: 15px;">Centos软件安装</a> <a href="/tags/CommonJS/" style="font-size: 10px;">CommonJS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PostgreSQL基础/" style="font-size: 15px;">PostgreSQL基础</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/cassandra/" style="font-size: 10px;">cassandra</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript函数/" style="font-size: 15px;">javascript函数</a> <a href="/tags/javascript基础/" style="font-size: 15px;">javascript基础</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/n2n/" style="font-size: 10px;">n2n</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/压力测试/" style="font-size: 10px;">压力测试</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/多线程-锁/" style="font-size: 10px;">多线程 锁</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/意志/" style="font-size: 10px;">意志</a> <a href="/tags/授权/" style="font-size: 10px;">授权</a> <a href="/tags/服务/" style="font-size: 10px;">服务</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/灰度发布/" style="font-size: 10px;">灰度发布</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/编码/" style="font-size: 15px;">编码</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/英语/" style="font-size: 10px;">英语</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/运动/" style="font-size: 10px;">运动</a> <a href="/tags/进程/" style="font-size: 10px;">进程</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/31/Cassandra-数据库使用小记/">Cassandra 数据库使用小记</a>
          </li>
        
          <li>
            <a href="/2018/08/30/wrk-压力测试/">wrk 压力测试</a>
          </li>
        
          <li>
            <a href="/2018/08/22/Supervisor的使用/">Supervisor的使用</a>
          </li>
        
          <li>
            <a href="/2018/08/09/Lua-OpenResty-开发环境搭建/">Lua OpenResty 开发环境搭建</a>
          </li>
        
          <li>
            <a href="/2018/08/05/Nginx-Lua-实现灰度发布/">Nginx+Lua 实现灰度发布</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 orh<br>
      湘ICP备16002846号 <a href="http://www.beian.miit.gov.cn" target="_blank"> 湘ICP备16002846号</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>