<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Poxi哥的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Poxi哥的博客">
<meta property="og:url" content="http://blog.ouronghui.com/page/2/index.html">
<meta property="og:site_name" content="Poxi哥的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Poxi哥的博客">
  
    <link rel="alternate" href="/atom.xml" title="Poxi哥的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Poxi哥的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">种一棵树最好的时间是十年前，其次是现在。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.ouronghui.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-字符编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/字符编码/" class="article-date">
  <time datetime="2017-06-21T02:31:46.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/字符编码/">字符编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从刚接触计算机理论起，就被灌输这是一台只认识0、1的机器，数字、字符串、声音、图像、视频等都可以在计算机中表示，这就是所谓的数字化吧。</p>
<h3 id="大于0、1的整数表示"><a href="#大于0、1的整数表示" class="headerlink" title="大于0、1的整数表示"></a>大于0、1的整数表示</h3><p>既然说到了，字符编码，想必已经理解了这个问题<code>只有0、1怎么表示2、3、4这些数字呢？</code>，表示如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000 -&gt; 0</span><br><span class="line">0001 -&gt; 1</span><br><span class="line">0010 -&gt; 2</span><br><span class="line">0011 -&gt; 3</span><br><span class="line">0100 -&gt; 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>采用进位使用多个bit位来表示就可以了，小数的表示这里就不展开说了，有兴趣的可以从这里看。</p>
<h4 id="TODO-内存位置"><a href="#TODO-内存位置" class="headerlink" title="TODO: 内存位置,"></a>TODO: 内存位置,</h4><p>bit 单元格，内存里面茫茫一片的<code>01...</code>， 内存并不去区分这个<code>01</code>是<code>十进制1中的01</code>，还是<code>10进制2中的01</code>  ，怎么区分这个交由具体的程序去做， <a href="http://www.cnblogs.com/little-YTMM/p/5058354.html" target="_blank" rel="noopener">关于CPU位数，OS位数以及内存大小关系</a></p>
<p>内存位置16进制编号，一个网格，网格上每个都有编号，用16进制表示，<code>0x....</code>表示</p>
<p>程序指引 int a = 1; int b = 1</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>进入今天的正题<code>字符编码</code>，同样的问题<code>0、1怎么来表示字符呢，比如hello、你好？</code></p>
<p><strong>抽象的字符编码层面：把一个字符“编码”到一个数字</strong></p>
<p><strong>具体的字符编码层面：把抽象层面的数字“编码”成最终的储存形式，明确是定长还是变长；定长的话是定几个字节；用变长的话有哪几种字节长度，具体如何实现；</strong></p>
<h4 id="Unicode-与-UTF-X"><a href="#Unicode-与-UTF-X" class="headerlink" title="Unicode 与 UTF-X"></a>Unicode 与 UTF-X</h4><p><a href="http://naotu.baidu.com/file/91e22aa3101b248bb9fb207c7d878826" target="_blank" rel="noopener">脑图</a></p>
<ul>
<li>Unicode 只是符号集，规定了符号与二进制代码的关系，没有规定二进制代码应该如何存储</li>
<li>UTF-X 根据Unicode来进行存储，涉及具体的编码; <ul>
<li>最终的存储形式 定长还是变长；</li>
<li>如果是变长有哪几种字节长度，具体如何实现；</li>
</ul>
</li>
</ul>
<p>一般来说，字符集(关系表) 与 具体实现的编码是，1对1的关系，像ASCII、GB2312(EUC-CN存储)等，但是 Unicode 与 UTF-X 是1对多的，UTF-X 有UTF-8、UTF-16、UTF-32等</p>
<h4 id="Unicode-码点-code-point"><a href="#Unicode-码点-code-point" class="headerlink" title="Unicode 码点(code point)"></a>Unicode 码点(code point)</h4><ul>
<li>码点格式：表现形式<code>U+[XX]XXXX</code>，X为16进制数字，<strong>4-6位表示</strong>。</li>
<li>码点范围：码点范围: <code>U+0000~U+10FFFF</code>；两种理解思路:<ol>
<li><code>U+10FFFF</code> 1*16^5 + 16^4 = 1114112</li>
<li><code>U+10FFFF + 1 = U+110000</code>个，前一个1是后一个1的16倍，<code>(16+1) * 65536 = 1114112</code></li>
</ol>
</li>
<li>17个面，每个面可表示65536个符<ul>
<li>BMP(Basic Multilingual Plan 基本多语言平面) <a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a></li>
<li>SP(Supplementary Plans 增补平面)</li>
</ul>
</li>
</ul>
<h4 id="编码单元-code-unit"><a href="#编码单元-code-unit" class="headerlink" title="编码单元 (code unit)"></a>编码单元 (code unit)</h4><p><code>UTF-X</code> 中<code>X</code>就代表了多少个比特位表示一个编码单元。<code>Unicode</code>码点最大<code>10FFFF</code>最大21位</p>
<p>UTF-8: 8bit即单字节为1个编码单元，UTF-16: 16bit即2个字节为1个编码单元, UTF-32：32bit即4个字节为1个编码单元</p>
<h4 id="定长编码-与-变长编码"><a href="#定长编码-与-变长编码" class="headerlink" title="定长编码 与 变长编码"></a>定长编码 与 变长编码</h4><p>定长编码：意味着这类编码使用固定长度的字节，如<code>ASCII</code>固定占1个字节长度、<code>UTF-32</code>固定占4个字节长度。特点：复杂度低，其存在的问题是<strong>定多长，定少了不够用，定多了浪费空间</strong></p>
<p>变长编码：字符所占长度不固定，如<code>UTF-8</code>占1/2/3/4个字节长度、<code>UTF-16</code>占2/4个字节长度。特点：具有一定复杂度，其核心解决的问题是<strong>如何区分不同的变长字节</strong></p>
<p>定长编码的读取我们好理解，一次读固定长度的字节，根据码表将二进制翻译字符显示即可；写入时根据字符翻译成二进制，不足固定长度，向前补0即可；</p>
<p>那变长编码的读取和写入呢？</p>
<h4 id="变长编码的实现一——UTF-8"><a href="#变长编码的实现一——UTF-8" class="headerlink" title="变长编码的实现一——UTF-8"></a>变长编码的实现一——UTF-8</h4><p><code>UTF-8</code>：<code>UTF-8</code>利用高位保留来做区分来解决上面提到的<strong>如何区分不同的变长字节</strong>问题，缺点就是减少了有效编码空间</p>
<p>这种编码方式类似<code>前缀编码</code>：<strong>设计长短不等的编码，则必须是任一字符不是另一字符编码的前缀</strong> ,就像压缩算法中应用的<code>哈夫曼编码</code></p>
<p><code>UTF-8</code>单个字节字符的字节<code>0开头</code>，<code>n</code>个字节的字符高字节是<code>n个1开头</code>，其中开头字节就像前缀一样。由于高位不同，<strong>多字节不会包含一字节的模式</strong>，0开头的字节不会出现在多字节字符编码中，二字节的模式不会出现在三字节模式中，也不会出现在四字节模式中；三字节的模式中也不会出现在四字节模式中；</p>
<table>
<thead>
<tr>
<th>UNICODE码点范围</th>
<th>UTF-8</th>
<th>UTF-8二进制</th>
<th>有效编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+0000~U+007F</td>
<td>1字节</td>
<td>0XXXXXXX</td>
<td>2^7=128个(ASCII)</td>
</tr>
<tr>
<td>U+0080~U+07FF</td>
<td>2字节</td>
<td>110XXXXX 10XXXXXX</td>
<td>2^11=2048个</td>
</tr>
<tr>
<td>U+0800~U+FFFF</td>
<td>3字节</td>
<td>1110XXXX 10XXXXXX 10XXXXXX</td>
<td>2^16=65536个</td>
</tr>
<tr>
<td>U+010000~U+10FFFF</td>
<td>4字节</td>
<td>11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
<td>2^21=2097152个</td>
</tr>
</tbody>
</table>
<ul>
<li>UTF-8多字节二进制规则：<strong>首字节前n位为1，n+1位为0；后面字节前两位为0</strong></li>
<li>UTF-8多(n)字节有效编码位：<code>(n*8)-(n+1+(n-1)*2)=5n+1</code></li>
</ul>
<p>上面有效编码可以看出来，ASCII段占1个字节、大多数字符是占1或者3个字节的，一些生僻极其罕见的才会占4个字节</p>
<h4 id="变长编码的实现二——UTF-16"><a href="#变长编码的实现二——UTF-16" class="headerlink" title="变长编码的实现二——UTF-16"></a>变长编码的实现二——UTF-16</h4><p><code>UTF-16</code>: <code>UTF-16</code>是使用所谓的代理区来实现。从<a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a>可以看到<code>D8-D9</code>整行都是空，这块空白就是所谓的<strong>代理区(Surrogate Area)</strong>。</p>
<p>代理区实现原理：我们来自己实现一种字符编码来体验下<code>代理区</code>吧</p>
<p>大多数占2个字节，生僻极其罕见的占4个字节。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>ASCII: 计算机早期应用，只在美国，33个计算机控制字符、33个英文标点字符、10个数字字符、52个大小写字母字符，33+33+10+52=128 用一个字节的后7位表示，还空闲一个高位<code>0XXX XXXX</code></p>
</li>
<li><p>EASCII: 计算机发展至欧洲，欧洲国家128个字符不够用，利用ASCII字节空闲的最高位扩展128个.</p>
</li>
<li><p>GB2312: 国标，每个汉字及符号以两个字节来表示，第一个字节为“高位字节”，第二个字节为“低位字节”</p>
</li>
<li><p>GBK: 国标扩展</p>
</li>
<li><p>EUC: EUC-CN ，Extended Unix Code，是一个使用8位编码来表示字符的方法</p>
</li>
<li><p>BIG5: 港澳台同胞</p>
</li>
<li><p>两个独立的尝试创立单一字符集的组织:</p>
<ul>
<li>国际标准化组织（ISO）</li>
<li>由Xerox、Apple等软件制造商于1988年组成的统一码联盟</li>
</ul>
</li>
<li><p>UNICODE: Unicode是Unicode Standard（Unicode标准）,定义了码点与字符的关系</p>
</li>
<li><p>ISO: 国际标准化组织 </p>
</li>
<li><p>UCS: <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">通用字符集(Universal Character Set)</a>，由ISO制定的<code>ISO 10646</code>标准；</p>
<ul>
<li>UCS-4: <code>ISO 10646</code>标准定义了一个32位的编码形式，称作UCS-4。<a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a>和UCS4能表示的字符是相同的。</li>
<li>UCS-2: 类似<code>UCS-4</code>，使用16位的编码形式。<a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>可看成是UCS-2的父集</li>
</ul>
</li>
<li><p>BOM: Byte Order Mark，UTF-8采用字节为编码单元，没有字节序问题，常见的是UTF-16的字节序问题。</p>
<ul>
<li>UTF-16LE, 小尾序，Little Endian，也叫小端序，这里的端是指末端的意思， BOM 标记 <code>FF EE</code>， 小的作为尾巴在后面。<code>windows txt 另存时的Unicde 为UTF-16LE</code></li>
<li>UTF-16BE, 大尾序, Big  Endian，也叫大端序，这里的端也是指末端的意思，BOM 标记 <code>EE FF</code>， 大的作为尾巴在后面。<code>很多编码语言如java、javascript内码采用UTF-16BE</code></li>
<li>另外UTF-32也有大端小端的问题</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/21/字符编码/" data-id="cjjwiirgv004iftrjonpyy9b5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java线程池实现原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/15/java线程池实现原理分析/" class="article-date">
  <time datetime="2017-06-15T02:48:12.000Z" itemprop="datePublished">2017-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/15/java线程池实现原理分析/">java线程池实现原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>沉下心，才会远离烦恼。</p>
</blockquote>
<p><code>java</code>提供了多线程，用户只要继承<code>Thread</code>类或实现<code>Runnable</code>接口就能轻松达到多线程的目的。简单的应用时，我们硬编码固定的线程数可能就能满足要求，但是涉及到线程资源的重复利用、管理、响应性能等，我们就需要线程池来协助了。类似数据库连接池，线程池主要有以下优点：</p>
<ol>
<li>创建线程也需要消耗，池中线程可重复利用，降低资源消耗</li>
<li>线程提前创建，提高响应速度</li>
<li>提高线程可管理性</li>
</ol>
<p><code>Java 1.5</code>中引入了<code>Executor</code>框架把任务的<strong>提交</strong>和<strong>执行</strong>进行了解耦。只需要<strong>定义好任务</strong>，然后<strong>提交</strong>给线程池。而不用关心任务如何被执行、被哪个线程执行、以及什么时候执行等。</p>
<p><code>Executor</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Executor</code>只是一个简单的接口，但它为灵活而强大的框架创造了基础，<code>Executor</code> 基于 <strong>生产者-消费者模式</strong>。如果你在程序中实现一个生产者-消费者的设计，使用<code>Executor</code>通常是最简单的方式。</p>
<h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 2. 创建一个包含10个线程的线程池 executor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task()); <span class="comment">// 3. 20个任务提交给 线程池 executor 来执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 1. 定义任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>Executors</code>是java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池，如<code>Executors.newFixedThreadPool</code>方法产生一个拥有固定数量的线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ExecutorService</code>接口继承接口<code>Executor</code>，方法内本质是通过不同参数初始化<code>ThreadPoolExecutor</code>，下面看下这个方法是怎么定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最准确的注释，你还可以查看<code>jdk</code>源码中的英文注释。</p>
<h5 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h5><p>要保存在池中的线程数，包括空闲的。除非<code>allowCoreThreadTimeOut</code>参数被设置。如果执行了<code>prestartAllCoreThreads()</code>方法，将提前创建并启动所有核心线程。</p>
<h5 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h5><p>线程池允许的最大线程数，超出的提交将进入<code>BlockingQueue</code>阻塞队列，故<code>executor.execute(xxTask)</code>之后的代码不会因线程数量的限定而阻塞。</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>线程的空闲存活时间。该参数只在线程数大于核心线程数时起作用，结合<code>corePoolSize</code>的注释理解。</p>
<h5 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h5><p><code>keepAliveTime</code>的单位。</p>
<h5 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h5><p>保存任务的阻塞队列，限定了队列中只能存储实现了<code>Runnable</code>接口的任务。<code>BlockingQueue&lt;Runnable&gt;</code>接口在<code>JDK</code>中有以下实现：</p>
<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>: 基于链表机构的阻塞队列。</li>
<li><code>SynchronusQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入一直处于阻塞状态。</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列。</li>
</ul>
<p>前两者的味道类似于<code>ArrayList</code>与<code>LinkedList</code>，主要是具有数据结构<code>Array</code>、<code>链表</code>的特点。而<code>SynchronusQueue</code>则类似于<code>CSP</code>场景中，一个没有<code>buffer</code>缓冲的<code>channel</code>，《七周七并发模型》中一书中的<code>CSP</code>模型中提到<code>新手往往会认为有缓存的channel会比无缓存的channel应用更广泛，但实际情况却恰恰相反。</code>，虽然这不一定对，但是这提醒了我们一定要根据场景去选择使用。<code>PriorityBlockingQueue</code>则是更接近场景需求优先级的解决办法。</p>
<h5 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h5><p>创建线程的工厂，具有名称前缀<code>pool-</code>,主要实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    SecurityManager s = System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                            Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                    poolNumber.getAndIncrement() +</span><br><span class="line">                    <span class="string">"-thread-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h5><p>任务队列达到限制的饱和处理策略。线程池提供了4中策略：</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在线程来执行任务</li>
<li><code>DiscardOldesPolicy</code>: 丢弃队列最前面的任务，执行新的任务。类似于<code>CSP</code>模型中的<code>sliding</code>方式</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务。类似于<code>CSP</code>模型中的<code>dropping</code>方式<br>如果以上都不满足你的需求，你还可以自己实现<code>RejectedExecutionHandler</code>接口，自定义饱和处理策略，比如日志记录、邮件提醒等。</li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><code>Executors</code>工厂类提供了线程的初始化接口，主要有如下几种：</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能如其名，入参只有一个数字。指定固定的线程个数，其中 <code>corePoolSize == maximumPoolSize</code>，<code>0L</code>代表不会释放<code>core</code>线程，使用<code>LinkedBlocingQueue</code>作为任务队列。</p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个缓存限定时间线程的线程池，默认缓存60s，线程空闲超过60s时会自动释放线程，不会保留<code>core</code>线程。</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建单个工作线程的<code>Executor</code>，等同于<code>newFixedThreadPool(1, threadFactory)</code>，返回的<code>Executor</code>不可再重新配置。</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期同步数据。</p>
<h5 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jdk 1.8</code>中出现，创建一个<code>work-stealing</code>的线程池，内部<code>ForkJoinPool</code>使用一个并行因子来创建，默认为主机CPU的可用核心数。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>可以从方法内部的实例化代码看出，前三者都是<code>ThreadPoolExecutor</code>类实现的，<code>newScheduledThreadPool</code>返回类型都发生了变化，其实现是<code>ScheduledThreadPoolExecutor</code>，另外<code>newWorkStealingPool</code>返回值没有变化，说明暴露给外部的使用上没有变，内部使用<code>ForkJoinPool</code>来做了优化。</p>
<h4 id="ThreadPoolExecutor-线程池内部状态"><a href="#ThreadPoolExecutor-线程池内部状态" class="headerlink" title="ThreadPoolExecutor 线程池内部状态"></a>ThreadPoolExecutor 线程池内部状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); <span class="comment">// ctl 包含了两个概念，因为两个的关联关系，巧妙的组合在一起；高3位表示线程池状态； 低29位 表示workerCount </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3为为011</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>RUNNING</code> : 线程池会接收新任务，并处理排队的任务 </li>
<li><code>SHUTDOWN</code>: 线程池不接收新任务，但会处理队列中的任务</li>
<li><code>STOP</code>: 线程池不接收新人无，不处理队列中的任务，并中断正在运行的任务</li>
<li><code>TIDYING</code>:  所有任务已经终止，workCount为零，线程过渡到TIDYING状态</li>
<li><code>TERMINATED</code>: terminated() 钩子方法运行完毕</li>
</ul>
<h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>线程池框架提供了两种方式提交任务：</p>
<ul>
<li><p><code>Executor.execute(Runnable command)</code>  返回void, 不关心返回值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ExecutorService.submit(Callable&lt;T&gt; task)</code> 返回<code>Future&lt;T&gt;</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ThreadPoolExecutor-execute-的实现"><a href="#ThreadPoolExecutor-execute-的实现" class="headerlink" title="ThreadPoolExecutor.execute 的实现"></a>ThreadPoolExecutor.execute 的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取原子变量的值</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 统计 workerCount 如果小于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 则 addWorker 来创建线程来执行任务</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get(); <span class="comment">// 如果上面的 command没有被执行，则再获取一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 判断线程池当前状态为运行，并且成功将任务插入到 阻塞队列中</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 再次取新值判断</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池停止了，并且任务被成功移除</span></span><br><span class="line">        reject(command); <span class="comment">// reject handler</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// workerCount 为 0 </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// ？经过上面内部的层层判断，逻辑不太会走到这里，不太理解此处的 null，在我看来这是一种“弃疗”的表现。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 再次使用 maximun 作为限定数尝试添加</span></span><br><span class="line">    reject(command); <span class="comment">// 线程池饱和处理 reject handler</span></span><br></pre></td></tr></table></figure>
<h5 id="addWorker的实现"><a href="#addWorker的实现" class="headerlink" title="addWorker的实现"></a>addWorker的实现</h5><p><code>addWorker</code>方法主要是创建线程，执行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry: <span class="comment">// 重试标记层级</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限定条件的for</span></span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 线程池状态不满足则直接返回 false</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY || <span class="comment">// 如果 workerCount 大于 容量</span></span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize)) </span><br><span class="line">                   <span class="comment">// 如果 workerCount 大于 核心线程数（外部以核心线程数作为判断依据时） 或 workerCount 大于 最大线程数(外部以最大线程数作为判断依据时)</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 容量受限，返回false</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 通过上面的检测，并更新数值成功</span></span><br><span class="line">                   <span class="keyword">break</span> retry; <span class="comment">// 跳出 多层循环，往方法的下半部分继续执行</span></span><br><span class="line">               c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 上面未设值成功，状态 没有变化</span></span><br><span class="line">                   <span class="keyword">continue</span> retry; <span class="comment">// 继续外部循环</span></span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是这个方法的前半部分，主要是线程池状态检测、线程池数量限制检测、线程池相关数量与状态的更新。以下是下半部分代码，主要是创建线程，执行任务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 线程池的工作 通过 Worker 类，Worker 类继承了 AQS （AbstractQueuedSynchronizer）</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 线程是取的 worker中的线程，而worker中的线程是线程池初始化的 线程工厂创建的</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; <span class="comment">// ReentrantLock 锁的保证下，插入到 workers(HashSet结构)中</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">            <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">            <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                workers.add(w); <span class="comment">// 加入 hashSet 中</span></span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start(); <span class="comment">// 添加成功 开始 运行</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure></p>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123; <span class="comment">// </span></span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">// 初始化线程池的 线程工厂来创建线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">// runnable 接口的实现，启动线程 运行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="runWorker实现"><a href="#runWorker实现" class="headerlink" title="runWorker实现"></a>runWorker实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts // 线程启动后通过unlock释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 首次进入会执行 firstTask，后面则主要通过getTask()方法取队列中的任务</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 前置任务</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run(); <span class="comment">// 开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 后置任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getTask-实现"><a href="#getTask-实现" class="headerlink" title="getTask 实现"></a>getTask 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 在指定时间内，阻塞队列没有新的任务，则会返回null</span></span><br><span class="line">                workQueue.take(); <span class="comment">// 如果阻塞队列为空，当前线程被挂起；队列中有任务加入时，线程被唤醒，返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Future-和-Callable-的实现"><a href="#Future-和-Callable-的实现" class="headerlink" title="Future 和 Callable 的实现"></a>Future 和 Callable 的实现</h4><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Task()); <span class="comment">// 提交异步任务</span></span><br><span class="line">        System.out.println(<span class="string">"do other things"</span>);</span><br><span class="line">        </span><br><span class="line">        String result = future.get(); <span class="comment">// 线程阻塞</span></span><br><span class="line">        System.out.println(<span class="string">"asynchronus result:"</span> + result); <span class="comment">// 后面跟随的代码，等待上面的阻塞解除执行完后，才会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 睡眠2s，模拟异步耗时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"this is future case"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际业务场景中，<code>Future</code>与<code>Callable</code>一般是成对出现的，<code>Callable</code>负责执行任务产生结果，<code>Future</code>则是负责获取结果</p>
<ol>
<li><code>Callable</code>接口类似<code>Runnable</code>接口，只是<code>Runnable</code>没有返回值。所以如果你关心你每个任务的执行返回结果，就可以采用<code>Callable</code>，否则你就直接使用<code>Runnable</code>就好了。</li>
<li><code>Callable</code>执行的任务如果发生异常，该异常也会被返回，即<code>Future</code>可以拿到异步执行任务的各种结果。</li>
<li><code>Future.get</code>方法是阻塞的，直到<code>Callable</code>任务执行完成</li>
</ol>
<h5 id="submit实现"><a href="#submit实现" class="headerlink" title="submit实现"></a>submit实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable</code>任务通过<code>submit()</code>方法被封装为一个<code>RunnableFuture</code>的<code>FutureTask</code>.</p>
<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>state 存储 <code>FutureTask</code>的状态，</li>
<li>构造初始状态为<code>NEW</code>，构造函数使用<code>callable</code>成员变量存储了入参<code>callable</code>任务</li>
<li><code>FutureTask</code>实现了<code>Runnable</code>接口，最终实际执行的是<code>FutureTask</code>中的<code>run</code>方法</li>
</ul>
<h5 id="FutureTask-get实现"><a href="#FutureTask-get实现" class="headerlink" title="FutureTask.get实现"></a>FutureTask.get实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING) <span class="comment">// 状态检查</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部通过<code>awaitDone</code>方法阻塞，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果线程被中断，则抛出异常</li>
<li>如果状态大于<code>COMPLETING</code>说明已经完成，直接返回状态即可</li>
<li>如果状态等于<code>COMPLETING</code>说明已经完成，使用<code>yield</code>让渡一下<code>cpu</code>，<code>state</code>则会过度到<code>NORMAL</code>了</li>
<li>通过<code>WaitNode</code>简单链表封装当前线程，并通过<code>UNSAFE</code>添加到<code>waiters</code>链表</li>
<li>最终通过<code>LockSupport</code>的<code>park</code>或<code>parkNanos</code>来挂起线程，另外<code>finishCompletion</code>方法中会<code>unpark</code></li>
</ul>
<h5 id="FutureTask-run-实现"><a href="#FutureTask-run-实现" class="headerlink" title="FutureTask.run 实现"></a>FutureTask.run 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>run</code> 方法是线程池中的线程来执行的，而非主线程</li>
<li>执行<code>callable.call</code>方法来运行任务</li>
<li><code>call</code>通过时用<code>set</code>方法来保存结果</li>
<li><code>call</code>出现异常时用<code>setException</code>方法来保持异常信息</li>
</ul>
<h5 id="set-setException"><a href="#set-setException" class="headerlink" title="set/setException"></a>set/setException</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>UNSAFE</code>修改了<code>FutureTask</code>的状态，最终都通过调用<code>finishCompletion</code>方法通知主线程任务完成。</p>
<h5 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新<code>waiters</code>的值</li>
<li><code>LockSupport.unpark(t)</code>唤醒主线程</li>
</ul>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/87bff5cc8d8c" target="_blank" rel="noopener">占小狼-深入分析java线程池的实现原理</a> </li>
<li>《JAVA并发编程实践》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/15/java线程池实现原理分析/" data-id="cjjwiirg7003aftrjosgtywqa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-好文推荐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/好文推荐/" class="article-date">
  <time datetime="2017-05-24T03:08:56.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/好文推荐/">好文推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一些总结的好，不一定是要文笔有多好，或者涵盖广泛。只要是能给我提供一些想法，或者是能帮助完善自己的一些想法，这里存储下链接，做一下简要记录，希望不要像书签一样，存的多却看的少。</p>
<ul>
<li><a href="http://www.zcfy.cc/article/how-to-get-node-js-logging-right-518.html" target="_blank" rel="noopener">如何让Node.js正确地日志</a> - 2017年5月24日11:14:46：<blockquote>
<p>虽然写的是Node.js的，但是提到<strong>日志的几个要点</strong>、<strong>日志的应用范围</strong>，在其他语言中同样也是适用的，抽象出概念能帮助理解日志。<br>要点：时间戳、格式、日志目标、日志级别<br>应用范围：库类型、单个应用程序、分布式系统<br><a href="https://github.com/eggjs/egg-logger" target="_blank" rel="noopener">egg-logger的图也助于理解主流日志框架</a></p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/24/好文推荐/" data-id="cjjwiirgu004fftrjpvicq073" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javascript模块化方式简记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/javascript模块化方式简记/" class="article-date">
  <time datetime="2017-05-23T03:19:46.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/javascript模块化方式简记/">javascript模块化方式简记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a><code>CommonJS</code> 规范</h5><p><code>node.js</code>是服务端的编程，需要与操作系统、其他应用互动，需要模块化，否则无法编程，而在浏览器其复杂性有限，没有模块化也不是特别大的问题。而<code>node.js</code>的模块系统就是操作<code>CommonJS</code>规范实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./A'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a><code>AMD</code> 规范</h5><p>有了服务端模块化后，很自然地，大家就想要客户端模块化。而且最好能与服务端兼容，模块都不用修改，在服务器和浏览器都可以运行。但是<strong>浏览器加载<code>模块文件</code>是跨网络的</strong>，加载可能会造成假死，后面的代码无法运行。而服务端是在本地硬盘的，这对服务端不是问题。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p><code>AMD</code>是”Asynchronous Module Definition”，意识就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响他后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等模块加载完成后，这个回调函数才会运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖前置，提前执行</span></span><br><span class="line">    a.xx();</span><br><span class="line">    b.xx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://requirejs.org/" target="_blank" rel="noopener"><code>require.js</code></a>是<code>AMD</code>规范的一个实现。</p>
<h5 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a><code>CMD</code> 规范</h5><p><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.xxx();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>); <span class="comment">//依赖就近书写</span></span><br><span class="line">    b.xxx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="静态加载与动态加载"><a href="#静态加载与动态加载" class="headerlink" title="静态加载与动态加载"></a>静态加载与动态加载</h4><p><code>es6</code>之前模块加载的两种方式</p>
<ul>
<li>静态加载：在编译阶段进行，把所有需要的依赖打包到一个文件</li>
<li>动态加载：在运行时加载</li>
</ul>
<p><code>AMD</code>标准是动态加载的代表，而<code>CommonJS</code>是静态加载的代表。</p>
<p><code>AMD</code>主要用在浏览器上，是异步加载的，而<code>NodeJS</code>在服务端，同步加载的方式更易被接收，所以用的是<code>CommonJS</code>。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><code>ES6</code></h5><p><code>ES6</code>采用哪种加载机制了？ <code>ES6</code>既希望用简单的声明来完成静态加载，有不愿放弃动态加载的特性，而这两种方式几乎不能简单的同时实现，所以<code>ES6</code>提供了两种独立的模块加载方法。</p>
<ol>
<li><p>声明的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> some_module;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>System.import</code> API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.import(<span class="string">'some_module)</span></span><br><span class="line"><span class="string">    .then(some_module =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    .catch(error =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>模块导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export 一个命名 function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export default function</span></span><br><span class="line"><span class="keyword">export</span> num = <span class="number">123</span> <span class="comment">// export 一个数值</span></span><br><span class="line"><span class="keyword">export</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; obj <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// default export</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> myModule&#125; <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// rename</span></span><br><span class="line"><span class="keyword">import</span> &#123;abc, num, obj&#125; <span class="keyword">from</span> <span class="string">'some_module'</span></span><br></pre></td></tr></table></figure></p>
<p>参考自：</p>
<ul>
<li><a href="https://blog.wilddog.com/?p=587" target="_blank" rel="noopener">写了十年JS却不知道模块化为何物？</a></li>
<li><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">Sea.js 与 RequireJS 的异同</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/23/javascript模块化方式简记/" data-id="cjjwiirg40035ftrjfbtyidy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AMD/">AMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CMD/">CMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字节序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/字节序/" class="article-date">
  <time datetime="2017-05-16T01:31:57.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/字节序/">字节序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实已经有几次写到过有关字节序的问题了，这里单独拎出来再写一次，是因为又淡忘了，特意抽象其根本问题再做一个简要的记录。</p>
<p>抽象出的两个概念：</p>
<ol>
<li>存储地址：内存地址“从左至右”递增，可以理解往左是低位地址，往右是高位地址</li>
<li>要存的值：比如1个数字 112233(十进制)、1个字符串 “112233”  —(这里两处的33都是尾巴)</li>
</ol>
<p>注意：1个xx需要多个字节表示的时候，才会有字节序的问题</p>
<h4 id="面临的问题：-尾巴放到高的位置还是低的位置？"><a href="#面临的问题：-尾巴放到高的位置还是低的位置？" class="headerlink" title="面临的问题： 尾巴放到高的位置还是低的位置？"></a>面临的问题： 尾巴放到高的位置还是低的位置？</h4><p><strong>高尾端：高的位置存尾巴</strong></p>
<p><strong>低尾端：低的位置存尾巴</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1ffmybwhwrwj20jm0ax0sr.jpg" alt="字节序"></p>
<h4 id="比拟"><a href="#比拟" class="headerlink" title="比拟"></a>比拟</h4><p>一个<code>词</code>中<code>字</code>的顺序 (普遍：从左至右念，牌匾：从右至左念)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">法语，公主，四十</span><br></pre></td></tr></table></figure></p>
<p>一行文字中字的读取顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严管妻是本；妇顺夫为实.</span><br></pre></td></tr></table></figure></p>
<p>解析的顺序不一样意义就大不一样咯。</p>
<h4 id="其他叫法"><a href="#其他叫法" class="headerlink" title="其他叫法"></a>其他叫法</h4><p><code>高尾端/大端序/大尾序</code></p>
<p><code>低尾端/小端序/小尾序</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/16/字节序/" data-id="cjjwiirgw004jftrj2d0pxe73" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-事务及隔离级别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/事务及隔离级别/" class="article-date">
  <time datetime="2017-05-08T08:12:08.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/事务及隔离级别/">事务及隔离级别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><p>据库具有 <strong>ACID</strong>四个特性，分别指：</p>
<h5 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity - 原子性"></a>Atomicity - 原子性</h5><p>原子操作不可分割，内部要么全部成功，要么全部失败。</p>
<h5 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency - 一致性"></a>Consistency - 一致性</h5><p>系统从一个一致状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性，下面会详细提到。</p>
<h5 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation - 隔离性"></a>Isolation - 隔离性</h5><p>事务不被其他事务干扰，相互隔离。 每个事务都感觉不到其他事务在执行，下面为详细提到事务的隔离的级别。</p>
<h5 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability - 持久性"></a>Durability - 持久性</h5><p>事务一旦提交，那么数据的改变就是永久性的。</p>
<h4 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h4><p>此处主要参考: <a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>
<ul>
<li><strong>强一致性</strong>：读操作可以立即读到提交的更新操作。</li>
<li><strong>弱一致性</strong>: 提交的更新操作，不一定立即会被操作读取到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li>
<li><strong>最终一致性</strong>: 是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li>
<li><strong>单调一致性</strong>: 如果一个进程已经读到一个值，那么后续不会读到更早的值。</li>
<li><strong>会话一致性</strong>: 保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li>
</ul>
<h4 id="事务隔离性"><a href="#事务隔离性" class="headerlink" title="事务隔离性"></a>事务隔离性</h4><p>如果不考虑隔离性，在事务并发操作时，可能出现的问题有：</p>
<ul>
<li><strong>脏读</strong>：<strong>一个事务读取了另一个事务未提交的数据</strong><blockquote>
<p>例如：公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。</p>
</blockquote>
</li>
<li><strong>不可重复读</strong>：<strong>一个事务内，单份数据多次读取结果不同</strong>，这是由于<strong>读取间隔，被别的事务修改并提交了</strong> （事务内重复读取会有问题，不重复读则没问题，则理解为<code>不可重复读</code>问题）<blockquote>
<p>例如：singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何……</p>
</blockquote>
</li>
<li><strong>幻读</strong>：<strong>一个事务内，多次读取数据的结果集合不同</strong>，幻读是由于<strong>读取间隔，被别的事务插入了数据</strong><blockquote>
<p>例如：singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了</p>
</blockquote>
</li>
</ul>
<p>针对上面的问题，一般定义有以下几种事务隔离级别：</p>
<ul>
<li><strong>READ UNCOMMITED</strong> (可以读取到未提交的数据)一个事务可以读到另一个事务未提交的结果，以上的<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>问题都可能会发生。</li>
<li><strong>READ COMMITED</strong>  (可以读取到已提交的数据)只有在事务提交后，其更新结果才会被其他事务看见。<strong>可以解决上面的脏读问题</strong></li>
<li><strong>Repeated Read</strong> (重复读取)在同一个事务中，对于同一份数据的读取结果总是相同的，无论其他事务对这份数据是否进行操作，以及整个事务是否提交。<strong>可以解决脏读、不可重复读问题</strong></li>
<li><strong>Serializable</strong> (串行化) 隔离级别最高，牺牲了系统的并发性。<strong>可以解决并发事务的所有问题</strong></li>
</ul>
<p>大多数数据库的默认级别就是<code>Read committed</code>，如<code>Oracle</code>、<code>SQL Server</code>; </p>
<p>注：<code>MySQL</code> 的默认隔离级别是<code>REPEATABLE-READ</code>，查看命令<code>select @@tx_isolation;</code></p>
<p>例子参考：</p>
<p><a href="http://singo107.iteye.com/blog/1175084" target="_blank" rel="noopener">数据库事务隔离级别</a></p>
<p><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">数据库事务的四大特性以及事务的隔离级别</a></p>
<p><a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/08/事务及隔离级别/" data-id="cjjwiirgl003yftrjrnxzp3nu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-书单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/书单/" class="article-date">
  <time datetime="2017-04-14T05:51:52.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/书单/">书单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>书是系统性的表达，相对单篇的博客、资讯，书内容更加完整富有体系。对于一些新流行的技术，网上的资讯快餐更及时，书的内容往往会跟不上潮流，但是经典的东西往往早已沉淀在书中了。
</code></pre><h2 id="正读"><a href="#正读" class="headerlink" title="正读"></a>正读</h2><ul>
<li>《编码-隐匿在计算机背后的软硬件语言》</li>
<li>《大话数据结构》</li>
<li>《大话设计模式》</li>
</ul>
<h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ul>
<li>《JavaScript高级程序设计（第3版）》</li>
<li>《Java多线程编程核心技术》</li>
<li><p>《鸟哥的Linux私房菜》</p>
</li>
<li><p>《把时间当作朋友》</p>
</li>
<li>《黑客与画家》</li>
<li>《一个人的朝圣》</li>
<li>《影响力》</li>
<li><p>《习惯的力量》</p>
</li>
<li><p>《潜规则》</p>
</li>
<li>《摆渡人》</li>
<li>《解读量化投资：西蒙斯用公式打败市场的故事》</li>
<li>《从你的全世界路过》</li>
<li>《我不是潘金莲》</li>
<li>《解忧杂货店》</li>
<li>《智齿》</li>
<li>《别做正常的傻瓜》</li>
<li>《别拿村长不当干部》</li>
<li>《老鼠仓》</li>
<li>《为奴十二年》</li>
<li>《追风筝的人》</li>
<li>《人性弱点》</li>
<li>《如何变得有思想？》</li>
</ul>
<h2 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h2><ul>
<li>《编写高质量代码：改善Java程序的151个建议》</li>
<li><p>《TCP-IP协议族(第4版)》</p>
</li>
<li><p>《岛上书店》</p>
</li>
<li>《无声告白》</li>
<li>《我的晃荡青春》</li>
<li>《白夜行》</li>
<li>《沉默的大多数》</li>
<li>《世界上的另一个你》</li>
<li>《不抱怨的世界》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://book.douban.com" target="_blank" rel="noopener">豆瓣读书</a></li>
<li><a href="http://www.cnblogs.com/xing901022/p/3694709.html" target="_blank" rel="noopener">他人书单1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/14/书单/" data-id="cjjwiirgj003uftrjty3r34tg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux操作常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/Linux操作常用命令/" class="article-date">
  <time datetime="2017-04-12T02:33:08.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/Linux操作常用命令/">Linux操作常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一些常用的技巧，隔一段时间不用又给淡忘了。</p>
<h3 id="打包压缩、解压"><a href="#打包压缩、解压" class="headerlink" title="打包压缩、解压"></a>打包压缩、解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// .tar.bz2 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jcv -f /root/<span class="built_in">test</span>/etc.tar.bz2 /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jxv -f  /root/<span class="built_in">test</span>/etc.tar.bz2  -C /tmp/</span></span><br><span class="line"></span><br><span class="line">// .tar.gz 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zcv -f /root/<span class="built_in">test</span>/etc.tar.gz /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zxv -f  /root/<span class="built_in">test</span>/etc.tar.gz  -C /tmp/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -sf /usr/local/postgresql-9.2.4 /usr/local/pgsql</span></span><br><span class="line"><span class="comment">## -s: symbole 软链接，-f: force 如果目标链接已经存在则删除重新建立</span></span><br><span class="line"><span class="comment">## 如果9.2.5的版本发布了，升级只需停掉数据库在这里改下软链接地址就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="当前目录-各文件夹-大小-linux"><a href="#当前目录-各文件夹-大小-linux" class="headerlink" title="当前目录 各文件夹 大小 linux"></a>当前目录 各文件夹 大小 linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find $1 -maxdepth 1 | xargs du -sh</span></span><br></pre></td></tr></table></figure>
<h3 id="强制停止应用的两种方式"><a href="#强制停止应用的两种方式" class="headerlink" title="强制停止应用的两种方式"></a>强制停止应用的两种方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;print $2&#125;'|xargs kill -9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;system("kill -9 " $2)&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="某次服务器中毒，删除与病毒文件同样大小字节的文件"><a href="#某次服务器中毒，删除与病毒文件同样大小字节的文件" class="headerlink" title="某次服务器中毒，删除与病毒文件同样大小字节的文件"></a>某次服务器中毒，删除与病毒文件同样大小字节的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -size 1223123c | xargs rm -rf</span></span><br></pre></td></tr></table></figure>
<h3 id="find类-其他"><a href="#find类-其他" class="headerlink" title="find类 其他"></a>find类 其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正则匹配删除</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "2016-12-1[2-7]"|xargs rm -rf</span></span><br><span class="line"></span><br><span class="line">// 反向匹配，找出名字不含 <span class="string">"tar"</span> 的文件/文件夹</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "tar" -v</span></span><br></pre></td></tr></table></figure>
<h3 id="根据进程获取进程号，打印进程的运行信息"><a href="#根据进程获取进程号，打印进程的运行信息" class="headerlink" title="根据进程获取进程号，打印进程的运行信息"></a>根据进程获取进程号，打印进程的运行信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pgrep mysql | xargs -I &#123;&#125; ls -l /proc/&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="crontab-同步时间，"><a href="#crontab-同步时间，" class="headerlink" title="crontab 同步时间，"></a>crontab 同步时间，</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// crontab 分、时、日、月、周</span><br><span class="line">// 10分钟同步一次</span><br><span class="line"><span class="comment"># */10 * * * * /usr/sbin/ntpdate time.windows.com &amp;&amp; hwclock -w</span></span><br></pre></td></tr></table></figure>
<h3 id="输出磁盘的读写情况"><a href="#输出磁盘的读写情况" class="headerlink" title="输出磁盘的读写情况"></a>输出磁盘的读写情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iostat -k 2</span></span><br></pre></td></tr></table></figure>
<h3 id="新增磁盘"><a href="#新增磁盘" class="headerlink" title="新增磁盘"></a>新增磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// fdisk: 操作磁盘分区表</span><br><span class="line">// mkfs：对磁盘分区进行文件系统格式化</span><br><span class="line"></span><br><span class="line">// 列出磁盘装置，找到我们要操作的装置名称，便于对其进行分区</span><br><span class="line"><span class="comment"># fdisk -l </span></span><br><span class="line"></span><br><span class="line">// 开始对磁盘进行分区处理，注意不要加上数字</span><br><span class="line"><span class="comment"># fdisk /dev/xvdb  </span></span><br><span class="line"></span><br><span class="line">// 对分区进行格式化</span><br><span class="line"><span class="comment"># mkfs -t ext4 -c /dev/xvdb1</span></span><br><span class="line"></span><br><span class="line">// 建立磁盘挂载目录</span><br><span class="line"><span class="comment"># mkdir /data</span></span><br><span class="line"></span><br><span class="line">// 手动挂载</span><br><span class="line"><span class="comment"># mount /dev/xvdb1 /data/</span></span><br><span class="line"></span><br><span class="line">// 开机自动挂载</span><br><span class="line"><span class="comment"># echo "/dev/xvdb1 /data/ ext4 defaults 0 0" &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>
<h3 id="看你在Linux下最常用的命令是哪些？"><a href="#看你在Linux下最常用的命令是哪些？" class="headerlink" title="看你在Linux下最常用的命令是哪些？"></a>看你在Linux下最常用的命令是哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | awk <span class="string">'&#123;CMD[$2]++;count++;&#125; END &#123; for (a in CMD )print CMD[ a ]" " CMD[ a ]/count*100 "% " a &#125;'</span> | grep -v <span class="string">"./"</span> | column -c3 -s <span class="string">" "</span> -t |sort -nr | nl | head -n10</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/12/Linux操作常用命令/" data-id="cjjwiirfl002aftrjev1pz0ir" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java多线程编程核心技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/06/java多线程编程核心技术/" class="article-date">
  <time datetime="2017-04-06T06:35:32.000Z" itemprop="datePublished">2017-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/06/java多线程编程核心技术/">java多线程编程核心技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果你认为多线程编程就是一堆的线程在运行一堆的代码，那将会一团糟。程序有时候正常，偶尔又异常，多线程的编程将变的困难。</p>
<p>但是如果你能将线程按需来分配，控制线程间的交互，那问题就变得简单多了。</p>
<p>多线程双刃剑：充分利用多核，复杂度提升，操作共享资源处理不好时会带来线程安全问题。</p>
<p>WEB编程普遍缺乏对多线程的理解：web容器实现，屏蔽了复杂的编程细节，多线程处理，（自己实现一款简单的web容器）</p>
<h2 id="一、Java多线程技能"><a href="#一、Java多线程技能" class="headerlink" title="一、Java多线程技能"></a>一、Java多线程技能</h2><p>Skills:</p>
<ul>
<li>线程的启动</li>
<li>如何使线程暂停</li>
<li>如何是线程停止</li>
<li>线程的优先级</li>
<li>线程安全相关的问题</li>
</ul>
<h3 id="1-1-进程和多线程的概念及线程的优点"><a href="#1-1-进程和多线程的概念及线程的优点" class="headerlink" title="1.1 进程和多线程的概念及线程的优点"></a>1.1 进程和多线程的概念及线程的优点</h3><p>进程是操作系统结构的基础，它是系统进行资源分配和调度的一个独立单位。可以将windows任务管理器的<code>.exe</code>理解成一个进程。<br>线程：线程就是进程中独立的子任务，比如QQ.exe运行时，有视频的线程、下载文件线程、传输数据线程等。<br>优点：在多任务操作系统中效率大大提升。</p>
<h3 id="1-2-使用多线程"><a href="#1-2-使用多线程" class="headerlink" title="1.2 使用多线程"></a>1.2 使用多线程</h3><p>一个进程中至少会有一个线程在运行，比如常见的<code>main</code>函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-1-继承Thread类"><a href="#1-2-1-继承Thread类" class="headerlink" title="1.2.1 继承Thread类"></a>1.2.1 继承Thread类</h4><p>实现多线程的主要方式有两种：一种是继承<code>Thread</code>类，另一种是实现<code>Runnable</code>接口。<br>前者与后者工作时的性质是一样的，继承<code>Thread</code>最大的局限就是不支持多继承.<br>继承实现的方式就是继承<code>Thread</code>类，重写<code>run</code>方法，然后创建线程类实例，调用其<code>start</code>方法即启动了一个线程<br><code>如果多次调用start()方法，则会出现异常 IllegalThreadStateException ..</code></p>
<h4 id="1-2-2-实现Runnable接口"><a href="#1-2-2-实现Runnable接口" class="headerlink" title="1.2.2 实现Runnable接口"></a>1.2.2 实现Runnable接口</h4><p>实现方式：实现<code>Runnable</code>接口并实现<code>run</code>方法</p>
<h4 id="1-2-3-实例变量与线程安全"><a href="#1-2-3-实例变量与线程安全" class="headerlink" title="1.2.3 实例变量与线程安全"></a>1.2.3 实例变量与线程安全</h4><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>; <span class="comment">//实例变量(非static)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">"由 "</span> + Thread.currentThread().getName() + <span class="string">" 计算， count="</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行方式一，不共享数据，运行类Run:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread a = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">        MyThread b = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">        MyThread c = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里共创建了3个线程，每个线程都有自己的count变量，不存在访问同一个实例变量的情况。</p>
<p>运行方式二，共享数据，运行了ShareRun:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareRun</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread threadRun = <span class="keyword">new</span> MyThread(); <span class="comment">// 使用同一个Runnable实现类的实例</span></span><br><span class="line">        </span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(threadRun, <span class="string">"A"</span>); <span class="comment">// 再通过Thread包装</span></span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(threadRun, <span class="string">"B"</span>);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(threadRun, <span class="string">"C"</span>);</span><br><span class="line">        Thread d = <span class="keyword">new</span> Thread(threadRun, <span class="string">"D"</span>);</span><br><span class="line">        Thread e = <span class="keyword">new</span> Thread(threadRun, <span class="string">"E"</span>);</span><br><span class="line">        </span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jvm的i–分3个步骤：</p>
<blockquote>
<ol>
<li>取i值</li>
<li>计算i-1</li>
<li>赋值i</li>
</ol>
</blockquote>
<p>此时多个线程访问<code>threadRun</code>实例的变量出现非线程安全问题，这就是典型的线程问题了。这时通过在<code>run</code>方法前添加<code>synchronized</code>可以解决这种问题。<br><code>synchronized</code>可以在任意对象及方法上加锁。<br>多个线程执行<code>run</code>时，以排队的方式执行，先判断<code>run</code>方法有没有上锁，如果有上锁说明其他线程正在执行，等待其他线程执行。线程尝试拿锁，如果没有<br>拿所锁，这个线程就会不断的尝试拿这把锁，直到拿到为止。</p>
<h4 id="1-2-4-注意count–与System-out-println-异常"><a href="#1-2-4-注意count–与System-out-println-异常" class="headerlink" title="1.2.4 注意count–与System.out.println()异常"></a>1.2.4 注意count–与System.out.println()异常</h4><p>将上面代码里面<code>count--</code> 放置到<code>System.out.println()</code>中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"由 "</span> + Thread.currentThread().getName() + <span class="string">" 计算， count="</span> + (count--));</span><br></pre></td></tr></table></figure></p>
<p>我们注意下在jdk的源码中<code>System.out.println()</code>这个方法内部是有<code>synchronized</code>的，说明这个方法是线程安全。<br>但是上面的代码也会发生非线程安全问题，因为<code>count--</code>这个计算是在<code>println</code>方法前执行的，这个有点类似<code>scala</code>的求值策略的<code>Call by Value</code>，<br>先会将形参计算出来 ，再进入方法中。</p>
<h3 id="1-3-currentThread-方法"><a href="#1-3-currentThread-方法" class="headerlink" title="1.3 currentThread()方法"></a>1.3 currentThread()方法</h3><p><code>currentThread()</code>方法可以返回代的段正被哪个线程所执行，可以在线程类的run方法打印执行线程的名称，然后在外部分别使用线程的<code>start</code>和<code>run</code>方法执行对比查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-isAlive-方法"><a href="#1-4-isAlive-方法" class="headerlink" title="1.4 isAlive()方法"></a>1.4 isAlive()方法</h3><p><code>isAlive()</code> 方法是用来判断线程是否属于活动状态，活动状态即<code>线程已经启动且位尚未终止</code></p>
<h3 id="1-5-sleep-方法"><a href="#1-5-sleep-方法" class="headerlink" title="1.5 sleep()方法"></a>1.5 sleep()方法</h3><p><code>sleep()</code>方法是用来让线程暂停指定的时间。</p>
<h3 id="1-6-getId-方法"><a href="#1-6-getId-方法" class="headerlink" title="1.6 getId()方法"></a>1.6 getId()方法</h3><p><code>getId()</code>方法用来获取线程的唯一标识。</p>
<h3 id="1-7-停止线程"><a href="#1-7-停止线程" class="headerlink" title="1.7 停止线程"></a>1.7 停止线程</h3><p>停止线程是在多线程开发时重要的技术点，它不想循环中的break简单粗暴，需要一些技巧性的处理，处理好一些身后事(关闭资源连接、事务)才停止线程。<br><code>Thread.stop()</code>可以停止一个线程，但不建议使用它，这个方法是不安全的。<br>大多数停止一个线程的操作使用的是<code>Thread.interrupt()</code>，尽管方法名称是终止、停止的意思，但这个方法不会终止一个正在运行的线程，需要加入一些判断才可以完成线程的停止。<br>3种终止正在运行的线程的方法：</p>
<ol>
<li>使用退出标志，使程序正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止，但是不推荐使用，stop、suspend、resume都是作废过期的方法，使用它们可能会产生意料不到的结果。（强制性停止可能使一些清理工作得不到完成。）</li>
<li>使用interrupt方法，程序判断isInterrupted，使用throw/return来中断线程，推荐“抛异常”方式</li>
</ol>
<h4 id="1-7-1-停止不了的线程"><a href="#1-7-1-停止不了的线程" class="headerlink" title="1.7.1 停止不了的线程"></a>1.7.1 停止不了的线程</h4><p>下面的例子演示了<code>interrupt</code>停止不了线程的现象：<br>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread  t = <span class="keyword">new</span> MyThread();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终控制台还是打印了50万行，没有停止住线程。</p>
<h4 id="1-7-2-判断线程是否是停止状态"><a href="#1-7-2-判断线程是否是停止状态" class="headerlink" title="1.7.2 判断线程是否是停止状态"></a>1.7.2 判断线程是否是停止状态</h4><p>我们来看下如何判断线程状态不是停止的。Thread提供了两种方法：</p>
<ol>
<li>Thread.interrupted: 测试当前线程是否已经中断，执行后将状态标识清除为false的功能。</li>
<li>this.isInterrupted: 测试当前线程是否已经中断，但不清除状态标志。</li>
</ol>
<p>可以参考: <a href="http://blog.csdn.net/z69183787/article/details/25076033" target="_blank" rel="noopener">interrupt、interrupted 、isInterrupted 区别</a></p>
<h4 id="1-7-3-能停止的线程——异常法"><a href="#1-7-3-能停止的线程——异常法" class="headerlink" title="1.7.3 能停止的线程——异常法"></a>1.7.3 能停止的线程——异常法</h4><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//每次获取标识判断</span></span><br><span class="line">                System.out.println(<span class="string">"已经有了停止标识，我要退出了！"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//手动break</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"for 循环后面的代码被输出，线程其实未被停止。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的线程其实未真正停止，下面在接着改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//每次获取标识判断</span></span><br><span class="line">                    System.out.println(<span class="string">"已经有了停止标识，我要退出了！"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 改为 抛出异常的方式</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"for 循环后面的代码被输出，线程其实未被停止。--不会再输出"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入线程类的catch，线程终止"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-8-暂停、恢复线程"><a href="#1-8-暂停、恢复线程" class="headerlink" title="1.8 暂停、恢复线程"></a>1.8 暂停、恢复线程</h3><p>使用<code>suspend()</code>方法暂停线程，使用<code>resume()</code>方法恢复线程执行。</p>
<h4 id="1-8-1-测试"><a href="#1-8-1-测试" class="headerlink" title="1.8.1 测试"></a>1.8.1 测试</h4><p>演示功能效果，起到暂停、恢复效果，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeTest.java" target="_blank" rel="noopener">SuspendResumeTest.java</a></p>
<h4 id="1-8-2-suspend与resume方法的缺点——独占"><a href="#1-8-2-suspend与resume方法的缺点——独占" class="headerlink" title="1.8.2 suspend与resume方法的缺点——独占"></a>1.8.2 suspend与resume方法的缺点——独占</h4><p>线程类内部锁，独占，此类的其他线程实例也被阻塞，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeDealLock.java" target="_blank" rel="noopener">SuspendResumeDealLock.java</a></p>
<p>公共锁同步对象被独占，造成主线程阻塞，例如<code>println</code>方法，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeLockStop.java" target="_blank" rel="noopener">SuspendResumeLockStop.java</a><br>注释掉除线程内部的<code>println</code>方法后面的代码即恢复执行。</p>
<h4 id="1-8-3-suspend与resume方法的缺点——不同步"><a href="#1-8-3-suspend与resume方法的缺点——不同步" class="headerlink" title="1.8.3 suspend与resume方法的缺点——不同步"></a>1.8.3 suspend与resume方法的缺点——不同步</h4><p>使用<code>suspend</code>与<code>resume</code>方法时容易出现因为线程的暂停而导致数据不同步的情况。</p>
<p>值不同步的情况，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeNoSameValue.java" target="_blank" rel="noopener">SuspendResumeNoSameValue.java</a> </p>
<h3 id="1-9-yiled-方法"><a href="#1-9-yiled-方法" class="headerlink" title="1.9 yiled 方法"></a>1.9 yiled 方法</h3><p><code>yield()</code>方法的作用是放弃当前<code>CPU</code>资源，放弃时间不确定，有可能刚放弃，马上又获得了CPU时间片。</p>
<p>去除注释前后对比测试下吧，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/YieldTest.java" target="_blank" rel="noopener">YieldTest.java</a> </p>
<h3 id="1-10-线程优先级"><a href="#1-10-线程优先级" class="headerlink" title="1.10 线程优先级"></a>1.10 线程优先级</h3><p>线程可以划分优先级，优先级高的线程得到的<code>CPU</code>资源角度，也就是CPU优先执行优先级较高的线程对象中的任务。<code>java</code>中优先级设置中定义的几个常量：<code>MIN_PRIORITY=1</code>、<code>NORM_PRIORITY=5</code>、<code>MAX_PRIORITY=10</code>，设置小于1或者大于10将会抛出<code>IllegalArgumentException</code></p>
<h4 id="1-10-1-优先级的继承性"><a href="#1-10-1-优先级的继承性" class="headerlink" title="1.10.1 优先级的继承性"></a>1.10.1 优先级的继承性</h4><p><code>java</code>中，线程的优先级具有有继承性，比如<code>A线程</code><del>启动</del><strong>创建了</strong>了<code>B线程</code>，则<code>B线程</code>的优先级与<code>A线程</code>是一样的。</p>
<p>继承特性，上面写道了<code>创建了</code>，可以将<code>创建 t1</code>调换值至<code>设置main优先级之前</code>测试下，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PriorityInheritanceTest.java" target="_blank" rel="noopener">PriorityInheritanceTest.java</a> </p>
<h4 id="1-10-1-优先级具有规则性"><a href="#1-10-1-优先级具有规则性" class="headerlink" title="1.10.1 优先级具有规则性"></a>1.10.1 优先级具有规则性</h4><p>高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部执行完。</p>
<h3 id="1-11-守护线程"><a href="#1-11-守护线程" class="headerlink" title="1.11 守护线程"></a>1.11 守护线程</h3><p>在<code>Java</code>进程中有两种线程，一种是用户线程，一种是守护线程。</p>
<p>守护线程的特性有“陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。</p>
<p>守护进程，测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/DaemonTest.java" target="_blank" rel="noopener">DaemonTest.java</a> , 理解：用户线程 main都结束了，守护线程们已经没有什么可守护的了，就结束了</p>
<h2 id="对象及变量的并发访问"><a href="#对象及变量的并发访问" class="headerlink" title="对象及变量的并发访问"></a>对象及变量的并发访问</h2><p>Skills:</p>
<ul>
<li><code>synchronized</code>监视<code>Object</code>的使用</li>
<li><code>synchronized</code>监视<code>Class</code>的使用</li>
<li>非线程安全是如何出现的</li>
<li>关键字<code>volatile</code>的主要作用</li>
<li>关键字<code>volatile</code>与<code>synchronized</code>的区别及使用情况</li>
</ul>
<h3 id="2-1-synchronized同步方法"><a href="#2-1-synchronized同步方法" class="headerlink" title="2.1 synchronized同步方法"></a>2.1 synchronized同步方法</h3><p>多线程并发访问共享资源，很可能发生“非线程安全”题，产生的后果就是”脏读”。而“线程安全”就是获得的资源是经过同步处理的，不会出现脏读现象。</p>
<h4 id="2-1-1-方法内的变量为线程安全"><a href="#2-1-1-方法内的变量为线程安全" class="headerlink" title="2.1.1 方法内的变量为线程安全"></a>2.1.1 方法内的变量为线程安全</h4><p>方法内的变量不存在线程安全问题，永远都是线程安全的，这是方法内部的变量私有的特性造成的。</p>
<h4 id="2-1-2-实例变量非线程安全"><a href="#2-1-2-实例变量非线程安全" class="headerlink" title="2.1.2 实例变量非线程安全"></a>2.1.2 实例变量非线程安全</h4><p>多个线程访问一个实例中变量发生线程安全问题, 测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadSafetyProblem.java" target="_blank" rel="noopener">ThreadSafetyProblem.java</a></p>
<h4 id="2-1-3-多个对象多个锁"><a href="#2-1-3-多个对象多个锁" class="headerlink" title="2.1.3 多个对象多个锁"></a>2.1.3 多个对象多个锁</h4><p><strong>关键字<code>synchronized</code>取的锁都是对象锁，而不是把一段代码或方法当作锁</strong></p>
<p>两个线程访问同一个类的的不同实例的相同同步方法，因为创建了不同的实例，系统将根据实例个数产生锁。测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoObjectTwoLock.java" target="_blank" rel="noopener">TwoObjectTwoLock.java</a></p>
<h4 id="2-1-4-synchronized-方法与锁对象"><a href="#2-1-4-synchronized-方法与锁对象" class="headerlink" title="2.1.4 synchronized 方法与锁对象"></a>2.1.4 synchronized 方法与锁对象</h4><ul>
<li><code>A线程</code>先持有<code>object</code>对象的<code>Lock</code>锁，<code>B线程</code>可以调用<code>object</code>对象中的非<code>synchronized</code>类型的方法。</li>
<li><code>A线程</code>先持有<code>object</code>对象的<code>Lock</code>锁，<code>B线程</code>调用<code>object</code>对象中的<code>synchronized</code>类型的方法则需等待，也就是同步。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SynchronizedMethodLockObject.java" target="_blank" rel="noopener">SynchronizedMethodLockObject.java</a></p>
<h4 id="2-1-5-脏读"><a href="#2-1-5-脏读" class="headerlink" title="2.1.5 脏读"></a>2.1.5 脏读</h4><p>脏读出现在不同线程“争抢”实例变量的结果，即<code>2.1.4</code>中非同步方法随时可取共享资源就会造成脏读。</p>
<h4 id="2-1-6-synchronized-锁重入"><a href="#2-1-6-synchronized-锁重入" class="headerlink" title="2.1.6 synchronized 锁重入"></a>2.1.6 synchronized 锁重入</h4><p>线程进入<code>synchronized</code>方法调用本对象的另一个<code>synchronized</code>方法时，是永远可以得到锁的。即进入<code>synchronized</code>方法后可以无阻塞畅游本实例的所有方法了(当然这里不包括访问其他实例的<code>synchronized</code>方法)</p>
<h4 id="2-1-7-出现异常，锁自动释放"><a href="#2-1-7-出现异常，锁自动释放" class="headerlink" title="2.1.7 出现异常，锁自动释放"></a>2.1.7 出现异常，锁自动释放</h4><p>当一个线程执行代码出现异常时，其所持有的锁会自动释放。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ExceptionAutoReleaseLock.java" target="_blank" rel="noopener">ExceptionAutoReleaseLock.java</a></p>
<h4 id="2-1-8-同步不具有继承性"><a href="#2-1-8-同步不具有继承性" class="headerlink" title="2.1.8 同步不具有继承性"></a>2.1.8 同步不具有继承性</h4><p>子类重写父类的<code>synchronized</code>方法，如果该方法不添加<code>synchronized</code>标识，此方法将不再具有同步的特性。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncNotExtends.java" target="_blank" rel="noopener">SyncNotExtends.java</a></p>
<h3 id="2-2-synchronized-同步语句块"><a href="#2-2-synchronized-同步语句块" class="headerlink" title="2.2 synchronized 同步语句块"></a>2.2 synchronized 同步语句块</h3><p>多个线程访问同一个对象中的<code>synchronized(this)</code>同步代码块时，一段时间内只能有一个线程被执行，其他线程需要等待当前线程完成这个代码块的执行。我们来对比下，同步方法与同步块</p>
<p>同步方法，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncMethod.java" target="_blank" rel="noopener">SyncMethod.java</a></p>
<p>我们分析可以发现<code>doLongTimeTask</code>方法里面，只是对<code>getData1</code>、<code>getData2</code>赋值做了对<strong>共享资源</strong>的操作，之前部分的耗时操作不依赖<strong>共享资源</strong>，这部分代码完全可以<code>非同步</code>率先执行，所以修改方法，可以让方法内部达到<code>一般异步，一半同步</code>的效果。</p>
<p>同步块，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncBlock.java" target="_blank" rel="noopener">SyncBlcok.java</a></p>
<p>完成同样的效果，后者花费的时间缩短了50%；</p>
<h4 id="2-2-1-synchronized-方法的弊端"><a href="#2-2-1-synchronized-方法的弊端" class="headerlink" title="2.2.1 synchronized 方法的弊端"></a>2.2.1 synchronized 方法的弊端</h4><h4 id="2-2-2-synchronized-同步代码块的使用"><a href="#2-2-2-synchronized-同步代码块的使用" class="headerlink" title="2.2.2 synchronized 同步代码块的使用"></a>2.2.2 synchronized 同步代码块的使用</h4><h4 id="2-2-3-用同步方法解决同步方法的弊端"><a href="#2-2-3-用同步方法解决同步方法的弊端" class="headerlink" title="2.2.3 用同步方法解决同步方法的弊端"></a>2.2.3 用同步方法解决同步方法的弊端</h4><h4 id="2-2-4-一半异步，一半同步"><a href="#2-2-4-一半异步，一半同步" class="headerlink" title="2.2.4 一半异步，一半同步"></a>2.2.4 一半异步，一半同步</h4><p>其实上面提到的几点，上面的例子都已经体现了</p>
<p>同步方法弊端：也就是方法内部的代码，眉毛胡子一把抓，不区分“必须同步”与“可以异步”的代码将其“同步”的方式来执行，这样方法持锁时间更长，耗时更久。</p>
<p>同步块代码的使用：分析代码，区分<code>必须同步</code>与<code>可以非同步</code>，将同步代码加上<code>synchronized</code>。</p>
<h4 id="2-2-5-synchronized-代码块的同步性"><a href="#2-2-5-synchronized-代码块的同步性" class="headerlink" title="2.2.5 synchronized 代码块的同步性"></a>2.2.5 synchronized 代码块的同步性</h4><p>使用<code>synchronized(this)</code>代码块时，当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>方法时，其他线程访问对<code>object</code>其他所有的<code>synchronized(this)</code>方法访问将会阻塞。</p>
<h4 id="2-2-6-synchronized-this-代码是锁定当前对象的"><a href="#2-2-6-synchronized-this-代码是锁定当前对象的" class="headerlink" title="2.2.6 synchronized(this) 代码是锁定当前对象的"></a>2.2.6 synchronized(this) 代码是锁定当前对象的</h4><h4 id="2-2-7-将任意对象作为对象监视器"><a href="#2-2-7-将任意对象作为对象监视器" class="headerlink" title="2.2.7 将任意对象作为对象监视器"></a>2.2.7 将任意对象作为对象监视器</h4><p><code>synchronized</code>方法与<code>synchronized(this)</code>都具有：</p>
<ol>
<li>对其他<code>synchronized</code>方法与<code>synchronized(this)</code>同步块调用呈阻塞状态</li>
<li>同一时间只有一个线程执行当前<code>synchronized</code>方法块或<code>synchronized(this)</code>中的代码</li>
</ol>
<p><code>java</code>中支持对<code>任意对象</code>(注意此处是对象，基础的值类型可是不行的哦)作为“对象监视器”来实现同步功能，使用格式 <code>synchronized(非this)</code></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncBlockString.java" target="_blank" rel="noopener">SyncBlockString.java</a></p>
<h4 id="2-2-8-细化验证3个结论"><a href="#2-2-8-细化验证3个结论" class="headerlink" title="2.2.8 细化验证3个结论"></a>2.2.8 细化验证3个结论</h4><p><code>synchronized(非this对象x)</code>即意味着将对象<code>x</code>作为<code>对象监视器</code>，可以得出以下3个结论：</p>
<ol>
<li>多个线程同时执行<code>synchronized(x)</code>代码块时呈同步效果</li>
<li>其他线程执行<code>x</code>对象中的<code>synchronized</code>同步方法时呈同步效果</li>
<li>其他线程执行<code>x</code>对象中的<code>synchronized(this)</code>代码块时呈同步效果 （2、3点是<code>x</code>对象中本身还有相关的同步方法）</li>
</ol>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncLockObjInsideSyncMethod.java" target="_blank" rel="noopener">SyncLockObjInsideSyncMethod.java</a></p>
<h4 id="2-2-9-静态同步synchronized方法与synchronized-class-代码块"><a href="#2-2-9-静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="2.2.9 静态同步synchronized方法与synchronized(class)代码块"></a>2.2.9 静态同步synchronized方法与synchronized(class)代码块</h4><p><code>synchronized</code>可以应用在<code>static</code>静态方法上，这样表示对当前的<code>XX.java</code>文件对应的<code>Class</code>类进行持锁，等同于<code>synchronized(XX.class)</code>，会从<code>class</code>级别全局阻塞<code>class</code>锁，但不会阻塞实例的同步方法（非静态同步方法）。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncStaticMethod.java" target="_blank" rel="noopener">SyncStaticMethod.java</a></p>
<h4 id="2-2-10-数据类型String的常量池特性"><a href="#2-2-10-数据类型String的常量池特性" class="headerlink" title="2.2.10 数据类型String的常量池特性"></a>2.2.10 数据类型String的常量池特性</h4><p><code>JVM</code>具有<code>String</code>常量池缓存的功能，所以使用<code>String</code>作为监控锁对象不小心时可能会带来一些意外。所以一般<code>synchronized</code>代码块不使用<code>String</code>,改用其他如<code>new Object()</code>。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/StringConstantTrait.java" target="_blank" rel="noopener">StringConstantTrait.java</a></p>
<h4 id="2-2-11-同步sychronized方法无限等待与解决"><a href="#2-2-11-同步sychronized方法无限等待与解决" class="headerlink" title="2.2.11 同步sychronized方法无限等待与解决"></a>2.2.11 同步sychronized方法无限等待与解决</h4><p>同步方法容易造成死循环，让其他线程得不到运行机会。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoStop.java" target="_blank" rel="noopener">TwoStop.java</a></p>
<p>这个其实还得与具体的业务分析，不同的同步方法，是否涉及同一个资源访问的读写，如果不涉及则可以使用不同的”监控锁对象”（以上举例的测试类，在真正的业务场景中基本不会这样）</p>
<p>比如按业务不同，定义不同的锁对象，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoStopMultiLockObj.java" target="_blank" rel="noopener">TwoStopMultiLockObj.java</a></p>
<h4 id="2-2-12-多线程的死锁"><a href="#2-2-12-多线程的死锁" class="headerlink" title="2.2.12 多线程的死锁"></a>2.2.12 多线程的死锁</h4><p><code>java</code>线程死锁是一个经典的问题，造成的原因是不同的线程在等待不可能被释放的锁。</p>
<p>这里我自己脑补了一个来帮助理解死锁的例子:</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/DeadLockTest.java" target="_blank" rel="noopener">DeadLockTest.java</a></p>
<p>死锁是因为<code>阿毛</code>：<code>先锁坑位，再锁纸</code>不走寻常人的路，<code>阿毛他爹</code>、<code>阿毛麻麻</code>是：<code>先锁纸，再锁坑位</code>，导致<code>阿毛全家</code>都不能正常上厕所了。 如果注释掉<code>阿毛</code>，其他人都能正常排队的上厕所，反之注释掉其他人，<code>阿毛</code>一个人也玩的转，他们同时来就会发生死锁。</p>
<p>避免死锁：<strong>对多个资源(数据库表、对象)同时加锁时，需要保持一致的加锁顺序</strong></p>
<p>运行程序后可以看到应用<code>假死</code>了，这是我们可以用<code>jps</code> 查看下运行的<code>java</code>进程的信息，得到<code>pid</code>，然后使用 <code>jstack -l pid</code>，可以看出<code>线程</code>在等待哪个对象的锁，而这把锁现在正被哪个线程锁持有，可以看出这里的死锁就是两个线程互相持有了对方等待的锁。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps </span></span><br><span class="line">    -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</span><br><span class="line">    -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</span><br><span class="line">    -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</span><br><span class="line">    -v : 详细信息</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> jstack</span></span><br><span class="line">    -l</span><br></pre></td></tr></table></figure>
<h4 id="2-2-13-内置类与静态内置类"><a href="#2-2-13-内置类与静态内置类" class="headerlink" title="2.2.13 内置类与静态内置类"></a>2.2.13 内置类与静态内置类</h4><p>内部类依赖其外部类实例来实例化：<code>new External().new InnerClass()</code>， 静态内部类则可以直接：<code>new InnerStaticClass()</code>，实例化时不依赖外部类实例</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ExternalClass.java" target="_blank" rel="noopener">ExternalClass.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunTestExternalClass.java" target="_blank" rel="noopener">RunTestExternalClass.java</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 内部类， 把类比喻成一个鸡蛋，内部类是蛋黄，外部类是蛋壳</span><br><span class="line">// 普通内部类(非static) 那相当于生鸡蛋，没有鸡蛋壳（外部类没有实例化），蛋黄也就不复存在 ----- 生鸡蛋： 壳之不存，黄之焉附</span><br><span class="line">// 内部静态类 , 相当于熟鸡蛋，没有鸡蛋壳，蛋黄也可以是完好的（可以实例化）， -----  熟鸡蛋：唇亡齿寒 ，照样可以嚼东西（没有蛋壳，蛋黄可以用来做卤蛋呀...）</span><br><span class="line"></span><br><span class="line">// 内部类没有 `public`标识时，只有在同一个包的其他类可访问、实例化</span><br></pre></td></tr></table></figure>
<h4 id="2-2-14-内置类与同步：实验1"><a href="#2-2-14-内置类与同步：实验1" class="headerlink" title="2.2.14 内置类与同步：实验1"></a>2.2.14 内置类与同步：实验1</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/OutClzSyncTest.java" target="_blank" rel="noopener">OutClzSyncTest.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunOutClzSyncTest.java" target="_blank" rel="noopener">RunOutClzSyncTest.java</a></p>
<p>这里很好理解，由于<code>method1</code>与<code>method2</code>持有不同的“对象监视器”，所以他们是异步非阻塞，打印结果是乱序的。</p>
<h4 id="2-2-15-内置类与同步：实验2"><a href="#2-2-15-内置类与同步：实验2" class="headerlink" title="2.2.15 内置类与同步：实验2"></a>2.2.15 内置类与同步：实验2</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/OutClzSyncTest2.java" target="_blank" rel="noopener">OutClzSyncTest2.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunOutClzSyncTest2.java" target="_blank" rel="noopener">RunOutClzSyncTest2.java</a></p>
<p>这里用我们上面学到知识就可以理解了，A1、A2 使用了不同锁，非阻塞异步执行，A1、B1争抢一把锁，A1释放锁后B1才可拿锁执行。</p>
<h4 id="2-2-16-锁对象的改变"><a href="#2-2-16-锁对象的改变" class="headerlink" title="2.2.16 锁对象的改变"></a>2.2.16 锁对象的改变</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ChangeLockString.java" target="_blank" rel="noopener">ChangeLockString.java</a></p>
<p>从测试类发现：A、B线程锁对象<code>lock</code>，就算值发生了改变，他们持有的锁都是“123”，还是起到了同步的效果，C、D线程进一步验证了只要对象不变，即使对象的属性被改变，其运行结果还是同步的。</p>
<h3 id="2-3-volatile-关键字"><a href="#2-3-volatile-关键字" class="headerlink" title="2.3 volatile 关键字"></a>2.3 volatile 关键字</h3><p><code>volatile</code>关键字的主要作用是使变量在多个线程间可见。强制从<strong>公共堆栈</strong>中取得变量值，而不是从<strong>线程私有数据</strong>取得变量的值</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/VolatileCompare.java" target="_blank" rel="noopener">VolatileCompare.java</a></p>
<p>测试类输出结果可以看出，没有<code>volatile</code>标识的变量，<code>threadA</code>根本不理会主线程对这个变量的修改，线程会一直运行；而依赖<code>volatile</code>修饰变量运行的线程，可以得到主线程的修改，线程得以正常退出。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fecy1qtlzuj20aq06igll.jpg" alt="-server为了线程效率，从私有堆栈中取值"></p>
<p><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fecy1qe6l5j206w056jrc.jpg" alt="volate强制从公共堆栈中取值"></p>
<h4 id="2-3-1-关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行"><a href="#2-3-1-关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行" class="headerlink" title="2.3.1 关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行"></a>2.3.1 关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行</h4><h4 id="2-3-2-解决同步死循环–-多线程解决，新启线程来设置停止标识"><a href="#2-3-2-解决同步死循环–-多线程解决，新启线程来设置停止标识" class="headerlink" title="2.3.2 解决同步死循环–(多线程解决，新启线程来设置停止标识)"></a>2.3.2 解决同步死循环–(多线程解决，新启线程来设置停止标识)</h4><h4 id="2-3-3-解决异步死循环–-server-不读取主堆栈问题，使用volatile解决，强制读主堆栈内存"><a href="#2-3-3-解决异步死循环–-server-不读取主堆栈问题，使用volatile解决，强制读主堆栈内存" class="headerlink" title="2.3.3 解决异步死循环–(-server 不读取主堆栈问题，使用volatile解决，强制读主堆栈内存)"></a>2.3.3 解决异步死循环–(-server 不读取主堆栈问题，使用volatile解决，强制读主堆栈内存)</h4><h4 id="2-3-4-volatile-非原子的特性"><a href="#2-3-4-volatile-非原子的特性" class="headerlink" title="2.3.4 volatile 非原子的特性"></a>2.3.4 volatile 非原子的特性</h4><p>虽然<code>volatile</code>虽然实现了共享资源在多个线程间的可见性，但它却不具备同步性，那么也就不具备原子性(个人理解：变量本身没有原子性，对变量的操作才有原子性一说)。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/CounterVolatileUnsafe.java" target="_blank" rel="noopener">CounterVolatileUnsafe.java</a></p>
<p><code>volatile</code>只是增加了多线程间共享资源的透明度，上面的执行结果有可能出现的是你的期望值<code>10000</code>，这只是提高了他出现的几率，这也体现了线程安全问题的难以测试和问题偶发性。</p>
<h4 id="2-3-5-使用原子类进行i-操作"><a href="#2-3-5-使用原子类进行i-操作" class="headerlink" title="2.3.5 使用原子类进行i++ 操作"></a>2.3.5 使用原子类进行i++ 操作</h4><p>从jdk1.5起开始提供了<code>AtomicXX</code>的一些原子类，这些类是乐观锁的一种CAS(Compare And Swap)的实现，其利用JNI调用CPU指令实现。</p>
<p>主要提供了：<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>供基础数据类型的操作，<code>AtomicReference&lt;V&gt;</code>对象数据操作，<code>AtomicStampedRefrence&lt;V&gt;</code>来操作对象并解决<code>ABA</code>的问题</p>
<p><code>AtomicInteger</code>完成i++, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/AtomicIntegerTest.java" target="_blank" rel="noopener">AtomicIntegerTest.java</a><br><code>AtomicReference&lt;V&gt;</code>模拟栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/stackAtomVsSync/AtomicStack.java" target="_blank" rel="noopener">AtomicStack.java</a><br><code>AtomicStampedRefrence&lt;V&gt;</code>解决ABA问题，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/CAS/ABA.java" target="_blank" rel="noopener">ABA.java</a></p>
<h4 id="2-3-6-原子类也并不完全安全"><a href="#2-3-6-原子类也并不完全安全" class="headerlink" title="2.3.6 原子类也并不完全安全"></a>2.3.6 原子类也并不完全安全</h4><p>这里其实主要说明的是多个原子类方法间是不安全的，单个原子类方法没有问题。</p>
<h4 id="2-3-7-synchronized-代码块有volatile同步的功能"><a href="#2-3-7-synchronized-代码块有volatile同步的功能" class="headerlink" title="2.3.7 synchronized 代码块有volatile同步的功能"></a>2.3.7 synchronized 代码块有volatile同步的功能</h4><p>关键字<code>synchronized</code>可以使多个线程访问同一个资源具有同步性，而且还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Skills:</p>
<ul>
<li>使用<code>wait/notify</code> 实现线程间的通信</li>
<li>生产者/消费者模式的实现</li>
<li>方法<code>join</code>的使用</li>
<li><code>ThreadLocal</code>的使用</li>
</ul>
<h3 id="3-1-等待-通知机制"><a href="#3-1-等待-通知机制" class="headerlink" title="3.1 等待/通知机制"></a>3.1 等待/通知机制</h3><p>线程与线程之间不是独立的个体，他们彼此之间可以互相通信和协作。</p>
<h4 id="3-1-1-不使用等待-通知机制实现线程间通信"><a href="#3-1-1-不使用等待-通知机制实现线程间通信" class="headerlink" title="3.1.1 不使用等待/通知机制实现线程间通信"></a>3.1.1 不使用等待/通知机制实现线程间通信</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoThreadTransData.java" target="_blank" rel="noopener">TwoThreadTransData.java</a></p>
<p>线程<code>thread-b</code>循环中不断检测一个条件，轮循时间小，会造成浪费CPU资源，轮循间隔大时，响应不会实时。 所以要出现了<code>wait/notify</code>机制。</p>
<h4 id="3-1-2-什么是等待-通知机制"><a href="#3-1-2-什么是等待-通知机制" class="headerlink" title="3.1.2 什么是等待/通知机制"></a>3.1.2 什么是等待/通知机制</h4><p>比如：<code>厨师</code>完成一道菜的时间不确定，<code>服务员</code>需要将这道菜，送给就餐者。</p>
<p>如果不是“等待/通知”机制：<code>服务员</code>不断的询问<code>厨师</code>菜完成了没…</p>
<p>有了“等待/通知”机制择时：<code>服务员</code>坐等(wait)，<code>厨师</code>完成菜品即告诉(notify)<code>服务员</code>。</p>
<h4 id="3-1-3-等待-通知机制的实现"><a href="#3-1-3-等待-通知机制的实现" class="headerlink" title="3.1.3 等待/通知机制的实现"></a>3.1.3 等待/通知机制的实现</h4><p><strong><code>wait</code>使线程暂停执行，而<code>notify</code>唤醒其他线程继续执行</strong></p>
<p><code>wait()</code>方法使当前执行代码的线程进行等待，<code>wait()</code>方法是<code>Object</code>类的方法，该方法将当前线程置入“预执行队列中”，并且在<code>wait()</code>所在代码处停止，直到接到通知或被中断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用`wait()`方法前必须获得该对象实例的锁，即只能再锁对象实例的同步代码内中调用`wait()`方法，否则将抛出`IllegalMonitorStateException`，`wait()`方法后，当前线程释放该对象实例的锁。</span><br></pre></td></tr></table></figure></p>
<p><code>notify()</code>方法也需要或得对象实例的锁，该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则有线程规划器随机挑出一个呈<code>wait</code>状态的线程，对其发出通知notify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行`notify()`方法后，当前线程不会马上释放该对象的锁，呈wait状态的锁不会马上获得锁，而是要等执行`notify()`方法所在同步块执行完。</span><br></pre></td></tr></table></figure></p>
<p>简单体现<code>wait/notify</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TestWaitNotify.java" target="_blank" rel="noopener">TestWaitNotify.java</a></p>
<p>实现之前提到的<code>当公共变量==5时退出一个线程</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitNotifyWhen5.java" target="_blank" rel="noopener">WaitNotifyWhen5.java</a></p>
<p><strong>`运行–就绪–等待</strong>  （用单核cpu的方式去立即：同一时刻只有一个线程被执行，所以有了就绪队列）`:<br><strong>每个锁对象都有两个队列，一个是就绪队列(竞争锁)，一个是阻塞队列(wait待唤醒)。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒</strong></p>
<p>关于<code>就绪队列</code>与<code>阻塞队列</code>顺序相关</p>
<ol>
<li>就绪队列，进入方法的顺序与竞争得到锁的顺序，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/CompeteOrder.java" target="_blank" rel="noopener">CompeteOrder.java</a></li>
<li>阻塞队列，wait触发的顺序与被唤醒的顺序，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitOrder.java" target="_blank" rel="noopener">WaitOrder.java</a></li>
</ol>
<h4 id="3-1-4-方法wait-锁释放与notify-方法锁不释放"><a href="#3-1-4-方法wait-锁释放与notify-方法锁不释放" class="headerlink" title="3.1.4 方法wait()锁释放与notify()方法锁不释放"></a>3.1.4 方法wait()锁释放与notify()方法锁不释放</h4><p>当方法<code>wait()</code>被执行后，锁自动释放，但执行完<code>notify()</code>方法，锁是不自动释放的，还有在同步代码块内<code>sleep()</code>方法也是不会释放锁的。 这些其实在上面的例子中都已经有体现了。</p>
<h4 id="3-1-5-当interrup方法遇到wait方法"><a href="#3-1-5-当interrup方法遇到wait方法" class="headerlink" title="3.1.5 当interrup方法遇到wait方法"></a>3.1.5 当interrup方法遇到wait方法</h4><p>当线程呈<code>wait</code>状态时，调用线程对象的<code>interrupt()</code>方法会出现<code>InterruptedException</code>异常。</p>
<h4 id="3-1-6-只通知一个线程"><a href="#3-1-6-只通知一个线程" class="headerlink" title="3.1.6 只通知一个线程"></a>3.1.6 只通知一个线程</h4><p>调用<code>notify()</code>方法一次只<del>随机</del>(wait队列poll出一个)通知一个线程进行唤醒。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/NotifyOne.java" target="_blank" rel="noopener">NotifyOne.java</a></p>
<h4 id="3-1-7-唤醒所有线程"><a href="#3-1-7-唤醒所有线程" class="headerlink" title="3.1.7 唤醒所有线程"></a>3.1.7 唤醒所有线程</h4><p>调用<code>notifyAll()</code>方法将唤醒wait队列中的所有线程。</p>
<h4 id="3-1-8-方法wait-long-的使用"><a href="#3-1-8-方法wait-long-的使用" class="headerlink" title="3.1.8 方法wait(long)的使用"></a>3.1.8 方法wait(long)的使用</h4><p>带一个参数<code>wait(long)</code>方法的功能是等待指定的时间，如果指定时间内没有被<code>notify</code>将自动苏醒。</p>
<p>无人唤醒，自动苏醒，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitHasParamMethod.java" target="_blank" rel="noopener">WaitHasParamMethod.java</a></p>
<h4 id="3-1-9-通知过早"><a href="#3-1-9-通知过早" class="headerlink" title="3.1.9 通知过早"></a>3.1.9 通知过早</h4><p>“服务员”还没过来等待，“厨师”做完菜就发出了通知。也就是 一个线程notify 发生在另外一个线程wait之前。解决这种问题是在调用wait方法前判断，如果先通知了，则wait方法就没必要执行了。</p>
<h4 id="3-1-10-等待wait的条件发生变化"><a href="#3-1-10-等待wait的条件发生变化" class="headerlink" title="3.1.10 等待wait的条件发生变化"></a>3.1.10 等待wait的条件发生变化</h4><p>要注意wait所依赖的条件变化，多个线程在wait，有可能条件检验已经过期，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitOld.java" target="_blank" rel="noopener">WaitOld.java</a></p>
<h4 id="3-1-11-生产者-消费者模式实现"><a href="#3-1-11-生产者-消费者模式实现" class="headerlink" title="3.1.11 生产者/消费者模式实现"></a>3.1.11 生产者/消费者模式实现</h4><p><code>生产者消费者：互相通知，互相等待</code></p>
<ol>
<li>一生产者与一消费者：操作值，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerTest.java" target="_blank" rel="noopener">ProducerConsumerTest.java</a></li>
<li>多生产者与多消费：操作值-假死，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerAllWait.java" target="_blank" rel="noopener">ProducerConsumerAllWait.java</a></li>
<li>多生产者与多消费：操作值，将上面中的<code>notify</code>改为<code>notifyAll</code>，唤醒所有。</li>
<li>一生产与一消费：操作栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerStack.java" target="_blank" rel="noopener">ProducerConsumerStack.java</a></li>
<li>一生产与多消费：操作栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerMulConsumerStack.java" target="_blank" rel="noopener">ProducerMulConsumerStack.java</a></li>
</ol>
<h4 id="3-1-12-通过管道进行线程间通信：字节流"><a href="#3-1-12-通过管道进行线程间通信：字节流" class="headerlink" title="3.1.12 通过管道进行线程间通信：字节流"></a>3.1.12 通过管道进行线程间通信：字节流</h4><p><code>Java</code>语言中提供了各种各样的<code>输入/输出</code> 流<code>Stream</code>，能方便的对数据进行操作，其中<code>管道流</code>(<code>pipeStream</code>)是一种特殊的流，用于在不同线程间直接传送数据。</p>
<p>字节流通信，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PipedInputOutput.java" target="_blank" rel="noopener">PipedInputOutput.java</a></p>
<h4 id="3-1-13-通过管道进行线程间通信：字符流"><a href="#3-1-13-通过管道进行线程间通信：字符流" class="headerlink" title="3.1.13 通过管道进行线程间通信：字符流"></a>3.1.13 通过管道进行线程间通信：字符流</h4><p>字符流通信，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PipedReaderWriter.java" target="_blank" rel="noopener">PipedReaderWriter.java</a></p>
<h4 id="3-1-14-实战：等待-通知之交叉备份"><a href="#3-1-14-实战：等待-通知之交叉备份" class="headerlink" title="3.1.14 实战：等待/通知之交叉备份"></a>3.1.14 实战：等待/通知之交叉备份</h4><p>创建20个线程，其中10个线程将数据备份至A数据库，另外10个线程将数据备份至B数据库，并且备份A数据库和备份B数据库交叉进行。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitNotifyInsert.java" target="_blank" rel="noopener">WaitNotifyInsert.java</a></p>
<h3 id="3-2-方法join的使用"><a href="#3-2-方法join的使用" class="headerlink" title="3.2 方法join的使用"></a>3.2 方法join的使用</h3><p>在很多情况下，主线程创建并启动子线程，如果子线程耗时较久，主线程往往将早于子线程结束。这这时如果主线程想等待子线程完成之后做操作，就可以使用<code>join()</code>方法了。</p>
<h4 id="3-2-1-学习方法join前的铺垫"><a href="#3-2-1-学习方法join前的铺垫" class="headerlink" title="3.2.1 学习方法join前的铺垫"></a>3.2.1 学习方法join前的铺垫</h4><p>比如我们需要 T1、T2、T3 三个线程按先后顺序执行，没有join方法可以尝试这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1.start();  T1.sleep(xxx);</span><br><span class="line">T2.start();  T2.sleep(xxx);</span><br><span class="line">T3.start();</span><br></pre></td></tr></table></figure></p>
<p>问题就在于 上面的xxx时间我们无法确定，因为每个线程运行多久我们不能确定， 设值长了，程序会浪费等待时间，设值短了，可能出现顺序不对。</p>
<h4 id="3-2-2-用join方法解决"><a href="#3-2-2-用join方法解决" class="headerlink" title="3.2.2 用join方法解决"></a>3.2.2 用join方法解决</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1.start();  T1.join();</span><br><span class="line">T2.start();  T2.join();</span><br><span class="line">T3.start();</span><br></pre></td></tr></table></figure>
<p>这样就能保证三个线程依次执行了。</p>
<p>另外注意：<strong>如果<code>T1</code>内部启动了新的线程，<code>T1.join()</code>方法后面的代码不会等待<code>T1</code>新启的线程</strong></p>
<h4 id="3-2-3-方法join与异常"><a href="#3-2-3-方法join与异常" class="headerlink" title="3.2.3 方法join与异常"></a>3.2.3 方法join与异常</h4><h4 id="3-2-4-方法join-long-的使用"><a href="#3-2-4-方法join-long-的使用" class="headerlink" title="3.2.4 方法join(long)的使用"></a>3.2.4 方法join(long)的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">childThread.join(<span class="number">1000</span>); <span class="comment">//执行这个方法所在的线程最多等待 1000ms，</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个方法会无论如何等待 1000ms</span></span><br><span class="line">如果子线程执行的时间超过<span class="number">1000</span>ms，那么他们所看起来的效果是一致的。</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-方法-join-long-与-sleep-long-的异同"><a href="#3-2-5-方法-join-long-与-sleep-long-的异同" class="headerlink" title="3.2.5 方法 join(long) 与 sleep(long)的异同"></a>3.2.5 方法 join(long) 与 sleep(long)的异同</h4><p><code>join(long)</code>方法内部是使用<code>wait(long)</code>实现的，所以<code>join(long)</code>方法也具有释放锁的特点， 而<code>sleep(long)</code>方法不会释放锁。</p>
<p>相同：</p>
<ol>
<li>调用<code>sleep</code>与<code>join</code>方法来达到阻塞当前线程的目的</li>
</ol>
<p>不同：</p>
<ol>
<li><code>sleep(long)</code>为<code>Thread类static</code>方法，<code>join(long)</code>为<code>Thread实例的方法</code>，故需要注意他们作用于的线程区别</li>
<li>作用于普通的非同步方法中区别就是：<code>sleep(long)</code>等待固定时间、<code>join(long)</code>最多等待这么久的时间</li>
</ol>
<p>具体深入对比可以查看: <a href="http://blog.ouronghui.com/2017/03/23/Thread%E7%B1%BBjoin%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%20wait(0">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a>%20%E8%83%BD%E7%94%A8%20sleep(0)%20%E6%9D%A5%E6%9B%BF%E4%BB%A3%E6%A8%A1%E6%8B%9F%E5%90%97/)</p>
<h3 id="3-3-类ThreadLocal的使用"><a href="#3-3-类ThreadLocal的使用" class="headerlink" title="3.3 类ThreadLocal的使用"></a>3.3 类ThreadLocal的使用</h3><p>类变量的共享可以采用<code>public static</code>形式，所有线程都使用同一个<code>public static</code>变量。 如果想要实现每个线程都有自己的共享变量呢？ <code>JDK</code>提供的类<code>ThreadLocal</code>正是为了解决这个问题的。</p>
<ul>
<li>局部变量：方法内，不同享，与实例和线程都无关。</li>
<li>全局变量：类内，共享实例变量，在不同的线程、或方法间达到共享</li>
<li>全局静态：类内，共享静态变量，不同线程间访问达到共享，<code>静态</code>与实例无关。</li>
</ul>
<h4 id="3-3-1-方法-get-与-null"><a href="#3-3-1-方法-get-与-null" class="headerlink" title="3.3.1 方法 get() 与 null"></a>3.3.1 方法 get() 与 null</h4><h4 id="3-3-2-验证变量的隔离性"><a href="#3-3-2-验证变量的隔离性" class="headerlink" title="3.3.2 验证变量的隔离性"></a>3.3.2 验证变量的隔离性</h4><h4 id="3-3-3-解决-get-返回-null问题"><a href="#3-3-3-解决-get-返回-null问题" class="headerlink" title="3.3.3 解决 get() 返回 null问题"></a>3.3.3 解决 get() 返回 null问题</h4><h4 id="3-3-4-再次验证线程变量的隔离性"><a href="#3-3-4-再次验证线程变量的隔离性" class="headerlink" title="3.3.4 再次验证线程变量的隔离性"></a>3.3.4 再次验证线程变量的隔离性</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/VerifyIsolation.java" target="_blank" rel="noopener">VerifyIsolation.java</a></p>
<h3 id="3-4-类-InheritableThreadLocal-的使用"><a href="#3-4-类-InheritableThreadLocal-的使用" class="headerlink" title="3.4 类 InheritableThreadLocal 的使用"></a>3.4 类 InheritableThreadLocal 的使用</h3><p>使用<code>InheritableThreadLocal</code>可以在子线程取得父线程继承下来的值。</p>
<h4 id="3-4-1-值继承"><a href="#3-4-1-值继承" class="headerlink" title="3.4.1 值继承"></a>3.4.1 值继承</h4><h4 id="3-4-2-值继承再修改"><a href="#3-4-2-值继承再修改" class="headerlink" title="3.4.2 值继承再修改"></a>3.4.2 值继承再修改</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/InheritableThreadLocalTest.java" target="_blank" rel="noopener">InheritableThreadLocalTest.java</a></p>
<h2 id="4-Lock的使用"><a href="#4-Lock的使用" class="headerlink" title="4. Lock的使用"></a>4. Lock的使用</h2><p>Skills:</p>
<ul>
<li><code>ReentrantLock</code>类的使用</li>
<li><code>ReentrantReadWriteLock</code>类的使用</li>
</ul>
<h3 id="4-1-使用-ReentrantLock类"><a href="#4-1-使用-ReentrantLock类" class="headerlink" title="4.1 使用 ReentrantLock类"></a>4.1 使用 ReentrantLock类</h3><p>在<code>java</code>多线程中，可以使用<code>synchronized</code>关键字来实现线程之间同步互斥，但在<code>jdk1.5</code>中新增了<code>ReentrantLock</code>类也能达到同样的效果，并且在扩展功能上也更加强大，比如有嗅探锁定、多路分支通知等功能，使用上比<code>synchronized</code>更加灵活。</p>
<h4 id="4-1-1-使用-ReentrantLock类实现同步"><a href="#4-1-1-使用-ReentrantLock类实现同步" class="headerlink" title="4.1.1 使用 ReentrantLock类实现同步"></a>4.1.1 使用 ReentrantLock类实现同步</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReentrantLockTest.java" target="_blank" rel="noopener">ReentrantLockTest.java</a></p>
<h4 id="4-1-2-使用-ReentrantLock类实现同步-测试2"><a href="#4-1-2-使用-ReentrantLock类实现同步-测试2" class="headerlink" title="4.1.2 使用 ReentrantLock类实现同步: 测试2"></a>4.1.2 使用 ReentrantLock类实现同步: 测试2</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReentrantLockTest2.java" target="_blank" rel="noopener">ReentrantLockTest2.java</a></p>
<h4 id="4-1-3-使用Condition-实现等待-通知：错误用法与解决"><a href="#4-1-3-使用Condition-实现等待-通知：错误用法与解决" class="headerlink" title="4.1.3 使用Condition 实现等待/通知：错误用法与解决"></a>4.1.3 使用Condition 实现等待/通知：错误用法与解决</h4><p>关键字 <code>synchronized</code>与<code>wait()</code>和<code>notify()/notifyAll()</code>方法结合可以实现等待/通知模式，类<code>ReentrantLock</code>实现同样的功能是借助于<code>Condition</code>对象。<code>Condition</code>是JDK5中出现的技术，使用它有更好的灵活性，比如实现多路通知的功能，也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>对象实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/UseConditionWaitNotifyError.java" target="_blank" rel="noopener">UseConditionWaitNotifyError.java</a></p>
<h4 id="4-1-4-正确使用Condition实现等待-通知"><a href="#4-1-4-正确使用Condition实现等待-通知" class="headerlink" title="4.1.4 正确使用Condition实现等待/通知"></a>4.1.4 正确使用Condition实现等待/通知</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/UseConditionWaitNotifyOK.java" target="_blank" rel="noopener">UseConditionWaitNotifyOK.java</a></p>
<p>成功的实现了等待/通知模式。</p>
<ul>
<li><code>Object</code>类中的<code>wait()</code>相当于<code>Condition</code>类中的<code>await()</code>方法， 线程进入<code>WAITING</code>状态。</li>
<li><code>Object</code>类中的<code>wait(long timeout)</code>相当于<code>Condition</code>类中的<code>await(long time, TimeUnit unit)</code>方法， 线程进入<code>TIMED_WAITING</code>状态。</li>
<li><code>Object</code>类中的<code>notify()</code>相当于<code>Condition</code>类中的<code>signal()</code>方法</li>
<li><code>Object</code>类中的<code>notifyAll()</code>相当于<code>Condition</code>类中的<code>signalAll()</code>方法</li>
</ul>
<h4 id="4-1-5-使用Condition实现通知部分线程：错误用法"><a href="#4-1-5-使用Condition实现通知部分线程：错误用法" class="headerlink" title="4.1.5 使用Condition实现通知部分线程：错误用法"></a>4.1.5 使用Condition实现通知部分线程：错误用法</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/MustUseMoreConditionError.java" target="_blank" rel="noopener">MustUseMoreConditionError.java</a></p>
<p>两个方法共用一个<code>Condition</code>，不能体现区别唤醒，<code>thread-A</code>、<code>thread-B</code>两个线程启动分别调用了同一个<code>condition</code>的<code>await()</code>方法，线程都进入了<code>WAITING</code>状态，最后主线程同时唤醒的是两个线程。</p>
<h4 id="4-1-6-使用多个Condition实现通知部分线程：正确用法"><a href="#4-1-6-使用多个Condition实现通知部分线程：正确用法" class="headerlink" title="4.1.6 使用多个Condition实现通知部分线程：正确用法"></a>4.1.6 使用多个Condition实现通知部分线程：正确用法</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/MustUseMoreConditionOK.java" target="_blank" rel="noopener">MustUseMoreConditionOK.java</a></p>
<p>此时两个方法分别使用了<code>conditionA</code>、<code>conditionB</code>，主线程调用了<code>conditoinA.signalAll()</code>达到了只唤醒<code>thread-A</code>的效果，<code>thread-B</code>继续<code>WAITING</code></p>
<h4 id="4-1-7-实现生产者-消费者：一对一交替打印"><a href="#4-1-7-实现生产者-消费者：一对一交替打印" class="headerlink" title="4.1.7 实现生产者/消费者：一对一交替打印"></a>4.1.7 实现生产者/消费者：一对一交替打印</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionTest.java" target="_blank" rel="noopener">ConditionTest.java</a></p>
<h4 id="4-1-8-实现生产者-消费者：多对多交替打印"><a href="#4-1-8-实现生产者-消费者：多对多交替打印" class="headerlink" title="4.1.8 实现生产者/消费者：多对多交替打印"></a>4.1.8 实现生产者/消费者：多对多交替打印</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionTestManyToMany.java" target="_blank" rel="noopener">ConditionTestManyToMany.java</a></p>
<p>类似<code>Object</code>的<code>notify()</code>方法，<code>signal()</code>方法同样也会造成假死的现象，这是因为<code>生产者</code>与<code>消费者</code>使用的是同一个<code>Condition</code>，<code>signal()</code>方法在我们期望通知<code>消费者</code>时，可能通知到的是<code>另一个消费者</code>，反之消费者发出的通知也是一样的。所以这里也采取了<code>signalAll()</code>方法发出信号一并唤醒。</p>
<h4 id="4-1-9-公平锁与非公平锁"><a href="#4-1-9-公平锁与非公平锁" class="headerlink" title="4.1.9 公平锁与非公平锁"></a>4.1.9 公平锁与非公平锁</h4><p>公平与非公平锁：锁<code>Lock</code>分为<code>公平锁</code>和<code>非公平锁</code>, 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的<code>FIFO</code>先进先出的顺序。 而非公平锁就是一种获取锁的抢占机制，是随机获得锁的。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/FairNoFairTest.java" target="_blank" rel="noopener">FairNoFairTest.java</a></p>
<ul>
<li>公平锁 ，开始运行与得锁顺序呈有序</li>
<li>非公平锁， 开始运行与得锁顺序基本上是乱序的</li>
</ul>
<h4 id="4-1-10-方法getHoldCount-、getQueueLength-、getWaitQueueLength"><a href="#4-1-10-方法getHoldCount-、getQueueLength-、getWaitQueueLength" class="headerlink" title="4.1.10 方法getHoldCount()、getQueueLength()、getWaitQueueLength()"></a>4.1.10 方法getHoldCount()、getQueueLength()、getWaitQueueLength()</h4><ul>
<li><code>int getHoldCount()</code> 方法是<strong>查询当前线程保持此锁的个数</strong>，也就是调用 <code>lock()</code>方法的次数。测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHoldCount.java" target="_blank" rel="noopener">LockMethodHoldCount.java</a></li>
<li><code>int getQueueLength()</code> 方法是返回<strong>等待获取此锁的线程估计数</strong> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodQueueLength.java" target="_blank" rel="noopener">LockMethodQueueLength.java</a></li>
<li><code>int getWaitQueueLength(Condition condition)</code> 方法是返回<strong>等待此锁相关条件Condition的线程估计数</strong> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodWaitQueueLength.java" target="_blank" rel="noopener">LockMethodWaitQueueLength.java</a></li>
</ul>
<p>这里的体现其实与之前<code>synchronized</code>内部锁达一致：锁的两个队列，getQueueLength() 取的是针对此锁 在<code>BLOCKED</code> 就绪阻塞线程，<code>getWaitQueueLength(Condition condition)</code> 则是<code>WAITING</code>睡眠等待唤醒的线程</p>
<h4 id="4-1-11-方法-hasQueuedThread-、hasQueuedThreads-和-hasWaiters-的测试"><a href="#4-1-11-方法-hasQueuedThread-、hasQueuedThreads-和-hasWaiters-的测试" class="headerlink" title="4.1.11 方法 hasQueuedThread()、hasQueuedThreads() 和 hasWaiters()的测试"></a>4.1.11 方法 hasQueuedThread()、hasQueuedThreads() 和 hasWaiters()的测试</h4><ul>
<li><code>boolean hasQueuedThread(Thread thread)</code> 查询指定的线程是否等待获取此锁。</li>
<li><code>boolean hasQueuedThreads()</code> 查询是否有线程正在等待获取此锁。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHasQueued.java" target="_blank" rel="noopener">LockMethodHasQueued.java</a></p>
<ul>
<li><code>boolean hasWaiters(Condition condition)</code> 查询是否有线程正在等待此锁有关的<code>condition</code>条件,测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHasWaiters.java" target="_blank" rel="noopener">LockMethodHasWaiters.java</a></li>
</ul>
<h4 id="4-1-12-方法-isFair-、isHeldByCurrentThread-和-isLocked-的测试"><a href="#4-1-12-方法-isFair-、isHeldByCurrentThread-和-isLocked-的测试" class="headerlink" title="4.1.12 方法 isFair()、isHeldByCurrentThread() 和 isLocked() 的测试"></a>4.1.12 方法 isFair()、isHeldByCurrentThread() 和 isLocked() 的测试</h4><ul>
<li><code>boolean isFair()</code> 判断锁是不是公平锁，默认情况下<code>ReentrantLock</code>是<code>非公平锁</code></li>
<li><code>boolean isHeldByCurrentThread()</code> 查询当前线程是否保持此锁定。</li>
<li><code>boolean isLocked()</code> 查询此锁是否有线程保持锁定。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodIsHeldByCurrentThread.java" target="_blank" rel="noopener">LockMethodIsHeldByCurrentThread.java</a></p>
<h4 id="4-1-13-方法-lockInterruptibly-、tryLock-和-tryLock-long-timeout-TiemUnit-unit-的测试"><a href="#4-1-13-方法-lockInterruptibly-、tryLock-和-tryLock-long-timeout-TiemUnit-unit-的测试" class="headerlink" title="4.1.13 方法 lockInterruptibly()、tryLock() 和 tryLock(long timeout, TiemUnit unit) 的测试"></a>4.1.13 方法 lockInterruptibly()、tryLock() 和 tryLock(long timeout, TiemUnit unit) 的测试</h4><ul>
<li><code>void lockInterruptibly()</code> ：取锁，如果当前线程未被中断，则获取锁定，如果已经被终端则出现异常。测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodInterruptiblyTest.java" target="_blank" rel="noopener">LockMethodInterruptiblyTest.java</a></li>
<li><code>boolean tryLock()</code> : 取锁，尝试取锁，如未取得则返回false。</li>
<li><code>boolean tryLock(long timeout, TimeUnit unit)</code>：取锁，指定时间内如未取得锁，取锁失败返回false</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodTryLock.java" target="_blank" rel="noopener">LockMethodTryLock.java</a></p>
<h4 id="4-1-14-方法-awaitUninterruptibly-的使用"><a href="#4-1-14-方法-awaitUninterruptibly-的使用" class="headerlink" title="4.1.14 方法 awaitUninterruptibly() 的使用"></a>4.1.14 方法 awaitUninterruptibly() 的使用</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodAwaitUninterruptibly.java" target="_blank" rel="noopener">LockMethodAwaitUninterruptibly.java</a></p>
<p><code>awaitUninterruptibly()</code>方法不同于<code>await()</code>，前者将不理会<code>interrupt()</code>动作，继续执行，而<code>await()</code>在线程触发<code>interrupt()</code>动作时将正常抛出异常。</p>
<h4 id="4-1-15-方法-awaitUntil-的使用"><a href="#4-1-15-方法-awaitUntil-的使用" class="headerlink" title="4.1.15 方法 awaitUntil() 的使用"></a>4.1.15 方法 awaitUntil() 的使用</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodAwaitUntil.java" target="_blank" rel="noopener">LockMethodAwaitUntil.java</a></p>
<h4 id="4-1-16-使用-Condition-实现顺序执行"><a href="#4-1-16-使用-Condition-实现顺序执行" class="headerlink" title="4.1.16 使用 Condition 实现顺序执行"></a>4.1.16 使用 Condition 实现顺序执行</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionABC.java" target="_blank" rel="noopener">ConditionABC.java</a></p>
<h3 id="4-2-使用-ReentrantReadWriteLock-类"><a href="#4-2-使用-ReentrantReadWriteLock-类" class="headerlink" title="4.2 使用 ReentrantReadWriteLock 类"></a>4.2 使用 ReentrantReadWriteLock 类</h3><p>类<code>ReentrantLock</code>具有完全互斥排他的效果，即同一时间只有一个线程在执行<code>ReentrantLock.lock()</code>方法后的任务。这样虽然保证了实例变量的线程安全性，但效率确实低下的。所以<code>JDK</code>提供了一种读写锁<code>ReentrantReadWriteLock</code>类，使他可以加快运行效率，在某些不需要操作实例变量的方法中，完全可以使用读写锁<code>ReentrantReadWriteLock</code>来提升该方法的代码运行速度。</p>
<p>读写锁表示有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。</p>
<p>多个读锁之间不互斥，读写与写锁互斥，写锁与写锁互斥。 在没有线程进行写操作时，进行读取操作的多个线程都可以获取读锁，而写操作的线程只有在获取写锁后才能进行写操作。</p>
<p>即多个线程可以同时进行读取操作，但是同一时刻只允许一个线程进行写操作。</p>
<h3 id="4-2-1-类-ReentrantLockReadWriteLock-的使用：读读共享"><a href="#4-2-1-类-ReentrantLockReadWriteLock-的使用：读读共享" class="headerlink" title="4.2.1 类 ReentrantLockReadWriteLock 的使用：读读共享"></a>4.2.1 类 ReentrantLockReadWriteLock 的使用：读读共享</h3><p>可以看出多个线程都获得了读锁<code>readLock</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin1.java" target="_blank" rel="noopener">ReadWriteLockBegin1.java</a></p>
<h3 id="4-2-1-类-ReentrantLockReadWriteLock-的使用：写写互斥"><a href="#4-2-1-类-ReentrantLockReadWriteLock-的使用：写写互斥" class="headerlink" title="4.2.1 类 ReentrantLockReadWriteLock 的使用：写写互斥"></a>4.2.1 类 ReentrantLockReadWriteLock 的使用：写写互斥</h3><p>同意时刻，只有一个线程获得锁，写锁阻塞等待前一个线程释放锁, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin2.java" target="_blank" rel="noopener">ReadWriteLockBegin2.java</a></p>
<h3 id="4-2-3-类-ReentrantLockReadWriteLock-的使用：读写互斥"><a href="#4-2-3-类-ReentrantLockReadWriteLock-的使用：读写互斥" class="headerlink" title="4.2.3 类 ReentrantLockReadWriteLock 的使用：读写互斥"></a>4.2.3 类 ReentrantLockReadWriteLock 的使用：读写互斥</h3><h3 id="4-2-4-类-ReentrantLockReadWriteLock-的使用：写读互斥"><a href="#4-2-4-类-ReentrantLockReadWriteLock-的使用：写读互斥" class="headerlink" title="4.2.4 类 ReentrantLockReadWriteLock 的使用：写读互斥"></a>4.2.4 类 ReentrantLockReadWriteLock 的使用：写读互斥</h3><p><strong>获得读锁未释放，写锁也会被阻塞，获得写锁未释放，读锁也会被阻塞</strong>：测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin3.java" target="_blank" rel="noopener">ReadWriteLockBegin3.java</a></p>
<h3 id="4-3-Lock-本章总结"><a href="#4-3-Lock-本章总结" class="headerlink" title="4.3 Lock 本章总结"></a>4.3 Lock 本章总结</h3><p>完全可以使用<code>Lock</code>对象将<code>synchronized</code>关键字替换掉，而且其具有的功能是<code>synchronized</code>不具有的，<code>Lock</code>是<code>synchronized</code>的进阶。</p>
<h2 id="5-定时器-Timer"><a href="#5-定时器-Timer" class="headerlink" title="5 定时器 Timer"></a>5 定时器 Timer</h2><p>Skills:</p>
<ul>
<li>如何实现指定时间执行任务</li>
<li>如何实现按指定周期执行任务</li>
</ul>
<h3 id="5-1-定时器-Timer-的使用"><a href="#5-1-定时器-Timer-的使用" class="headerlink" title="5.1 定时器 Timer 的使用"></a>5.1 定时器 Timer 的使用</h3><p><code>JDK</code>中<code>Timer</code>类主要负责计划任务的功能，也就是在指定时间开始执行某一任务。<code>Timer</code>的作用是设置计划任务，但是封装任务的类是<code>TimerTask</code>抽象类，所以具体要计划执行的任务继承<code>TimerTask</code>类即可。</p>
<h4 id="5-1-1-方法-schedule-TimeTask-task-Date-time"><a href="#5-1-1-方法-schedule-TimeTask-task-Date-time" class="headerlink" title="5.1.1 方法 schedule(TimeTask task, Date time)"></a>5.1.1 方法 schedule(TimeTask task, Date time)</h4><p>指定的日期的时间执行一次任务。</p>
<ol>
<li>执行任务的时间晚于当前时间：在未来的某个时间点执行 — timer内部的TimerThread 在实例化时start，默认非守护线程，意味任务完成后，即使没有其他线程，程序不会结束，如果设定为守护线程，如果任务运行之前，其他非守护都已经结束，那么有可能任务还未执行，程序就已经结束。</li>
<li><p>计划时间早于当前时间：设定的时间点是已经过去 – 时间点是过去，则会立即执行task任务</p>
<p> 1,2 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest1.java" target="_blank" rel="noopener">TimerTest1.java</a></p>
</li>
<li><p>一个<code>Timer</code>中多个<code>TimerTask</code> 任务及延时的测试 – 以计划执行的时间排队成队列，前者执行完后者再执行，当前者执行时间较长时会阻塞后面队列中的任务。<br> 3 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerMultiTask.java" target="_blank" rel="noopener">TimerMultiTask.java</a></p>
</li>
</ol>
<h4 id="5-1-2-方法-schedule-TimerTask-task-Date-firstTime-long-period"><a href="#5-1-2-方法-schedule-TimerTask-task-Date-firstTime-long-period" class="headerlink" title="5.1.2 方法 schedule(TimerTask task, Date firstTime, long period)"></a>5.1.2 方法 schedule(TimerTask task, Date firstTime, long period)</h4><p>指定日期的时间后，按指定间隔周期性的执行某一任务。</p>
<ol>
<li>计划时间晚于当前时间：在未来某个时间点开始</li>
<li>计划时间早于当前时间：设定的开始时间是已经过去的 – 立即开始周期任务</li>
<li><p>任务执行时间被延迟 – 当间隔时间小于任务单次执行所要的时间时，后面的任务都被延时堆压，会越积越多，但还是一个一个顺序执行</p>
<p> 1,2,3 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest2.java" target="_blank" rel="noopener">TimerTest2.java</a></p>
</li>
<li><p><code>TimerTask</code>类的<code>cancel</code>方法 – 将自身任务从<code>Timer</code>任务队列中移除，其他任务不受影响<br> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTaskCancel.java" target="_blank" rel="noopener">TimerTaskCancel.java</a></p>
</li>
<li><code>Timer</code>类的<code>cancel</code>方法 – timer中的任务全部清除，timer内部线程销毁，程序退出<br> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerCancel.java" target="_blank" rel="noopener">TimerCancel.java</a></li>
<li><code>Timer</code>的<code>cancel()</code> 方法注意事项 – 调用<code>cancel()</code> 方法不一定会停止任务，当<code>cancel()</code>方法没有竞争到内部的<code>queue</code>锁时。</li>
</ol>
<h4 id="5-1-3-方法-schedule-TimerTask-task-long-delay"><a href="#5-1-3-方法-schedule-TimerTask-task-long-delay" class="headerlink" title="5.1.3 方法 schedule(TimerTask task, long delay)"></a>5.1.3 方法 schedule(TimerTask task, long delay)</h4><p>以当前时间为基准，延迟指定的毫秒数执行某一任务。<br>    测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest3.java" target="_blank" rel="noopener">TimerTest3.java</a></p>
<h4 id="5-1-4-方法-schedule-TimerTask-task-long-delay-long-period"><a href="#5-1-4-方法-schedule-TimerTask-task-long-delay-long-period" class="headerlink" title="5.1.4 方法 schedule(TimerTask task, long delay, long period)"></a>5.1.4 方法 schedule(TimerTask task, long delay, long period)</h4><p>以当前时间为基准，延迟指定的毫秒数开始周期性的执行某一任务。<br>    当前时间往后推3秒开始执行， 每3秒 执行一次myTask ,测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest4.java" target="_blank" rel="noopener">TimerTest4.java</a></p>
<h4 id="5-1-5-方法-scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period"><a href="#5-1-5-方法-scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period" class="headerlink" title="5.1.5 方法 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)"></a>5.1.5 方法 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</h4><p>  “单次执行任务的时间”一般小于”间隔时间<code>period</code>“，比如你<code>完成一次仰卧起坐的时间是2秒</code>，那么你就不会制定一个<code>每隔1秒做1个仰卧起坐</code>执行计划,你有可能制定一个：<strong>每隔3秒做1个仰卧起做</strong>执行计划，基于这个计划我们来对比下各种情况，schedule/scheduleAtFixedRate的表现：</p>
<p>情况1：<strong>中途出现4秒完成一个的情况</strong> – 认定为意外</p>
<p>此时<code>schedule/scheduleAtFixedRate</code>都会认为这是一个意外，为了不让这个意外继续扩散，他们都会在这个情况出现后马上开始下一次。</p>
<p>情况2：<strong>昨天忘记按这个计划执行了</strong> – 区别在这里</p>
<p>schedule: 按period周期，不追赶；马上开始做仰卧起做，按period周期做。</p>
<p>scheduleAtFixedRate: 追赶执行；马上开始做仰卧起坐，做完一个紧接着做下一个，直到赶上，完成昨天的量。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest5.java" target="_blank" rel="noopener">TimerTest5.java</a></p>
<h2 id="6-单例模式与多线程"><a href="#6-单例模式与多线程" class="headerlink" title="6. 单例模式与多线程"></a>6. 单例模式与多线程</h2><p>通过单例与多线程技术的结合，在这个过程中发现很多以前为考虑的问题，学习如何使单例模式遇到多线程时安全的。</p>
<h3 id="6-1-立即加载-“饿汉模式”"><a href="#6-1-立即加载-“饿汉模式”" class="headerlink" title="6.1 立即加载/“饿汉模式”"></a>6.1 立即加载/“饿汉模式”</h3><p>在使用类之前类的对象就已经创建好了，中文语境来看，就是饿的迫不及待，有着急迫切的含义。实现的一般做法是：私有化构造方法，声明类全局静态变量，并实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</span><br></pre></td></tr></table></figure></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest1.java" target="_blank" rel="noopener">SigletonTest1.java</a></p>
<p>注意看下上面例子不单是单例相关的演示，而且包括：静态资源初始化的问题，<strong>会有一个奇怪的现象，多线程访问类的普通静态方法，不是立马返回结果，而是线程被“阻塞了”</strong></p>
<ul>
<li>静态资源初始化本身就是 单线程的(同步阻塞)，在类内部资源被初次访问时，触发静态初始化,初始化的顺序 是从上往下.</li>
<li>被静态初始化“阻塞”的方法，不是阻塞”BLOCKD”状态，而是 “RUNNABLE” 状态</li>
</ul>
<p>其实这里应该也是<code>JVM</code>的一个编译优化，类如果被使用到，其静态的资源也不会被初始化加载。</p>
<h3 id="6-2-延迟加载-懒汉模式"><a href="#6-2-延迟加载-懒汉模式" class="headerlink" title="6.2 延迟加载/懒汉模式"></a>6.2 延迟加载/懒汉模式</h3><p>只有在<code>get()</code>时才被创建，从语境上看是“缓慢”、“不急迫”的含义。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest2.java" target="_blank" rel="noopener">SigletonTest2.java</a></p>
<p>以上代码帮助理解”懒汉模式” + “DCL” 方式实现的单例，应对的绝大多数场景：<code>高并发取单例，低并发初始化实例</code>，巧妙的避免了<code>synchronized</code>的阻塞，又使用<code>synchronized</code>来保证单次实例化。</p>
<p>进阶理解，对比测试：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SyncDclMethodCompare.java" target="_blank" rel="noopener">SyncDclMethodCompare.java</a></p>
<p><code>剧情再次反转，在我的上面的测试环境，就用 synchronized 方法就好，不会有什么性能影响</code></p>
<h3 id="6-3-静态内置类实现单例"><a href="#6-3-静态内置类实现单例" class="headerlink" title="6.3 静态内置类实现单例"></a>6.3 静态内置类实现单例</h3><p>静态内部类实现 <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest3.java" target="_blank" rel="noopener">SigletonTest3.java</a></p>
<h3 id="6-4-序列化反序列化实现单例"><a href="#6-4-序列化反序列化实现单例" class="headerlink" title="6.4 序列化反序列化实现单例"></a>6.4 序列化反序列化实现单例</h3><p>反序列化生成对象时，不通过对象的构造方法，所以会造成有另外的实例被生成，出现非单例的情况，但是反序列化内部会判断对象是否有<code>readResolve</code>方法，有就会自动调用，来达到单例的目的。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest4.java" target="_blank" rel="noopener">SigletonTest4.java</a></p>
<h3 id="6-5-使用-static-代码块实现单例"><a href="#6-5-使用-static-代码块实现单例" class="headerlink" title="6.5 使用 static 代码块实现单例"></a>6.5 使用 static 代码块实现单例</h3><p>其实这种和<code>饿汉模式</code>类似，都类被访问，静态资源自动初始化。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest5.java" target="_blank" rel="noopener">SigletonTest5.java</a></p>
<h3 id="6-6-使用枚举-enum-数据类型实现单例"><a href="#6-6-使用枚举-enum-数据类型实现单例" class="headerlink" title="6.6 使用枚举 enum 数据类型实现单例"></a>6.6 使用枚举 enum 数据类型实现单例</h3><p>利用枚举类中枚举元素自动实例化的特点，定义几个枚举元素，产生几个实例，定义一个枚举元素，就是单个实例。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest6.java" target="_blank" rel="noopener">SigletonTest6.java</a></p>
<h3 id="6-7-完善使用-enum-枚举实现单例模式"><a href="#6-7-完善使用-enum-枚举实现单例模式" class="headerlink" title="6.7 完善使用 enum 枚举实现单例模式"></a>6.7 完善使用 enum 枚举实现单例模式</h3><p>上面<code>6.6</code>的例子中违反了“职责单一原则”，完善测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest7.java" target="_blank" rel="noopener">SigletonTest7.java</a></p>
<h2 id="7-拾遗增补"><a href="#7-拾遗增补" class="headerlink" title="7. 拾遗增补"></a>7. 拾遗增补</h2><p>Skills:</p>
<ul>
<li>线程组的使用</li>
<li>如何切换线程状态</li>
<li>SimpleDateFormat 类与多线程的解决办法</li>
<li>如何处理线程异常</li>
</ul>
<h3 id="7-1-线程的状态"><a href="#7-1-线程的状态" class="headerlink" title="7.1 线程的状态"></a>7.1 线程的状态</h3><p>线程状态枚举类：<code>Thread.State</code></p>
<h4 id="7-1-1-验证-NEW、RUNNABLE、TERMINATED"><a href="#7-1-1-验证-NEW、RUNNABLE、TERMINATED" class="headerlink" title="7.1.1 验证 NEW、RUNNABLE、TERMINATED"></a>7.1.1 验证 NEW、RUNNABLE、TERMINATED</h4><h4 id="7-1-2-验证-TIMED-WAITING"><a href="#7-1-2-验证-TIMED-WAITING" class="headerlink" title="7.1.2 验证 TIMED_WAITING"></a>7.1.2 验证 TIMED_WAITING</h4><h4 id="7-1-3-验证-BLOCKED"><a href="#7-1-3-验证-BLOCKED" class="headerlink" title="7.1.3 验证 BLOCKED"></a>7.1.3 验证 BLOCKED</h4><h4 id="7-1-4-验证-WAITING"><a href="#7-1-4-验证-WAITING" class="headerlink" title="7.1.4 验证 WAITING"></a>7.1.4 验证 WAITING</h4><p><a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadStateTest.java" target="_blank" rel="noopener">演示以上1-4状态的例子</a></p>
<h3 id="7-2-线程组"><a href="#7-2-线程组" class="headerlink" title="7.2 线程组"></a>7.2 线程组</h3><p>可以把线程归属到某一个线程组中，线程组中可以有线程对象、也可以有线程组，组中还可以有线程。就类似于一颗节点树，树分支是线程组，叶子节点就是线程，树分支上可以有更小的树分支。</p>
<p>线程组的作用是批量管理线程或线程组对象，有效的对线程或线程组对象进行组织。</p>
<h4 id="7-2-1-线程对象管理线程组：-1级关联"><a href="#7-2-1-线程对象管理线程组：-1级关联" class="headerlink" title="7.2.1 线程对象管理线程组： 1级关联"></a>7.2.1 线程对象管理线程组： 1级关联</h4><p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddThread.java" target="_blank" rel="noopener">GroupAddThread.java</a></p>
<h4 id="7-2-2-线程对象管理线程组：-多级关联"><a href="#7-2-2-线程对象管理线程组：-多级关联" class="headerlink" title="7.2.2 线程对象管理线程组： 多级关联"></a>7.2.2 线程对象管理线程组： 多级关联</h4><p>多级分组, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddThreadMoreLevel.java" target="_blank" rel="noopener">GroupAddThreadMoreLevel.java</a></p>
<h4 id="7-2-3-线程组自动归属特性"><a href="#7-2-3-线程组自动归属特性" class="headerlink" title="7.2.3 线程组自动归属特性"></a>7.2.3 线程组自动归属特性</h4><p>自动归属就是自动归到当前线程组中。<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/AutoAddGroup.java" target="_blank" rel="noopener">AutoAddGroup.java</a></p>
<h4 id="7-2-4-获取根线程组"><a href="#7-2-4-获取根线程组" class="headerlink" title="7.2.4 获取根线程组"></a>7.2.4 获取根线程组</h4><p>通过线程<code>getThreadGroup().getParent()</code>获取线程所在组的父级线程组，得到为null时则已经是最根级别的组了。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GetParentGroup.java" target="_blank" rel="noopener">GetParentGroup.java</a></p>
<h4 id="7-2-5-线程组里加线程组"><a href="#7-2-5-线程组里加线程组" class="headerlink" title="7.2.5 线程组里加线程组"></a>7.2.5 线程组里加线程组</h4><p>利用<code>ThreadGroup</code>构造函数显示指定父线程组，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddGroup.java" target="_blank" rel="noopener">GroupAddGroup.java</a></p>
<h4 id="7-2-6-组内的线程批量停止"><a href="#7-2-6-组内的线程批量停止" class="headerlink" title="7.2.6 组内的线程批量停止"></a>7.2.6 组内的线程批量停止</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupInnerStop.java" target="_blank" rel="noopener">GroupInnerStop.java</a></p>
<h4 id="7-2-7-递归与非递归取的组内对象"><a href="#7-2-7-递归与非递归取的组内对象" class="headerlink" title="7.2.7 递归与非递归取的组内对象"></a>7.2.7 递归与非递归取的组内对象</h4><ul>
<li><code>getThreadGroup().enumerate(putList, isRecurse)</code> 可以指定是否递归子孙组</li>
<li><code>activeGroupCount()</code> 取的数量是包括子孙组的</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupRecurse.java" target="_blank" rel="noopener">GroupRecurse.java</a></p>
<h3 id="7-3-使线程具有有序性"><a href="#7-3-使线程具有有序性" class="headerlink" title="7.3 使线程具有有序性"></a>7.3 使线程具有有序性</h3><p>正常情况下，多个线程执行任务的时机是无序的。可通过改造代码使他们具有有序性。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadRunSync.java" target="_blank" rel="noopener">ThreadRunSync.java</a></p>
<p>这里的顺序控制逻辑其实可以利用其它方式，如指定<code>nextFlag</code>，或者使用<code>ReentrantLock</code>的多个<code>Condition</code>来指定唤醒执行。</p>
<h3 id="7-4-SimpleDateFormat-非线程安全"><a href="#7-4-SimpleDateFormat-非线程安全" class="headerlink" title="7.4 SimpleDateFormat 非线程安全"></a>7.4 SimpleDateFormat 非线程安全</h3><p><code>SimpleDateFormat</code>主要负责日期的转换和格式化，但在多线程环境中容易误用，比如全局静态化实例、全局实例多线程访问造成转换不准确。</p>
<h4 id="7-4-1-出现异常"><a href="#7-4-1-出现异常" class="headerlink" title="7.4.1 出现异常"></a>7.4.1 出现异常</h4><p>发生异常的原因：跟踪<code>SimpleDateFormat</code> 源码可以发现 内部 存储了全局变量： <code>Calendar</code>，也就是单个实例，多线程 都会访问操作 这个<code>Calendar</code>，造成混乱，最终转换错误或出现转换异常<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/FormatError.java" target="_blank" rel="noopener">FormatError.java</a></p>
<h4 id="7-4-2-解决异常方法1"><a href="#7-4-2-解决异常方法1" class="headerlink" title="7.4.2 解决异常方法1"></a>7.4.2 解决异常方法1</h4><h4 id="7-4-3-解决异常方法2"><a href="#7-4-3-解决异常方法2" class="headerlink" title="7.4.3 解决异常方法2"></a>7.4.3 解决异常方法2</h4><p>其实都是同理，不可避免每次调用都需要新的实例。一般做法是 封装工具类，实现静态方法内部实例化<code>SimpleDateFormat</code>。或者使用现有的三方工具类。</p>
<h3 id="7-5-线程中出现异常的处理"><a href="#7-5-线程中出现异常的处理" class="headerlink" title="7.5 线程中出现异常的处理"></a>7.5 线程中出现异常的处理</h3><p><code>Thread</code>实例方法：<code>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code>，与<code>Thread</code>静态方法：<code>setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadExceptionHandler.java" target="_blank" rel="noopener">ThreadExceptionHandler.java</a>，测试中在这里发现了另外一个神奇的地方:<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/NewThreadForThread.java" target="_blank" rel="noopener">new Thread(existsThread)</a></p>
<h3 id="7-6-线程组内异常"><a href="#7-6-线程组内异常" class="headerlink" title="7.6 线程组内异常"></a>7.6 线程组内异常</h3><p>新建<code>MyThreadGroup</code> 重写其<code>uncaughtException(Thread t, Throwable e)</code>方法<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadGroupInnerException.java" target="_blank" rel="noopener">ThreadGroupInnerException.java</a></p>
<h3 id="7-7-线程异常处理的传递"><a href="#7-7-线程异常处理的传递" class="headerlink" title="7.7 线程异常处理的传递"></a>7.7 线程异常处理的传递</h3><p>前面介绍涉及了3中异常处理的方式，如果将这些方式一起用上，会有什么效果呢？</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadExceptionMultiHandler.java" target="_blank" rel="noopener">ThreadExceptionMultiHandler.java</a></p>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><h3 id="8-1-1-Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）"><a href="#8-1-1-Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）" class="headerlink" title="8.1 1. Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）"></a>8.1 1. Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。参考：<a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></p>
<ul>
<li>偏向锁： 适用于<code>低竞争</code>情况，其核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。可以理解为：当只有一个线程操作带有同步方法的Vector对象的时候，此时对Vector的操作就转变成了对ArrayList的操作。jvm参数:<code>-XX:+UseBiasedLocking</code></li>
<li>重量级锁：对象监视锁(monitor)实现，依赖于操作系统<code>Mutex Lock</code>实现，操作系统线程间状态切换相对耗时长，这就是<code>synchronized</code>效率低的原因。</li>
<li>自旋锁： 空转避免线程进入<code>BLOCKED</code>，适用于<code>锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义</code>,对于竞争激烈、单线程持锁时间长的不仅仅浪费CPU，最终避免不了进入<code>BLOCKED</code>状态。在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</li>
</ul>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><ul>
<li><p>锁存在的意义  <a href="http://www.cnblogs.com/paddix/p/5374810.html" target="_blank" rel="noopener">Java 并发编程：核心理论</a></p>
</li>
<li><p>Thread类</p>
</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecxy9fgeuj20dm1p4793.jpg" alt="Thread"></p>
<ul>
<li><code>synchronized</code> ,内部锁， 锁对象， Object() 类方法：截图  wait()/wait(long)、notify()、notifyAll()</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fecumm3jxlj20ld09rjs1.jpg" alt="Object"></p>
<ul>
<li><code>Lock</code>接口方法，<code>ReentrantLock</code>类方法，<code>ReentrantReadWriteLock</code>类方法 读、写锁特性</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecummi8pwj20sp0i00v1.jpg" alt="ReentrantLock"></p>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecumlrh4ij20tk0akdgn.jpg" alt="Condition"></p>
<ul>
<li><code>Timer</code>类方法</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecvjt4roej20xd0djq5x.jpg" alt="Timer"></p>
<ul>
<li>补充 <code>LockSupport</code> <a href="http://www.tuicool.com/articles/MveUNzF" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a>、<a href="https://www.zhihu.com/question/26471972/answer/74773092" target="_blank" rel="noopener">Java中Lock和LockSupport的区别到底是什么</a></li>
<li>补充 管理类：ThreadPoolExcutor 等</li>
<li><a href="http://www.linmuxi.com/2016/06/02/jvm-note-concurrent/" target="_blank" rel="noopener">内存模型/高效并发</a></li>
</ul>
<h4 id="实验碰到的几个问题"><a href="#实验碰到的几个问题" class="headerlink" title="实验碰到的几个问题"></a>实验碰到的几个问题</h4><h5 id="1-类内部的public-static-xxMethod-有可能被阻塞吗？"><a href="#1-类内部的public-static-xxMethod-有可能被阻塞吗？" class="headerlink" title="1. 类内部的public static xxMethod() {} 有可能被阻塞吗？"></a>1. 类内部的<code>public static xxMethod() {}</code> 有可能被阻塞吗？</h5><p>静态资源初始化造成“阻塞”，但是线程其实是呈<code>RUNNABLE</code>状态的，静态资源初始化本身就是 单线程的(同步阻塞)，在类内部资源被初次访问时，触发静态初始化,初始化的顺序 是从上往下. 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest1.java" target="_blank" rel="noopener">SigletonTest1.java</a></p>
<h5 id="2-thead-join-方法内的wait-0-可以用sleep-0-代替实现吗？"><a href="#2-thead-join-方法内的wait-0-可以用sleep-0-代替实现吗？" class="headerlink" title="2. thead.join()方法内的wait(0)可以用sleep(0)代替实现吗？"></a>2. <code>thead.join()</code>方法内的<code>wait(0)</code>可以用<code>sleep(0)</code>代替实现吗？</h5><p>具体查看：<a href="http://blog.ouronghui.com/2017/03/23/Thread%E7%B1%BBjoin%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%20wait(0)%20%E8%83%BD%E7%94%A8%20sleep(0)%20%E6%9D%A5%E6%9B%BF%E4%BB%A3%E6%A8%A1%E6%8B%9F%E5%90%97/">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a></p>
<h5 id="3-thread-join-如果thread内部启动了新的线程，那么thread-join-后的代码会等待thread内部线程再执行吗？"><a href="#3-thread-join-如果thread内部启动了新的线程，那么thread-join-后的代码会等待thread内部线程再执行吗？" class="headerlink" title="3. thread.join() 如果thread内部启动了新的线程，那么thread.join()后的代码会等待thread内部线程再执行吗？"></a>3. <code>thread.join()</code> 如果<code>thread</code>内部启动了新的线程，那么<code>thread.join()</code>后的代码会等待<code>thread</code>内部线程再执行吗？</h5><p><code>thread.join()</code>方法不会理会，<code>thread</code>新启动的线程，只会根据<code>thread</code>的<code>isAlive</code>返回来判断。可以利用线程组<code>ThreadGroup</code>来判断<code>thread</code>内部新建立的线程是否都已经运行完毕。</p>
<h5 id="4-线程基础-Object-wait-与-Object-notify-都是干什么用的，怎么用的？"><a href="#4-线程基础-Object-wait-与-Object-notify-都是干什么用的，怎么用的？" class="headerlink" title="4. 线程基础 Object.wait()与 Object.notify() 都是干什么用的，怎么用的？"></a>4. 线程基础 <code>Object.wait()</code>与 <code>Object.notify()</code> 都是干什么用的，怎么用的？</h5><p>线程同步中用到，执行<code>wait/notify</code>时都需要已经持有该对象的监视锁，<code>wait()</code>方法使线程释放锁并进入<code>WAITING</code>状态，<code>notify()</code>方法是唤醒该锁阻塞队列中的一个线程，<code>notify()</code>方法不会释放锁，同步代码块结束后才释放锁。</p>
<h5 id="5-怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？"><a href="#5-怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？" class="headerlink" title="5. 怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？"></a>5. 怎么看待单例模式中懒汉模式结合<code>DCL</code>的方式解决线程安全问题？</h5><p>初期理解，以高并发初次实例化的场景看待问题，觉得存在几处浪费工作，代码结构更加不清晰。 </p>
<p>不过后来发现，其实应该“乐观”看待，<code>高并发初始化</code>场景少，<code>高并发取实例</code>场景多</p>
<p>理解代码：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest2.java" target="_blank" rel="noopener">SigletonTest2.java</a></p>
<h5 id="6-发生线程安全问题一般有哪几种情况？-方法内定义的变量，可能引起线程安全问题吗？"><a href="#6-发生线程安全问题一般有哪几种情况？-方法内定义的变量，可能引起线程安全问题吗？" class="headerlink" title="6. 发生线程安全问题一般有哪几种情况？ 方法内定义的变量，可能引起线程安全问题吗？"></a>6. 发生线程安全问题一般有哪几种情况？ 方法内定义的变量，可能引起线程安全问题吗？</h5><p>容易出现问题的一般有这几中情况：</p>
<ol>
<li>全局的静态变量， 问题的发生点在于<code>全部线程都能访问这个静态变量</code>，少有的web下应用也常见的场景：定义一个全局静态的<code>map</code>来缓存数据  <code>public static HashMap&lt;String, String&gt; cacheMap = new HashMap&lt;String, String&gt;();</code>、定义一个全局</li>
<li>全局的实例变量， 问题的发生点就在于<code>单个实例会被多个线程访问到</code>，web下其实遇到的较少，一般不同的线程会建立不同的实例，但是也有单个实例被多个线程访问到的情况，比如网上看到的一个利用<code>i++</code>全局变量作为<code>sessionId</code> <a href="http://www.blogjava.net/aoxj/archive/2012/06/16/380926.html" target="_blank" rel="noopener">链接</a>。</li>
<li>方法内的”局部”变量，这种在实际中发生的较少，问题发生在：<code>方法内定义变量，方法内部再启动多个Thread，此时&quot;局部&quot;变量就成了新启动的几个线程的共享变量了</code>，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/MethodVaribleSecurity.java" target="_blank" rel="noopener">MethodVaribleSecurity.java</a></li>
</ol>
<h5 id="7-变量到底怎样的规则存储堆、栈中？"><a href="#7-变量到底怎样的规则存储堆、栈中？" class="headerlink" title="7. 变量到底怎样的规则存储堆、栈中？"></a>7. 变量到底怎样的规则存储堆、栈中？</h5><p> 一般的说法：基础值类型存栈中，对象在堆中。 不管怎样 基础类型、对象不都是定义在class内么，整个实例化后也是对象，那岂不是都在堆中了？<br>比如:<code>Person</code>类，有属性：<code>int age</code>、<code>String name</code>、<code>Array&lt;Person&gt; friends</code>，分析下这个类的实例时如何存储的吧。<br><a href="http://blog.csdn.net/ghost_programmer/article/details/40891735" target="_blank" rel="noopener">java中数据的5种存储位置(堆与栈)</a><br><a href="http://www.linmuxi.com/2016/06/13/jvm-note-javamemoryarea/" target="_blank" rel="noopener">《深入理解Java虚拟机》-Java内存区域</a></p>
<h5 id="8-Thread-threaNew-new-Thread-existsThread-中-existsThread-的状态-对threadNew有什么影响？"><a href="#8-Thread-threaNew-new-Thread-existsThread-中-existsThread-的状态-对threadNew有什么影响？" class="headerlink" title="8. Thread threaNew = new Thread(existsThread) 中 existsThread 的状态 对threadNew有什么影响？"></a>8. <code>Thread threaNew = new Thread(existsThread)</code> 中 <code>existsThread</code> 的状态 对<code>threadNew</code>有什么影响？</h5><p><a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/NewThreadForThread.java" target="_blank" rel="noopener">new Thread(existsThread)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/06/java多线程编程核心技术/" data-id="cjjwiirhk005pftrjg9rtovz9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/" class="article-date">
  <time datetime="2017-03-23T05:41:15.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Thread-线程类-join方法实现如下"><a href="#Thread-线程类-join方法实现如下" class="headerlink" title="Thread 线程类 join方法实现如下"></a>Thread 线程类 <code>join</code>方法实现如下</h4><p>都知道<code>join()</code> 经常用于等待前一个线程执行完毕，再执行后面的任务，那<code>join()</code>方法是如何做到这个”等待”的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>                                                                                                                        </span></span><br><span class="line"><span class="function"> 2 <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="number">3</span> |   <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line"> <span class="number">4</span> |   <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> |   <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">7</span> |   |   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line"> <span class="number">8</span> |   &#125;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> |   <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="number">11</span> |   |   <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line"><span class="number">12</span> |   |   |   wait(<span class="number">0</span>);</span><br><span class="line"><span class="number">13</span> |   |   &#125;</span><br><span class="line"><span class="number">14</span> |   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">15</span> |   |   <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line"><span class="number">16</span> |   |   |   <span class="keyword">long</span> delay = millis - now;</span><br><span class="line"><span class="number">17</span> |   |   |   <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">18</span> |   |   |   |   <span class="keyword">break</span>;</span><br><span class="line"><span class="number">19</span> |   |   |   &#125;</span><br><span class="line"><span class="number">20</span> |   |   |   wait(delay);</span><br><span class="line"><span class="number">21</span> |   |   |   now = System.currentTimeMillis() - base;</span><br><span class="line"><span class="number">22</span> |   |   &#125;</span><br><span class="line"><span class="number">23</span> |   &#125;</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<ol>
<li>方法无<code>static</code>修饰，说明其为<strong>线程实例</strong>的方法</li>
<li>方法有<code>syncrhonized</code>修饰，意味着可能需要竞争锁才能进入方法，进入这个方法后将锁住<strong>线程实例</strong>这个对象</li>
<li>第<code>10</code>行<code>if</code>代码块内的即是<code>join()</code>的实现</li>
<li>逻辑：<code>判断 线程实例 isAlive()返回的是 true，则 wait(0)， 然后再次进入前面的判断，否则退出</code>，也就是在目标线程执行完毕前，这里会不断循环取状态判断、wait(0)， 这里的<code>不断</code>即起到了<code>当前线程等待目标线程执行完毕的作用了</code></li>
</ol>
<p>这里的做法看起来就像这个思路，<code>比如需要等某人做完了一些事，我们再去做另外一件事，那么我们可不断的去问这个人他是不是做完了那些事</code></p>
<h4 id="那么我们能将join方法中的wait-0-用sleep-0-替代吗？"><a href="#那么我们能将join方法中的wait-0-用sleep-0-替代吗？" class="headerlink" title="那么我们能将join方法中的wait(0)用sleep(0)替代吗？"></a>那么我们能将<code>join</code>方法中的<code>wait(0)</code>用<code>sleep(0)</code>替代吗？</h4><p>实验一下吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSyncMethodLockAlive</span> </span>&#123;                                                                                                                                  </span><br><span class="line"> <span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="number">3</span>         Thread targetThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> <span class="number">4</span>             System.out.println(<span class="string">"target begin run state="</span> + Thread.currentThread().getState());</span><br><span class="line"> <span class="number">5</span>             sleep(<span class="number">1000</span>); <span class="comment">// 模拟目标线程做某些事情，比如查询数据库</span></span><br><span class="line"> <span class="number">6</span>             System.out.println(<span class="string">"target end  run state="</span> + Thread.currentThread().getState());</span><br><span class="line"> <span class="number">7</span>         &#125;, <span class="string">"target-thread"</span>);</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>         <span class="comment">// 定时输出 目标线程的状态 与 isAlive 值</span></span><br><span class="line"><span class="number">10</span>         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="number">12</span>                 System.out.printf(<span class="string">"### log ### targetThread: state=%s, isAlvie=%s\n"</span>, targetThread.getState(), targetThread.isAlive());</span><br><span class="line"><span class="number">13</span>                 <span class="keyword">if</span> (!targetThread.isAlive() &amp;&amp; !targetThread.getState().equals(Thread.State.NEW)) &#123;</span><br><span class="line"><span class="number">14</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">15</span>                 &#125;</span><br><span class="line"><span class="number">16</span>                 sleep(<span class="number">500</span>);</span><br><span class="line"><span class="number">17</span>             &#125;</span><br><span class="line"><span class="number">18</span>             System.out.printf(<span class="string">"### log ### targetThread: state=%s, isAlvie=%s\n"</span>, targetThread.getState(), targetThread.isAlive());</span><br><span class="line"><span class="number">19</span>         &#125;).start();</span><br><span class="line"><span class="number">20</span>         targetThread.start();</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>         <span class="comment">// 模拟 Thread 的 join 方法</span></span><br><span class="line"><span class="number">23</span>         <span class="keyword">synchronized</span> (targetThread) &#123;</span><br><span class="line"><span class="number">24</span>             <span class="keyword">while</span> (targetThread.isAlive()) &#123; <span class="comment">// 取线程状态</span></span><br><span class="line"><span class="number">25</span>                 targetThread.wait(<span class="number">0</span>);</span><br><span class="line"><span class="number">26</span>             &#125;</span><br><span class="line"><span class="number">27</span>             System.out.println(<span class="string">"synchronized anlog join over."</span>);</span><br><span class="line"><span class="number">28</span>         &#125;   </span><br><span class="line"><span class="number">29</span>     &#125;   </span><br><span class="line"><span class="number">30</span>     </span><br><span class="line"><span class="number">31</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">33</span>             Thread.sleep(millis);</span><br><span class="line"><span class="number">34</span>         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="number">35</span>             e.printStackTrace();</span><br><span class="line"><span class="number">36</span>         &#125;   </span><br><span class="line"><span class="number">37</span>     &#125;   </span><br><span class="line"><span class="number">38</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们用<code>23-28</code>行<code>wait(0)</code>的模式模拟了<code>Thread</code>的<code>join</code>方法，运行测试下，没有问题。 下面我们尝试把<code>25</code>行替换为<code>Thread.sleep(0);</code>测试下，发现控制台打印没有停止,输出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target begin run state=RUNNABLE</span><br><span class="line">### log ### targetThread: state=RUNNABLE, isAlvie=true</span><br><span class="line">### log ### targetThread: state=TIMED_WAITING, isAlvie=true</span><br><span class="line">target end  run state=RUNNABLE</span><br><span class="line">### log ### targetThread: state=BLOCKED, isAlvie=true</span><br><span class="line">### log ### targetThread: state=BLOCKED, isAlvie=true</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>分析下：</p>
<ol>
<li><code>taget end run</code> 的输出意味着线程内部的代码已经运行结束了，但是目标线程状态的<code>isAlvie()</code>返回的true，所以我们期盼的<code>27</code>行也不会打印</li>
<li>为什么线程内部代码执行完了，还是alive的呢？ 我们发现：线程状态由<code>RUNNABLE</code>转为<code>BLOCKED</code>状态，而不是期望值<code>TERMINATED</code></li>
<li>状态为<code>BLOCKED</code> 意味着线程阻塞，线程等待某个锁 ，死锁了？ 我们一起来分析下堆栈内存</li>
</ol>
<h5 id="分析堆栈内存"><a href="#分析堆栈内存" class="headerlink" title="分析堆栈内存"></a>分析堆栈内存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps <span class="comment"># 拿到进程 pid</span></span><br><span class="line">$ jstack -l pid <span class="comment"># 直接查看下 堆栈信息，可以发现："target-thread" BLOCKED ，但是好像没有发现 "deadlock" 的信息，没有发现死锁那为什么还会一直等待呢？</span></span><br><span class="line"><span class="comment"># jconsole.exe 也可以查看</span></span><br><span class="line"><span class="comment"># $ jmap -dump:live,format=b,file=heap.bin pid # 将堆栈信息导出至文件，离线分析下</span></span><br></pre></td></tr></table></figure>
<p>可以看以下信息(截取了部分)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 &quot;target-thread&quot; #10 prio=5 os_prio=0 tid=0x000000001d5f4000 nid=0x24140 waiting for monitor entry [0x0000000000000000]                                                  </span><br><span class="line"> 2    java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> 3 &quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x000000001bf06800 nid=0x21a24 in Object.wait() [0x000000001d15f000]</span><br><span class="line"> 4    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"> 5         at java.lang.Object.wait(Native Method)</span><br><span class="line"> 6         - waiting on &lt;0x000000076b406f58&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"> 7         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line"> 8             - locked &lt;0x000000076b406f58&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"> 9         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">10         at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line">11 &quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002458000 nid=0x244ec runnable [0x000000000293f000]</span><br><span class="line">12    java.lang.Thread.State: RUNNABLE</span><br><span class="line">13         at java.lang.Thread.sleep(Native Method)</span><br><span class="line">14         at commu.TestSyncMethodLockAlive.main(TestSyncMethodLockAlive.java:31)</span><br><span class="line">15         - locked &lt;0x000000076b4b1c40&gt; (a java.lang.Thread)</span><br></pre></td></tr></table></figure></p>
<p>内容分析</p>
<ol>
<li>第<code>1-2</code>行: <code>target-thread</code> waiting for monitor entry ` 意味“在等待进入一个临界区， ”，这里的信息没有期望的”-waiting to lock<0xx>“ 不能看出来到底是被哪个锁阻塞。 (jconsole中都看不到此线程了)</0xx></li>
<li>第<code>11-15</code>行: <code>main</code>方法运行的主线程<code>，主线程一直处于</code>RUNNABLE<code>状态，并且持有锁</code>- locked <0x764b1c40>`</0x764b1c40></li>
<li>第<code>3-10</code>行：daemon类型，一般为jvm守护线程，这里的<code>Finalizer</code>线程主要是给执行完<code>run</code>的线程处理一些<code>身后事</code>，比如将线程移除引用队列。可以看出这里等待的锁，不是直接<code>main</code>线程持有的锁，而是线程本身在此前<code>locked</code>的一个锁，只是这里在等待外部调用某个方法来<code>notify</code>唤醒线程，而间接的在外部依赖了<code>main</code>一直持有的锁，而这个外部可能是在<code>native</code>中而无法跟踪了。</li>
</ol>
<p>思考弯路：</p>
<ol>
<li><code>synchronized</code> 不是一直持有 线程对象的锁么， 为何 “target-thread”线程在等待锁？  —-&gt;   <code>synchronized</code>是main方法持有了锁, “target-thread” 是线程内部需要这个锁</li>
</ol>
<p>总结：</p>
<ol>
<li>创建的线程运行完<code>run</code>方法后，线程调度器对其还有<code>身后事</code>要处理的，并且间接同步的使用到“线程实例”，并且这个”间接”不好追踪，所以最好不要再线程实例外部来将线程实例作为同步条件来使用。</li>
<li>线程内做的操作影响线程本身的状态</li>
<li>将“线程实例”作为锁与“普通对象”作为锁本质一样，将其普通看待不要受到干扰，所以不要把<code>targetThread.wait()</code>方法看的特殊了，理解为<code>lock.wait()</code>就好</li>
</ol>
<h4 id="回到之前的问题“我们能将wait-0-用sleep-0-替代吗？”"><a href="#回到之前的问题“我们能将wait-0-用sleep-0-替代吗？”" class="headerlink" title="回到之前的问题“我们能将wait(0)用sleep(0)替代吗？”"></a>回到之前的问题“我们能将<code>wait(0)</code>用<code>sleep(0)</code>替代吗？”</h4><p>其实从控制台打印信息，可以看出<code>isAlive返回的一直为true，因为&quot;身后事&quot;的处理被阻塞，所以线程还是alive的，但是线程状态已经由&quot;RUNNABLE&quot;转变为&quot;BLOCKED&quot;了</code>.</p>
<p><img src="/images/xbq/idea.gif" alt="">那么我们可以将我们的<code>while (targetThread.isAlive())</code> 的判断条件修改下<code>while (!targetThread.getState().equals(Thread.State.BLOCKED))</code> 修改好了接着测试看下控制台的输出吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### log ### targetThread: state=TIMED_WAITING, isAlvie=true</span><br><span class="line">target end  run state=RUNNABLE</span><br><span class="line">synchronized anlog join over.</span><br></pre></td></tr></table></figure></p>
<p>bingo! 按我们期盼的顺序输出了 <img src="/images/xbq/big-laugh.gif" alt=""></p>
<p>高兴的有些早了，多运行几次发现有时候会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synchronized anlog join over.BLOCKED</span><br><span class="line">target begin run state=RUNNABLE</span><br></pre></td></tr></table></figure></p>
<p>main先结束，target才开始，再次证明多线程问题的偶发性，一不小心就以为万事大吉，其实已经暗藏危机了。其实我们这里的根本原因是<code>忽略了除了NEW/TERMINATED状态，其它的几个线程状态都有可能随意切换</code>。 我们这里单纯认为<code>BLOCKED</code>就是由处理“身后事”造成的，是不严谨的，这里多种其他的情况情况要处理比如:</p>
<ol>
<li><code>targetThread.start()</code>是<code>synchronized</code>方法，如果它比main<code>synchronized</code>块后拿到锁，会造成线程<code>BLOCKED</code></li>
<li><code>run</code>方法内部的<code>System.out.println</code>方法为同步方法也有可能造成线程 <code>BLOCKED</code> [这也是为什么在打包的代码里最好不要出现<code>System.out.println</code>的原因]</li>
<li><code>run</code>方法内部的<code>Thread.sleep(1000)</code> 是<code>native</code>的，经测试这里暂时<code>不会造成BLOCKED</code>，但是这里是模拟的业务，如果真实业务访问数据库、读写文件等操作其他资源都有可能造成<code>BLOCKED</code></li>
</ol>
<p>现有情况的解决方式：</p>
<ol>
<li>基于<code>1</code>的问题，可以在<code>targetThread.start()后再 sleep(50)</code></li>
<li><code>2</code>的问题，将打印信息的方式改为<code>logger</code>方式输出，比如<code>java.util.logging.Logger.getGlobal().info</code>非阻塞来替代</li>
<li><code>3</code>如果只是基于我们现有的模拟任务，不用修改可以暂时满足。</li>
</ol>
<p>结论：<strong>基于上面的测试代码</strong>，可以用<code>sleep(0)</code>代替<code>wait(0)</code>的方式来达到<code>join()</code>的效果。</p>
<p>我们根据日志结果做了不科学的事情：利用判断 thread.getState() 尝试代替 thread.isAlvie() 。只有状态<code>NEW</code>与<code>TERMINATED</code>时isAlive()为false，其他状态对应的都是true;</p>
<p><strong>不科学的使用，将给你带来各种意外，需要步步跟踪测试才能做出严谨的判断，除非你只是本着探索的心在学习，否则不建议这样使用</strong></p>
<h4 id="技能点："><a href="#技能点：" class="headerlink" title="技能点："></a>技能点：</h4><ol>
<li>线程状态 - <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/thread/ThreadStateTest.java" target="_blank" rel="noopener">帮助理解线程状态的例子</a><ul>
<li><code>NEW</code> 创建了未 start</li>
<li><code>RUNNABLE</code> 有可能正在运行(RUNNING)，也有可能在就绪队列中(Ready)，这个取决于 线程调度器</li>
<li><code>TIMED_WAITING</code> 挂起，等待指定的时间后自动恢复</li>
<li><code>WATING</code> 挂起，被动恢复，依赖其他线程的操作才会唤醒</li>
<li><code>BLOCKED</code> 阻塞，被动恢复执行，依赖其他线程释放相关资源的锁</li>
<li><code>TERMINATED</code> 执行完毕的线程</li>
</ul>
</li>
<li><code>wait()</code>、<code>wait(long)</code><ul>
<li><code>wait()</code>释放锁，线程进入<code>WAITING</code>状态，无限期等待另一个线程执行某一操作，如在锁对象上执行<code>notify()</code>/<code>notifyAll()</code></li>
<li><code>wait(long)</code>释放锁，线程进入<code>TIMED_WAITING</code>，等待指定的时间<strong>自动</strong>结束指定</li>
</ul>
</li>
<li><code>sleep(long)</code><ul>
<li><code>sleep(long)</code> 如果在同步块内，线程将不会释放锁，一直持有，线程进入<code>TIMED_WAITING</code>，等待指定的时间<strong>自动</strong>往下执行</li>
</ul>
</li>
<li>java dump 分析：<ul>
<li><a href="http://www.blogjava.net/freeman1984/archive/2015/12/14/428645.html" target="_blank" rel="noopener">JAVA Thread Dump 分析综述</a></li>
<li><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a></li>
<li><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/" data-id="cjjwiirfs002jftrj81x6hb0q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/通信/">通信</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/PostgreSQL/">PostgreSQL</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/">PostgreSQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/数据库/">数据库</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全/">安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript语言/">javascript语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/英语/">英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMD/">AMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMD/">CMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Centos软件安装/">Centos软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL基础/">PostgreSQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript函数/">javascript函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript基础/">javascript基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/n2n/">n2n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/意志/">意志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/授权/">授权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/英语/">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运动/">运动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/Centos软件安装/" style="font-size: 15px;">Centos软件安装</a> <a href="/tags/CommonJS/" style="font-size: 10px;">CommonJS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/PostgreSQL基础/" style="font-size: 15px;">PostgreSQL基础</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript函数/" style="font-size: 15px;">javascript函数</a> <a href="/tags/javascript基础/" style="font-size: 15px;">javascript基础</a> <a href="/tags/n2n/" style="font-size: 10px;">n2n</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/多线程-锁/" style="font-size: 10px;">多线程 锁</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/意志/" style="font-size: 10px;">意志</a> <a href="/tags/授权/" style="font-size: 10px;">授权</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/编码/" style="font-size: 15px;">编码</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/英语/" style="font-size: 10px;">英语</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/运动/" style="font-size: 10px;">运动</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/22/大白话简记TCP/">大白话简记TCP</a>
          </li>
        
          <li>
            <a href="/2018/07/22/再理一遍OAuth2.0/">再理一遍OAuth2.0</a>
          </li>
        
          <li>
            <a href="/2018/07/22/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/03/01/搭建-ELK-日志中心/">搭建 ELK 日志中心</a>
          </li>
        
          <li>
            <a href="/2018/02/22/Spring-生命周期/">Spring 生命周期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 orh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>