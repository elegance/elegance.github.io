<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Poxi哥的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Poxi哥的博客">
<meta property="og:url" content="http://blog.ouronghui.com/page/2/index.html">
<meta property="og:site_name" content="Poxi哥的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Poxi哥的博客">
  
    <link rel="alternate" href="/atom.xml" title="Poxi哥的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Poxi哥的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">种一棵树最好的时间是十年前，其次是现在。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.ouronghui.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-前端与后端的HTTP通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/12/前端与后端的HTTP通信/" class="article-date">
  <time datetime="2017-07-12T07:10:20.000Z" itemprop="datePublished">2017-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>►<a class="article-category-link" href="/categories/HTTP/通信/">通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/12/前端与后端的HTTP通信/">前端与后端的HTTP通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理解了，不用了又淡忘了，渐渐模糊混淆，感觉耗费大把的经历。</p>
<h2 id="前端与后端的通信方式"><a href="#前端与后端的通信方式" class="headerlink" title="前端与后端的通信方式"></a>前端与后端的通信方式</h2><p>通信，其实也就是网络通信，所以从<code>Chrome</code>的控制台的<code>Network</code>可以看到前端与后端的通信，如下图：<br><img src="http://wx3.sinaimg.cn/mw690/929194b4gy1fhfr4aok4rj20au00udfn.jpg" alt=""></p>
<p>我暂时打算记录一下开发经常碰到的问题。</p>
<h2 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h2><p>这里的介绍不会一应俱全，如果有需要你可以去参考一些权威指南。跟着自己的思考，带着一些问题来记录。</p>
<h4 id="HTTP-是无状态"><a href="#HTTP-是无状态" class="headerlink" title="HTTP 是无状态"></a>HTTP 是无状态</h4><p>就像你在围墙外面，我在围墙里面，我们通过扔纸条的方式来通信，我不知道你是谁。<br>无状态带来的问题很明显，如果有两个人站在墙外，我不知道你是谁，那我们就不能聊一些私密的话题了。<br>在互联网，乃至整个现实世界，要绝对的确认一个人的身份是不可能的，网络上的信息可以被截取、模仿，现实世界有人工智能，就像那句“我不是李开复,我是人工智能。”</p>
<h4 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h4><p>请求与响应就类似传递的信件，一部分是正文，一部分是必要的附加信息比如地址、身份等等。所以HTTP的“信件”分为了head、body部分。像一封信一样，虽然分为head、body但是他们是在一个报文内的。</p>
<p>HTTP/1.1 head 是文本(ASCII编码), body 可以是文本，也可以是二进制。<br>HTTP/2 则是一个彻底的二进制协议，头、数据体都是二进制，并且统称为“帧”（frame）：头信息帧、数据帧，因为帧可以方便的扩展，解析更为方便，HTTP/2已经定义了近十种帧。</p>
<p>来看下一个Ajax完整的请求报文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.tzb360.com/tzb-api/api/public/login HTTP/1.1</span><br><span class="line">Host: www.tzb360.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 47</span><br><span class="line">Origin: https://www.tzb360.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Accept: */*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Referer: https://www.tzb360.com/html/common/login.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Cookie: userId=test01; io=j8nS4_Ph2Jaq1aSWAFX4</span><br><span class="line"></span><br><span class="line">loginName=cqtl123&amp;password=tk110234&amp;imgVefCode=</span><br></pre></td></tr></table></figure></p>
<p>可以看出：</p>
<ul>
<li><strong>14行前的是请求头，即head；14行之后的是请求体，即body</strong></li>
<li><strong>14行本身是分隔，其内容是<code>空行</code>，即CR+LF（Carriage Return 回车， Line Feed 换行）</strong><ul>
<li>打字机，在纸张上打印字时，分为纵向移动、横向移动。纸张的一行打满后，横向位置回到起点，即携带纸张的车子回到起点即回车；纵方向上向下移动一行，即换行。</li>
<li>unix 结尾只有换行“\n”，window下是“\r\n”。现象就是：win下的文件在unix下会出现“^M”符号；unix下的文件到win下会连接成一行。</li>
<li><a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html?bsh_bid=705296311" target="_blank" rel="noopener">关于回车与换行的参考</a></li>
</ul>
</li>
<li><strong>请求地址、cookie、请求内容长度等等都是在请求头内的</strong></li>
</ul>
<p>响应头报文如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.9.9</span><br><span class="line">Date: Tue, 11 Jul 2017 06:02:51 GMT</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 928</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: TZB_SESSIONID=5788439a2c524880a5f79c6b81e97fcf; Path=/; HttpOnly</span><br><span class="line"></span><br><span class="line">&#123;&quot;code&quot;:&quot;0000&quot;,&quot;data&quot;:&#123;&#125;,&quot;msg&quot;:&quot;操作成功&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样可以看出，也是使用<code>\r\n</code>作为头、体的分隔符的。</p>
<h4 id="发起请求与后台接收请求"><a href="#发起请求与后台接收请求" class="headerlink" title="发起请求与后台接收请求"></a>发起请求与后台接收请求</h4><p>编码方面这前端请求主要用：<code>XMLHttpRequest/fetch</code>来实现，后台用<code>Spring MVC</code>来实现，只涉及到POST与GET方式的请求。<br>首先有必要讲下请求头中易忘、易混淆的字段：</p>
<ol>
<li><code>Content-type</code> ，内容类型，即描述body，作为请求头时，一般有以下4种分类来描述body：<ul>
<li><code>multipart/form-data;</code> 类似页面表单，支持多字段、多类型。此类型请求体中会有对每个子段的的描述，就像请求体中分了多个子的请求头、请求体。</li>
<li><code>application/x-www-form-urlencoded</code> “=”号相隔的ascii键值串，非ascii字符与特殊字符需要转码，js中可以使用<code>encodeURIComponent</code>。请求体格式：<code>a=value-a&amp;b=value-b</code></li>
<li>raw: <code>text/plain</code>、<code>application/json</code>、<code>text/xml</code>，这一类请求意味着请求体是一块整体，告诉服务器按照<code>Content-type</code>来解析这块整体。</li>
<li>binary: 可以上传单个文件，其body中存储了二进制内容，默认没有设置<code>Content-type</code>。</li>
</ul>
</li>
<li>Request Method <ul>
<li>POST/PUT/PATCH 可以包含请求体，而其他如<strong>GET是不包括请求体的</strong>。页面上的<code>form</code>如果<code>不科学</code>的使用，会引起误解，比如<code>method=GET</code>，提交时会忽略action问号后的参数，自动将表单内的input转换为地址的QueryString。当<code>method=POST</code>提交时，如果action的QueryString与表单内的字段都会被提交，后台可以从两个来源中得到同样的参数，而可能值不同。</li>
</ul>
</li>
</ol>
<p>所以有必要强调的是，一般意义上的参数取法是当后台判断请求方法是<code>GET</code>时，取参从QueryString中取，当判断请求的方法是<code>POST</code>时，取参从FormData中取。后台<strong>可以</strong>取到<code>POST</code>请求的QueryString，GET请求是无body的。</p>
<p>错误的请求头设置，会导致后台不能正常的接收数据，请根据具体的场景选择请求方式、<code>Content-type</code>。</p>
<p>开发中会碰到一些复杂嵌套的对象需要传输，一般是前端设置<code>ContentType: application/json</code> 也就是body是一个raw，作为一个整体，后端使用<code>@RequestBody</code>描述对象。</p>
<h6 id="XMLHttpRequest-与-fetch"><a href="#XMLHttpRequest-与-fetch" class="headerlink" title="XMLHttpRequest 与 fetch"></a>XMLHttpRequest 与 fetch</h6><p>使用<code>jquery</code>发起ajax请求时，会有<code>data</code>部分的参数设置，jquery发现请求是get时，会把data对象作为head的queryString提交，如果是POST，则会将data放置到body部分。</p>
<p><code>fetch</code>方法默认情况下不会发送本地的cookie到服务器，注意如果需要依赖cookie，需要配置<code>credentials</code>，其配置值有：<code>omit</code>、<code>same-origin</code>、<code>include</code>，其意分别为不携带、同源携带、一直携带。更多关于fetch的信息可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener">MDN-GlobalFetch</a></p>
<h4 id="HTTP-协议版本"><a href="#HTTP-协议版本" class="headerlink" title="HTTP 协议版本"></a>HTTP 协议版本</h4><p>这里再简单的记录下HTTP的几个版本的区别: （需要明白协议的实现要客户端、服务端共同完成，即新的浏览器、新的Web服务（Nginx/Apache/IIs等））</p>
<ul>
<li>HTTP/1.0 每个TCP只能发送一个请求。发完数据就关闭</li>
<li><p>HTTP/1.1 (当今主流) </p>
<ul>
<li>持久连接<code>Connection: keep-alive</code>，TCP默认不关闭，可以供多个请求复用，不用手动声明。连接没有活动，客户端就可以主动关闭连接了。规范的请求是，客户端发送最后一个请求时发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。一般对于同一个域名，浏览器允许建立6个持久连接。</li>
<li>管道机制（pipelining），同一个TCP中可发送多个请求</li>
<li>Content-Length字段，一个TCP连接中有多个请求或响应，用长度区分数据边界</li>
<li>分块传输编码，<code>Content-length</code>的前提是在传输之前就得知道要传输的数据长度，对于一些耗时久、数据块大的操作来说，意味长时等待，这不太合理。更好的办法是产生一块数据，发送一块数据。使用<code>Transfer-Encoding: chunked</code>来表明数据是数量未定的数据块组成，每个非空数据块之前，会有一个16进制的数值，表示这个块的长度，最后一个大小为0的块，表示本轮数据传输完毕。下面有个<code>chunked</code>的响应例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 12 Jul 2017 05:47:23 GMT</span><br><span class="line"></span><br><span class="line">7a</span><br><span class="line">&#123;&quot;paramters&quot;:&#123;&quot;key-a&quot;:[&quot;value-a&quot;],&quot;a&quot;:[&quot;value-a&quot;],&quot;b&quot;:[&quot;value-b&quot;]&#125;,&quot;queryString&quot;:&quot;key-a=value-a&quot;,&quot;autoInject-a&quot;:&quot;value-a&quot;&#125;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTTP/2 </p>
<ul>
<li>二进制协议</li>
<li>多工，复用的TCP不要求请求与应答顺序一一对应，避免了“队头阻塞”，这样能达到双向、实时，即多工（Multiplexing）</li>
<li>数据流，一个连接内的数据包，可能归属不同的请求或响应，每个请求或响应的所有数据包，称之为一个数据流（stream）。每个stream都有一个编号，客户端请求的stream编号为奇数，服务端发起的stream为偶数。</li>
<li>头信息压缩，无状态导致很多字段都是重复的，比如Cookie和UserAgent等。因此引入了头信息压缩机制（header compression），一方面压缩传输，一方面server与client共同维护一张头表，所有字段存入这个表，生成一个索引号，只发索引号来减少传输。</li>
<li>服务器推送，允许服务器未经请求，主动向客户端发送资源。以前是请求-返回网页，解析网页源码，请求网页依赖的静态资源；而现在可以主动把这些依赖的静态资源随着网页一起发给客户端。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/07/12/前端与后端的HTTP通信/" data-id="cjkphwhqa004ibyrjpcnxvao1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java多线程补充-LockSupport类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/java多线程补充-LockSupport类/" class="article-date">
  <time datetime="2017-06-21T02:32:32.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/java多线程补充-LockSupport类/">java多线程补充-LockSupport类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在之前的<a href="http://blog.ouronghui.com/2017/04/06/java多线程编程核心技术">java多线程编程核心技术</a>文章中，主要是记录了书<code>《Java多线程编程核心技术》</code>的一些内容，其中没有介绍到<code>LockSupport</code>类，但是这个类在<code>jdk</code>源码中也经常会碰到，所以特意拿出来再看一番。</p>
<h5 id="既然已经有了ReentrantLock，为什么还需要LockSupport呢？"><a href="#既然已经有了ReentrantLock，为什么还需要LockSupport呢？" class="headerlink" title="既然已经有了ReentrantLock，为什么还需要LockSupport呢？"></a>既然已经有了<code>ReentrantLock</code>，为什么还需要<code>LockSupport</code>呢？</h5><p>主要区别在于他们面向的对象不同。</p>
<p>我们先简单来回顾下<code>ReentrantLock</code>的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reviewReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"thread-A doXX"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 记得 finally 中 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"thread-A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"thread-B doXX"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"thread-B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>lock 通常需要在finally中释放</li>
<li>其它线程取锁将被阻塞</li>
</ul>
<p>接下来看下<code>LockSupport</code>要怎么使用，看了下<code>LockSupport</code>的源码有以下特点：</p>
<ul>
<li>构造函数是私有的，说明不可手动实例化</li>
<li>其它的方法都是静态的，说明不用实例化可以直接拿来使用</li>
</ul>
<h5 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useLockSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，如果许可可用将立即返回，否则线程将进入休眠状态</span></span><br><span class="line">    System.out.println(<span class="string">"block."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行此方法会发现，控制台的Terminate一直是红色，”block”也不会输出，说明当前线程在park后就被阻塞了</li>
<li><strong>线程许可默认是被占用的</strong></li>
</ul>
<p>可以使用<code>unpark(thread)</code>先取的许可，再执行<code>park</code>,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useLockSupport2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    LockSupport.unpark(thread); <span class="comment">// 为给定的线程提供许可；如果线程在park上被阻塞，那么它将被解除阻塞。否则它的下一次 park 执行将不会被阻塞</span></span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，因为上一步已经提供了，所以会直接往下执行</span></span><br><span class="line">    System.out.println(<span class="string">"block"</span>);  <span class="comment">// 像没事人样，正常输出</span></span><br><span class="line">    LockSupport.park(); <span class="comment">// 等待许可，前面的许可已经被使用了，故此线程将会进入休眠，等待许可</span></span><br><span class="line">    System.out.println(<span class="string">"block 2"</span>);  <span class="comment">// 阻塞，不会被输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>“block”会正常输出。</li>
<li>“block 2”不会输出，线程如果重复调用<code>park</code>，那么线程将会一直阻塞下去，故<strong>LockSupport是不可重入的</strong> ，对比而言<code>ReentrantLock</code>是可重入的，一个线程可以多次获取同一把锁，<code>lock.getHoldCount()</code>方法会得到当前线程持有该锁的个数，也就是<code>lock()</code>方法的次数。总的来说就是：<strong><code>lock.lock()</code>可以重复调用(线程内执行相应的<code>lock.unlock()</code>)，而<code>LockSupport.park()</code>则是单次不重复的，只可等待其他线程<code>LockSupport.unpark(t)</code></strong></li>
</ul>
<h5 id="线程等待许可时，被打断时会怎样？"><a href="#线程等待许可时，被打断时会怎样？" class="headerlink" title="线程等待许可时，被打断时会怎样？"></a>线程等待许可时，被打断时会怎样？</h5><p>下面我们看下线程对应中断会怎样响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end - start &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            end = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"after 1 second: acount=%s\n"</span>, count);</span><br><span class="line">        </span><br><span class="line">        LockSupport.park(); <span class="comment">// 等待许可</span></span><br><span class="line">        System.out.println(<span class="string">"thread-child over."</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;, <span class="string">"thread-child"</span>);</span><br><span class="line">    </span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    t.interrupt(); <span class="comment">// 中断线程</span></span><br><span class="line">    System.out.println(<span class="string">"main over!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after 1 second: acount=85732003</span><br><span class="line">main over!</span><br><span class="line">thread-child over.true</span><br></pre></td></tr></table></figure></p>
<ul>
<li>并没有抛出异常，程序照常往下执行</li>
</ul>
<h4 id="跳回前面的问题小结下-ReentrantLock-与-LockSupport"><a href="#跳回前面的问题小结下-ReentrantLock-与-LockSupport" class="headerlink" title="跳回前面的问题小结下 ReentrantLock 与 LockSupport"></a>跳回前面的问题小结下 ReentrantLock 与 LockSupport</h4><p><code>ReentrantLock</code> 关注线程内部取锁<code>lock()</code>，<code>unlock()</code>的问题，都是<strong>线程内部代码</strong>在掌控锁，自己关注方法内的业务逻辑。<br><code>LockSupport</code> 更倾向线程间的协作，一个线程“LockSupport.park()”等待许可，另外一个线程来“唤醒”等待的线程。</p>
<p><code>LockSupport</code>像是站在线程间的指挥家，可以指定唤醒哪个线程(<code>LockSupport.unpark(thread)</code>)、什么时候唤醒等。</p>
<p>更准确的理解可以去查看<code>LockSupport</code>的源码注释。</p>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://blog.csdn.net/aitangyong/article/details/38373137" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></li>
<li><a href="https://www.zhihu.com/question/26471972/answer/74773092" target="_blank" rel="noopener">Java中Lock和LockSupport的区别到底是什么？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/21/java多线程补充-LockSupport类/" data-id="cjkphwhpn003dbyrju49c8tg9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/字符编码/" class="article-date">
  <time datetime="2017-06-21T02:31:46.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/字符编码/">字符编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从刚接触计算机理论起，就被灌输这是一台只认识0、1的机器，数字、字符串、声音、图像、视频等都可以在计算机中表示，这就是所谓的数字化吧。</p>
<h3 id="大于0、1的整数表示"><a href="#大于0、1的整数表示" class="headerlink" title="大于0、1的整数表示"></a>大于0、1的整数表示</h3><p>既然说到了，字符编码，想必已经理解了这个问题<code>只有0、1怎么表示2、3、4这些数字呢？</code>，表示如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000 -&gt; 0</span><br><span class="line">0001 -&gt; 1</span><br><span class="line">0010 -&gt; 2</span><br><span class="line">0011 -&gt; 3</span><br><span class="line">0100 -&gt; 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>采用进位使用多个bit位来表示就可以了，小数的表示这里就不展开说了，有兴趣的可以从这里看。</p>
<h4 id="TODO-内存位置"><a href="#TODO-内存位置" class="headerlink" title="TODO: 内存位置,"></a>TODO: 内存位置,</h4><p>bit 单元格，内存里面茫茫一片的<code>01...</code>， 内存并不去区分这个<code>01</code>是<code>十进制1中的01</code>，还是<code>10进制2中的01</code>  ，怎么区分这个交由具体的程序去做， <a href="http://www.cnblogs.com/little-YTMM/p/5058354.html" target="_blank" rel="noopener">关于CPU位数，OS位数以及内存大小关系</a></p>
<p>内存位置16进制编号，一个网格，网格上每个都有编号，用16进制表示，<code>0x....</code>表示</p>
<p>程序指引 int a = 1; int b = 1</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>进入今天的正题<code>字符编码</code>，同样的问题<code>0、1怎么来表示字符呢，比如hello、你好？</code></p>
<p><strong>抽象的字符编码层面：把一个字符“编码”到一个数字</strong></p>
<p><strong>具体的字符编码层面：把抽象层面的数字“编码”成最终的储存形式，明确是定长还是变长；定长的话是定几个字节；用变长的话有哪几种字节长度，具体如何实现；</strong></p>
<h4 id="Unicode-与-UTF-X"><a href="#Unicode-与-UTF-X" class="headerlink" title="Unicode 与 UTF-X"></a>Unicode 与 UTF-X</h4><p><a href="http://naotu.baidu.com/file/91e22aa3101b248bb9fb207c7d878826" target="_blank" rel="noopener">脑图</a></p>
<ul>
<li>Unicode 只是符号集，规定了符号与二进制代码的关系，没有规定二进制代码应该如何存储</li>
<li>UTF-X 根据Unicode来进行存储，涉及具体的编码; <ul>
<li>最终的存储形式 定长还是变长；</li>
<li>如果是变长有哪几种字节长度，具体如何实现；</li>
</ul>
</li>
</ul>
<p>一般来说，字符集(关系表) 与 具体实现的编码是，1对1的关系，像ASCII、GB2312(EUC-CN存储)等，但是 Unicode 与 UTF-X 是1对多的，UTF-X 有UTF-8、UTF-16、UTF-32等</p>
<h4 id="Unicode-码点-code-point"><a href="#Unicode-码点-code-point" class="headerlink" title="Unicode 码点(code point)"></a>Unicode 码点(code point)</h4><ul>
<li>码点格式：表现形式<code>U+[XX]XXXX</code>，X为16进制数字，<strong>4-6位表示</strong>。</li>
<li>码点范围：码点范围: <code>U+0000~U+10FFFF</code>；两种理解思路:<ol>
<li><code>U+10FFFF</code> 1*16^5 + 16^4 = 1114112</li>
<li><code>U+10FFFF + 1 = U+110000</code>个，前一个1是后一个1的16倍，<code>(16+1) * 65536 = 1114112</code></li>
</ol>
</li>
<li>17个面，每个面可表示65536个符<ul>
<li>BMP(Basic Multilingual Plan 基本多语言平面) <a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a></li>
<li>SP(Supplementary Plans 增补平面)</li>
</ul>
</li>
</ul>
<h4 id="编码单元-code-unit"><a href="#编码单元-code-unit" class="headerlink" title="编码单元 (code unit)"></a>编码单元 (code unit)</h4><p><code>UTF-X</code> 中<code>X</code>就代表了多少个比特位表示一个编码单元。<code>Unicode</code>码点最大<code>10FFFF</code>最大21位</p>
<p>UTF-8: 8bit即单字节为1个编码单元，UTF-16: 16bit即2个字节为1个编码单元, UTF-32：32bit即4个字节为1个编码单元</p>
<h4 id="定长编码-与-变长编码"><a href="#定长编码-与-变长编码" class="headerlink" title="定长编码 与 变长编码"></a>定长编码 与 变长编码</h4><p>定长编码：意味着这类编码使用固定长度的字节，如<code>ASCII</code>固定占1个字节长度、<code>UTF-32</code>固定占4个字节长度。特点：复杂度低，其存在的问题是<strong>定多长，定少了不够用，定多了浪费空间</strong></p>
<p>变长编码：字符所占长度不固定，如<code>UTF-8</code>占1/2/3/4个字节长度、<code>UTF-16</code>占2/4个字节长度。特点：具有一定复杂度，其核心解决的问题是<strong>如何区分不同的变长字节</strong></p>
<p>定长编码的读取我们好理解，一次读固定长度的字节，根据码表将二进制翻译字符显示即可；写入时根据字符翻译成二进制，不足固定长度，向前补0即可；</p>
<p>那变长编码的读取和写入呢？</p>
<h4 id="变长编码的实现一——UTF-8"><a href="#变长编码的实现一——UTF-8" class="headerlink" title="变长编码的实现一——UTF-8"></a>变长编码的实现一——UTF-8</h4><p><code>UTF-8</code>：<code>UTF-8</code>利用高位保留来做区分来解决上面提到的<strong>如何区分不同的变长字节</strong>问题，缺点就是减少了有效编码空间</p>
<p>这种编码方式类似<code>前缀编码</code>：<strong>设计长短不等的编码，则必须是任一字符不是另一字符编码的前缀</strong> ,就像压缩算法中应用的<code>哈夫曼编码</code></p>
<p><code>UTF-8</code>单个字节字符的字节<code>0开头</code>，<code>n</code>个字节的字符高字节是<code>n个1开头</code>，其中开头字节就像前缀一样。由于高位不同，<strong>多字节不会包含一字节的模式</strong>，0开头的字节不会出现在多字节字符编码中，二字节的模式不会出现在三字节模式中，也不会出现在四字节模式中；三字节的模式中也不会出现在四字节模式中；</p>
<table>
<thead>
<tr>
<th>UNICODE码点范围</th>
<th>UTF-8</th>
<th>UTF-8二进制</th>
<th>有效编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+0000~U+007F</td>
<td>1字节</td>
<td>0XXXXXXX</td>
<td>2^7=128个(ASCII)</td>
</tr>
<tr>
<td>U+0080~U+07FF</td>
<td>2字节</td>
<td>110XXXXX 10XXXXXX</td>
<td>2^11=2048个</td>
</tr>
<tr>
<td>U+0800~U+FFFF</td>
<td>3字节</td>
<td>1110XXXX 10XXXXXX 10XXXXXX</td>
<td>2^16=65536个</td>
</tr>
<tr>
<td>U+010000~U+10FFFF</td>
<td>4字节</td>
<td>11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
<td>2^21=2097152个</td>
</tr>
</tbody>
</table>
<ul>
<li>UTF-8多字节二进制规则：<strong>首字节前n位为1，n+1位为0；后面字节前两位为0</strong></li>
<li>UTF-8多(n)字节有效编码位：<code>(n*8)-(n+1+(n-1)*2)=5n+1</code></li>
</ul>
<p>上面有效编码可以看出来，ASCII段占1个字节、大多数字符是占1或者3个字节的，一些生僻极其罕见的才会占4个字节</p>
<h4 id="变长编码的实现二——UTF-16"><a href="#变长编码的实现二——UTF-16" class="headerlink" title="变长编码的实现二——UTF-16"></a>变长编码的实现二——UTF-16</h4><p><code>UTF-16</code>: <code>UTF-16</code>是使用所谓的代理区来实现。从<a href="http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp" target="_blank" rel="noopener">BMP字符集-鸟瀚图</a>可以看到<code>D8-D9</code>整行都是空，这块空白就是所谓的<strong>代理区(Surrogate Area)</strong>。</p>
<p>代理区实现原理：我们来自己实现一种字符编码来体验下<code>代理区</code>吧</p>
<p>大多数占2个字节，生僻极其罕见的占4个字节。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>ASCII: 计算机早期应用，只在美国，33个计算机控制字符、33个英文标点字符、10个数字字符、52个大小写字母字符，33+33+10+52=128 用一个字节的后7位表示，还空闲一个高位<code>0XXX XXXX</code></p>
</li>
<li><p>EASCII: 计算机发展至欧洲，欧洲国家128个字符不够用，利用ASCII字节空闲的最高位扩展128个.</p>
</li>
<li><p>GB2312: 国标，每个汉字及符号以两个字节来表示，第一个字节为“高位字节”，第二个字节为“低位字节”</p>
</li>
<li><p>GBK: 国标扩展</p>
</li>
<li><p>EUC: EUC-CN ，Extended Unix Code，是一个使用8位编码来表示字符的方法</p>
</li>
<li><p>BIG5: 港澳台同胞</p>
</li>
<li><p>两个独立的尝试创立单一字符集的组织:</p>
<ul>
<li>国际标准化组织（ISO）</li>
<li>由Xerox、Apple等软件制造商于1988年组成的统一码联盟</li>
</ul>
</li>
<li><p>UNICODE: Unicode是Unicode Standard（Unicode标准）,定义了码点与字符的关系</p>
</li>
<li><p>ISO: 国际标准化组织 </p>
</li>
<li><p>UCS: <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">通用字符集(Universal Character Set)</a>，由ISO制定的<code>ISO 10646</code>标准；</p>
<ul>
<li>UCS-4: <code>ISO 10646</code>标准定义了一个32位的编码形式，称作UCS-4。<a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a>和UCS4能表示的字符是相同的。</li>
<li>UCS-2: 类似<code>UCS-4</code>，使用16位的编码形式。<a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>可看成是UCS-2的父集</li>
</ul>
</li>
<li><p>BOM: Byte Order Mark，UTF-8采用字节为编码单元，没有字节序问题，常见的是UTF-16的字节序问题。</p>
<ul>
<li>UTF-16LE, 小尾序，Little Endian，也叫小端序，这里的端是指末端的意思， BOM 标记 <code>FF EE</code>， 小的作为尾巴在后面。<code>windows txt 另存时的Unicde 为UTF-16LE</code></li>
<li>UTF-16BE, 大尾序, Big  Endian，也叫大端序，这里的端也是指末端的意思，BOM 标记 <code>EE FF</code>， 大的作为尾巴在后面。<code>很多编码语言如java、javascript内码采用UTF-16BE</code></li>
<li>另外UTF-32也有大端小端的问题</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/21/字符编码/" data-id="cjkphwhqf004ubyrjcsarif2a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java线程池实现原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/15/java线程池实现原理分析/" class="article-date">
  <time datetime="2017-06-15T02:48:12.000Z" itemprop="datePublished">2017-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/15/java线程池实现原理分析/">java线程池实现原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>沉下心，才会远离烦恼。</p>
</blockquote>
<p><code>java</code>提供了多线程，用户只要继承<code>Thread</code>类或实现<code>Runnable</code>接口就能轻松达到多线程的目的。简单的应用时，我们硬编码固定的线程数可能就能满足要求，但是涉及到线程资源的重复利用、管理、响应性能等，我们就需要线程池来协助了。类似数据库连接池，线程池主要有以下优点：</p>
<ol>
<li>创建线程也需要消耗，池中线程可重复利用，降低资源消耗</li>
<li>线程提前创建，提高响应速度</li>
<li>提高线程可管理性</li>
</ol>
<p><code>Java 1.5</code>中引入了<code>Executor</code>框架把任务的<strong>提交</strong>和<strong>执行</strong>进行了解耦。只需要<strong>定义好任务</strong>，然后<strong>提交</strong>给线程池。而不用关心任务如何被执行、被哪个线程执行、以及什么时候执行等。</p>
<p><code>Executor</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Executor</code>只是一个简单的接口，但它为灵活而强大的框架创造了基础，<code>Executor</code> 基于 <strong>生产者-消费者模式</strong>。如果你在程序中实现一个生产者-消费者的设计，使用<code>Executor</code>通常是最简单的方式。</p>
<h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 2. 创建一个包含10个线程的线程池 executor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task()); <span class="comment">// 3. 20个任务提交给 线程池 executor 来执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 1. 定义任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>Executors</code>是java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池，如<code>Executors.newFixedThreadPool</code>方法产生一个拥有固定数量的线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ExecutorService</code>接口继承接口<code>Executor</code>，方法内本质是通过不同参数初始化<code>ThreadPoolExecutor</code>，下面看下这个方法是怎么定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最准确的注释，你还可以查看<code>jdk</code>源码中的英文注释。</p>
<h5 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h5><p>要保存在池中的线程数，包括空闲的。除非<code>allowCoreThreadTimeOut</code>参数被设置。如果执行了<code>prestartAllCoreThreads()</code>方法，将提前创建并启动所有核心线程。</p>
<h5 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h5><p>线程池允许的最大线程数，超出的提交将进入<code>BlockingQueue</code>阻塞队列，故<code>executor.execute(xxTask)</code>之后的代码不会因线程数量的限定而阻塞。</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>线程的空闲存活时间。该参数只在线程数大于核心线程数时起作用，结合<code>corePoolSize</code>的注释理解。</p>
<h5 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h5><p><code>keepAliveTime</code>的单位。</p>
<h5 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h5><p>保存任务的阻塞队列，限定了队列中只能存储实现了<code>Runnable</code>接口的任务。<code>BlockingQueue&lt;Runnable&gt;</code>接口在<code>JDK</code>中有以下实现：</p>
<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>: 基于链表机构的阻塞队列。</li>
<li><code>SynchronusQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入一直处于阻塞状态。</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列。</li>
</ul>
<p>前两者的味道类似于<code>ArrayList</code>与<code>LinkedList</code>，主要是具有数据结构<code>Array</code>、<code>链表</code>的特点。而<code>SynchronusQueue</code>则类似于<code>CSP</code>场景中，一个没有<code>buffer</code>缓冲的<code>channel</code>，《七周七并发模型》中一书中的<code>CSP</code>模型中提到<code>新手往往会认为有缓存的channel会比无缓存的channel应用更广泛，但实际情况却恰恰相反。</code>，虽然这不一定对，但是这提醒了我们一定要根据场景去选择使用。<code>PriorityBlockingQueue</code>则是更接近场景需求优先级的解决办法。</p>
<h5 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h5><p>创建线程的工厂，具有名称前缀<code>pool-</code>,主要实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    SecurityManager s = System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                            Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                    poolNumber.getAndIncrement() +</span><br><span class="line">                    <span class="string">"-thread-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h5><p>任务队列达到限制的饱和处理策略。线程池提供了4中策略：</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在线程来执行任务</li>
<li><code>DiscardOldesPolicy</code>: 丢弃队列最前面的任务，执行新的任务。类似于<code>CSP</code>模型中的<code>sliding</code>方式</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务。类似于<code>CSP</code>模型中的<code>dropping</code>方式<br>如果以上都不满足你的需求，你还可以自己实现<code>RejectedExecutionHandler</code>接口，自定义饱和处理策略，比如日志记录、邮件提醒等。</li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><code>Executors</code>工厂类提供了线程的初始化接口，主要有如下几种：</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能如其名，入参只有一个数字。指定固定的线程个数，其中 <code>corePoolSize == maximumPoolSize</code>，<code>0L</code>代表不会释放<code>core</code>线程，使用<code>LinkedBlocingQueue</code>作为任务队列。</p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个缓存限定时间线程的线程池，默认缓存60s，线程空闲超过60s时会自动释放线程，不会保留<code>core</code>线程。</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建单个工作线程的<code>Executor</code>，等同于<code>newFixedThreadPool(1, threadFactory)</code>，返回的<code>Executor</code>不可再重新配置。</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期同步数据。</p>
<h5 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jdk 1.8</code>中出现，创建一个<code>work-stealing</code>的线程池，内部<code>ForkJoinPool</code>使用一个并行因子来创建，默认为主机CPU的可用核心数。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>可以从方法内部的实例化代码看出，前三者都是<code>ThreadPoolExecutor</code>类实现的，<code>newScheduledThreadPool</code>返回类型都发生了变化，其实现是<code>ScheduledThreadPoolExecutor</code>，另外<code>newWorkStealingPool</code>返回值没有变化，说明暴露给外部的使用上没有变，内部使用<code>ForkJoinPool</code>来做了优化。</p>
<h4 id="ThreadPoolExecutor-线程池内部状态"><a href="#ThreadPoolExecutor-线程池内部状态" class="headerlink" title="ThreadPoolExecutor 线程池内部状态"></a>ThreadPoolExecutor 线程池内部状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); <span class="comment">// ctl 包含了两个概念，因为两个的关联关系，巧妙的组合在一起；高3位表示线程池状态； 低29位 表示workerCount </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3位为010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 高3为为011</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>RUNNING</code> : 线程池会接收新任务，并处理排队的任务 </li>
<li><code>SHUTDOWN</code>: 线程池不接收新任务，但会处理队列中的任务</li>
<li><code>STOP</code>: 线程池不接收新人无，不处理队列中的任务，并中断正在运行的任务</li>
<li><code>TIDYING</code>:  所有任务已经终止，workCount为零，线程过渡到TIDYING状态</li>
<li><code>TERMINATED</code>: terminated() 钩子方法运行完毕</li>
</ul>
<h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>线程池框架提供了两种方式提交任务：</p>
<ul>
<li><p><code>Executor.execute(Runnable command)</code>  返回void, 不关心返回值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ExecutorService.submit(Callable&lt;T&gt; task)</code> 返回<code>Future&lt;T&gt;</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="ThreadPoolExecutor-execute-的实现"><a href="#ThreadPoolExecutor-execute-的实现" class="headerlink" title="ThreadPoolExecutor.execute 的实现"></a>ThreadPoolExecutor.execute 的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取原子变量的值</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 统计 workerCount 如果小于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 则 addWorker 来创建线程来执行任务</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get(); <span class="comment">// 如果上面的 command没有被执行，则再获取一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 判断线程池当前状态为运行，并且成功将任务插入到 阻塞队列中</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 再次取新值判断</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 线程池停止了，并且任务被成功移除</span></span><br><span class="line">        reject(command); <span class="comment">// reject handler</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// workerCount 为 0 </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// ？经过上面内部的层层判断，逻辑不太会走到这里，不太理解此处的 null，在我看来这是一种“弃疗”的表现。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 再次使用 maximun 作为限定数尝试添加</span></span><br><span class="line">    reject(command); <span class="comment">// 线程池饱和处理 reject handler</span></span><br></pre></td></tr></table></figure>
<h5 id="addWorker的实现"><a href="#addWorker的实现" class="headerlink" title="addWorker的实现"></a>addWorker的实现</h5><p><code>addWorker</code>方法主要是创建线程，执行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry: <span class="comment">// 重试标记层级</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限定条件的for</span></span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 线程池状态不满足则直接返回 false</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY || <span class="comment">// 如果 workerCount 大于 容量</span></span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize)) </span><br><span class="line">                   <span class="comment">// 如果 workerCount 大于 核心线程数（外部以核心线程数作为判断依据时） 或 workerCount 大于 最大线程数(外部以最大线程数作为判断依据时)</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 容量受限，返回false</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 通过上面的检测，并更新数值成功</span></span><br><span class="line">                   <span class="keyword">break</span> retry; <span class="comment">// 跳出 多层循环，往方法的下半部分继续执行</span></span><br><span class="line">               c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 上面未设值成功，状态 没有变化</span></span><br><span class="line">                   <span class="keyword">continue</span> retry; <span class="comment">// 继续外部循环</span></span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是这个方法的前半部分，主要是线程池状态检测、线程池数量限制检测、线程池相关数量与状态的更新。以下是下半部分代码，主要是创建线程，执行任务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 线程池的工作 通过 Worker 类，Worker 类继承了 AQS （AbstractQueuedSynchronizer）</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 线程是取的 worker中的线程，而worker中的线程是线程池初始化的 线程工厂创建的</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; <span class="comment">// ReentrantLock 锁的保证下，插入到 workers(HashSet结构)中</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">            <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">            <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                workers.add(w); <span class="comment">// 加入 hashSet 中</span></span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start(); <span class="comment">// 添加成功 开始 运行</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure></p>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123; <span class="comment">// </span></span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">// 初始化线程池的 线程工厂来创建线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">// runnable 接口的实现，启动线程 运行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="runWorker实现"><a href="#runWorker实现" class="headerlink" title="runWorker实现"></a>runWorker实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts // 线程启动后通过unlock释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 首次进入会执行 firstTask，后面则主要通过getTask()方法取队列中的任务</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 前置任务</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run(); <span class="comment">// 开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 后置任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getTask-实现"><a href="#getTask-实现" class="headerlink" title="getTask 实现"></a>getTask 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 在指定时间内，阻塞队列没有新的任务，则会返回null</span></span><br><span class="line">                workQueue.take(); <span class="comment">// 如果阻塞队列为空，当前线程被挂起；队列中有任务加入时，线程被唤醒，返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Future-和-Callable-的实现"><a href="#Future-和-Callable-的实现" class="headerlink" title="Future 和 Callable 的实现"></a>Future 和 Callable 的实现</h4><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCase2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Task()); <span class="comment">// 提交异步任务</span></span><br><span class="line">        System.out.println(<span class="string">"do other things"</span>);</span><br><span class="line">        </span><br><span class="line">        String result = future.get(); <span class="comment">// 线程阻塞</span></span><br><span class="line">        System.out.println(<span class="string">"asynchronus result:"</span> + result); <span class="comment">// 后面跟随的代码，等待上面的阻塞解除执行完后，才会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 睡眠2s，模拟异步耗时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"this is future case"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际业务场景中，<code>Future</code>与<code>Callable</code>一般是成对出现的，<code>Callable</code>负责执行任务产生结果，<code>Future</code>则是负责获取结果</p>
<ol>
<li><code>Callable</code>接口类似<code>Runnable</code>接口，只是<code>Runnable</code>没有返回值。所以如果你关心你每个任务的执行返回结果，就可以采用<code>Callable</code>，否则你就直接使用<code>Runnable</code>就好了。</li>
<li><code>Callable</code>执行的任务如果发生异常，该异常也会被返回，即<code>Future</code>可以拿到异步执行任务的各种结果。</li>
<li><code>Future.get</code>方法是阻塞的，直到<code>Callable</code>任务执行完成</li>
</ol>
<h5 id="submit实现"><a href="#submit实现" class="headerlink" title="submit实现"></a>submit实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable</code>任务通过<code>submit()</code>方法被封装为一个<code>RunnableFuture</code>的<code>FutureTask</code>.</p>
<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>state 存储 <code>FutureTask</code>的状态，</li>
<li>构造初始状态为<code>NEW</code>，构造函数使用<code>callable</code>成员变量存储了入参<code>callable</code>任务</li>
<li><code>FutureTask</code>实现了<code>Runnable</code>接口，最终实际执行的是<code>FutureTask</code>中的<code>run</code>方法</li>
</ul>
<h5 id="FutureTask-get实现"><a href="#FutureTask-get实现" class="headerlink" title="FutureTask.get实现"></a>FutureTask.get实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING) <span class="comment">// 状态检查</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部通过<code>awaitDone</code>方法阻塞，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果线程被中断，则抛出异常</li>
<li>如果状态大于<code>COMPLETING</code>说明已经完成，直接返回状态即可</li>
<li>如果状态等于<code>COMPLETING</code>说明已经完成，使用<code>yield</code>让渡一下<code>cpu</code>，<code>state</code>则会过度到<code>NORMAL</code>了</li>
<li>通过<code>WaitNode</code>简单链表封装当前线程，并通过<code>UNSAFE</code>添加到<code>waiters</code>链表</li>
<li>最终通过<code>LockSupport</code>的<code>park</code>或<code>parkNanos</code>来挂起线程，另外<code>finishCompletion</code>方法中会<code>unpark</code></li>
</ul>
<h5 id="FutureTask-run-实现"><a href="#FutureTask-run-实现" class="headerlink" title="FutureTask.run 实现"></a>FutureTask.run 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>run</code> 方法是线程池中的线程来执行的，而非主线程</li>
<li>执行<code>callable.call</code>方法来运行任务</li>
<li><code>call</code>通过时用<code>set</code>方法来保存结果</li>
<li><code>call</code>出现异常时用<code>setException</code>方法来保持异常信息</li>
</ul>
<h5 id="set-setException"><a href="#set-setException" class="headerlink" title="set/setException"></a>set/setException</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>UNSAFE</code>修改了<code>FutureTask</code>的状态，最终都通过调用<code>finishCompletion</code>方法通知主线程任务完成。</p>
<h5 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新<code>waiters</code>的值</li>
<li><code>LockSupport.unpark(t)</code>唤醒主线程</li>
</ul>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/87bff5cc8d8c" target="_blank" rel="noopener">占小狼-深入分析java线程池的实现原理</a> </li>
<li>《JAVA并发编程实践》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/06/15/java线程池实现原理分析/" data-id="cjkphwhpp003gbyrjc7vba9or" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-好文推荐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/好文推荐/" class="article-date">
  <time datetime="2017-05-24T03:08:56.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/好文推荐/">好文推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一些总结的好，不一定是要文笔有多好，或者涵盖广泛。只要是能给我提供一些想法，或者是能帮助完善自己的一些想法，这里存储下链接，做一下简要记录，希望不要像书签一样，存的多却看的少。</p>
<ul>
<li><a href="http://www.zcfy.cc/article/how-to-get-node-js-logging-right-518.html" target="_blank" rel="noopener">如何让Node.js正确地日志</a> - 2017年5月24日11:14:46：<blockquote>
<p>虽然写的是Node.js的，但是提到<strong>日志的几个要点</strong>、<strong>日志的应用范围</strong>，在其他语言中同样也是适用的，抽象出概念能帮助理解日志。<br>要点：时间戳、格式、日志目标、日志级别<br>应用范围：库类型、单个应用程序、分布式系统<br><a href="https://github.com/eggjs/egg-logger" target="_blank" rel="noopener">egg-logger的图也助于理解主流日志框架</a></p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/24/好文推荐/" data-id="cjkphwhqd004pbyrj8y17q645" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javascript模块化方式简记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/javascript模块化方式简记/" class="article-date">
  <time datetime="2017-05-23T03:19:46.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/javascript模块化方式简记/">javascript模块化方式简记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a><code>CommonJS</code> 规范</h5><p><code>node.js</code>是服务端的编程，需要与操作系统、其他应用互动，需要模块化，否则无法编程，而在浏览器其复杂性有限，没有模块化也不是特别大的问题。而<code>node.js</code>的模块系统就是操作<code>CommonJS</code>规范实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./A'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a><code>AMD</code> 规范</h5><p>有了服务端模块化后，很自然地，大家就想要客户端模块化。而且最好能与服务端兼容，模块都不用修改，在服务器和浏览器都可以运行。但是<strong>浏览器加载<code>模块文件</code>是跨网络的</strong>，加载可能会造成假死，后面的代码无法运行。而服务端是在本地硬盘的，这对服务端不是问题。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p><code>AMD</code>是”Asynchronous Module Definition”，意识就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响他后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等模块加载完成后，这个回调函数才会运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖前置，提前执行</span></span><br><span class="line">    a.xx();</span><br><span class="line">    b.xx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://requirejs.org/" target="_blank" rel="noopener"><code>require.js</code></a>是<code>AMD</code>规范的一个实现。</p>
<h5 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a><code>CMD</code> 规范</h5><p><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.xxx();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>); <span class="comment">//依赖就近书写</span></span><br><span class="line">    b.xxx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="静态加载与动态加载"><a href="#静态加载与动态加载" class="headerlink" title="静态加载与动态加载"></a>静态加载与动态加载</h4><p><code>es6</code>之前模块加载的两种方式</p>
<ul>
<li>静态加载：在编译阶段进行，把所有需要的依赖打包到一个文件</li>
<li>动态加载：在运行时加载</li>
</ul>
<p><code>AMD</code>标准是动态加载的代表，而<code>CommonJS</code>是静态加载的代表。</p>
<p><code>AMD</code>主要用在浏览器上，是异步加载的，而<code>NodeJS</code>在服务端，同步加载的方式更易被接收，所以用的是<code>CommonJS</code>。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><code>ES6</code></h5><p><code>ES6</code>采用哪种加载机制了？ <code>ES6</code>既希望用简单的声明来完成静态加载，有不愿放弃动态加载的特性，而这两种方式几乎不能简单的同时实现，所以<code>ES6</code>提供了两种独立的模块加载方法。</p>
<ol>
<li><p>声明的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> some_module;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>System.import</code> API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.import(<span class="string">'some_module)</span></span><br><span class="line"><span class="string">    .then(some_module =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    .catch(error =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>模块导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export 一个命名 function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export default function</span></span><br><span class="line"><span class="keyword">export</span> num = <span class="number">123</span> <span class="comment">// export 一个数值</span></span><br><span class="line"><span class="keyword">export</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; obj <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// default export</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> myModule&#125; <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// rename</span></span><br><span class="line"><span class="keyword">import</span> &#123;abc, num, obj&#125; <span class="keyword">from</span> <span class="string">'some_module'</span></span><br></pre></td></tr></table></figure></p>
<p>参考自：</p>
<ul>
<li><a href="https://blog.wilddog.com/?p=587" target="_blank" rel="noopener">写了十年JS却不知道模块化为何物？</a></li>
<li><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">Sea.js 与 RequireJS 的异同</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/23/javascript模块化方式简记/" data-id="cjkphwhpl003abyrjcots594l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AMD/">AMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CMD/">CMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字节序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/字节序/" class="article-date">
  <time datetime="2017-05-16T01:31:57.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/字节序/">字节序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实已经有几次写到过有关字节序的问题了，这里单独拎出来再写一次，是因为又淡忘了，特意抽象其根本问题再做一个简要的记录。</p>
<p>抽象出的两个概念：</p>
<ol>
<li>存储地址：内存地址“从左至右”递增，可以理解往左是低位地址，往右是高位地址</li>
<li>要存的值：比如1个数字 112233(十进制)、1个字符串 “112233”  —(这里两处的33都是尾巴)</li>
</ol>
<p>注意：1个xx需要多个字节表示的时候，才会有字节序的问题</p>
<h4 id="面临的问题：-尾巴放到高的位置还是低的位置？"><a href="#面临的问题：-尾巴放到高的位置还是低的位置？" class="headerlink" title="面临的问题： 尾巴放到高的位置还是低的位置？"></a>面临的问题： 尾巴放到高的位置还是低的位置？</h4><p><strong>高尾端：高的位置存尾巴</strong></p>
<p><strong>低尾端：低的位置存尾巴</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1ffmybwhwrwj20jm0ax0sr.jpg" alt="字节序"></p>
<h4 id="比拟"><a href="#比拟" class="headerlink" title="比拟"></a>比拟</h4><p>一个<code>词</code>中<code>字</code>的顺序 (普遍：从左至右念，牌匾：从右至左念)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">法语，公主，四十</span><br></pre></td></tr></table></figure></p>
<p>一行文字中字的读取顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严管妻是本；妇顺夫为实.</span><br></pre></td></tr></table></figure></p>
<p>解析的顺序不一样意义就大不一样咯。</p>
<h4 id="其他叫法"><a href="#其他叫法" class="headerlink" title="其他叫法"></a>其他叫法</h4><p><code>高尾端/大端序/大尾序</code></p>
<p><code>低尾端/小端序/小尾序</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/16/字节序/" data-id="cjkphwhql004wbyrj0kh2ehwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-事务及隔离级别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/事务及隔离级别/" class="article-date">
  <time datetime="2017-05-08T08:12:08.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/事务及隔离级别/">事务及隔离级别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><p>据库具有 <strong>ACID</strong>四个特性，分别指：</p>
<h5 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity - 原子性"></a>Atomicity - 原子性</h5><p>原子操作不可分割，内部要么全部成功，要么全部失败。</p>
<h5 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency - 一致性"></a>Consistency - 一致性</h5><p>系统从一个一致状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性，下面会详细提到。</p>
<h5 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation - 隔离性"></a>Isolation - 隔离性</h5><p>事务不被其他事务干扰，相互隔离。 每个事务都感觉不到其他事务在执行，下面为详细提到事务的隔离的级别。</p>
<h5 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability - 持久性"></a>Durability - 持久性</h5><p>事务一旦提交，那么数据的改变就是永久性的。</p>
<h4 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h4><p>此处主要参考: <a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>
<ul>
<li><strong>强一致性</strong>：读操作可以立即读到提交的更新操作。</li>
<li><strong>弱一致性</strong>: 提交的更新操作，不一定立即会被操作读取到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li>
<li><strong>最终一致性</strong>: 是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li>
<li><strong>单调一致性</strong>: 如果一个进程已经读到一个值，那么后续不会读到更早的值。</li>
<li><strong>会话一致性</strong>: 保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li>
</ul>
<h4 id="事务隔离性"><a href="#事务隔离性" class="headerlink" title="事务隔离性"></a>事务隔离性</h4><p>如果不考虑隔离性，在事务并发操作时，可能出现的问题有：</p>
<ul>
<li><strong>脏读</strong>：<strong>一个事务读取了另一个事务未提交的数据</strong><blockquote>
<p>例如：公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。</p>
</blockquote>
</li>
<li><strong>不可重复读</strong>：<strong>一个事务内，单份数据多次读取结果不同</strong>，这是由于<strong>读取间隔，被别的事务修改并提交了</strong> （事务内重复读取会有问题，不重复读则没问题，则理解为<code>不可重复读</code>问题）<blockquote>
<p>例如：singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何……</p>
</blockquote>
</li>
<li><strong>幻读</strong>：<strong>一个事务内，多次读取数据的结果集合不同</strong>，幻读是由于<strong>读取间隔，被别的事务插入了数据</strong><blockquote>
<p>例如：singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了</p>
</blockquote>
</li>
</ul>
<p>针对上面的问题，一般定义有以下几种事务隔离级别：</p>
<ul>
<li><strong>READ UNCOMMITED</strong> (可以读取到未提交的数据)一个事务可以读到另一个事务未提交的结果，以上的<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>问题都可能会发生。</li>
<li><strong>READ COMMITED</strong>  (可以读取到已提交的数据)只有在事务提交后，其更新结果才会被其他事务看见。<strong>可以解决上面的脏读问题</strong></li>
<li><strong>Repeated Read</strong> (重复读取)在同一个事务中，对于同一份数据的读取结果总是相同的，无论其他事务对这份数据是否进行操作，以及整个事务是否提交。<strong>可以解决脏读、不可重复读问题</strong></li>
<li><strong>Serializable</strong> (串行化) 隔离级别最高，牺牲了系统的并发性。<strong>可以解决并发事务的所有问题</strong></li>
</ul>
<p>大多数数据库的默认级别就是<code>Read committed</code>，如<code>Oracle</code>、<code>SQL Server</code>; </p>
<p>注：<code>MySQL</code> 的默认隔离级别是<code>REPEATABLE-READ</code>，查看命令<code>select @@tx_isolation;</code></p>
<p>例子参考：</p>
<p><a href="http://singo107.iteye.com/blog/1175084" target="_blank" rel="noopener">数据库事务隔离级别</a></p>
<p><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">数据库事务的四大特性以及事务的隔离级别</a></p>
<p><a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/08/事务及隔离级别/" data-id="cjkphwhq30042byrj2k2tee4o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-书单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/书单/" class="article-date">
  <time datetime="2017-04-14T05:51:52.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/书单/">书单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>书是系统性的表达，相对单篇的博客、资讯，书内容更加完整富有体系。对于一些新流行的技术，网上的资讯快餐更及时，书的内容往往会跟不上潮流，但是经典的东西往往早已沉淀在书中了。
</code></pre><h2 id="正读"><a href="#正读" class="headerlink" title="正读"></a>正读</h2><ul>
<li>《编码-隐匿在计算机背后的软硬件语言》</li>
<li>《大话数据结构》</li>
<li>《大话设计模式》</li>
</ul>
<h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ul>
<li>《JavaScript高级程序设计（第3版）》</li>
<li>《Java多线程编程核心技术》</li>
<li><p>《鸟哥的Linux私房菜》</p>
</li>
<li><p>《把时间当作朋友》</p>
</li>
<li>《黑客与画家》</li>
<li>《一个人的朝圣》</li>
<li>《影响力》</li>
<li><p>《习惯的力量》</p>
</li>
<li><p>《潜规则》</p>
</li>
<li>《摆渡人》</li>
<li>《解读量化投资：西蒙斯用公式打败市场的故事》</li>
<li>《从你的全世界路过》</li>
<li>《我不是潘金莲》</li>
<li>《解忧杂货店》</li>
<li>《智齿》</li>
<li>《别做正常的傻瓜》</li>
<li>《别拿村长不当干部》</li>
<li>《老鼠仓》</li>
<li>《为奴十二年》</li>
<li>《追风筝的人》</li>
<li>《人性弱点》</li>
<li>《如何变得有思想？》</li>
</ul>
<h2 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h2><ul>
<li>《编写高质量代码：改善Java程序的151个建议》</li>
<li><p>《TCP-IP协议族(第4版)》</p>
</li>
<li><p>《岛上书店》</p>
</li>
<li>《无声告白》</li>
<li>《我的晃荡青春》</li>
<li>《白夜行》</li>
<li>《沉默的大多数》</li>
<li>《世界上的另一个你》</li>
<li>《不抱怨的世界》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://book.douban.com" target="_blank" rel="noopener">豆瓣读书</a></li>
<li><a href="http://www.cnblogs.com/xing901022/p/3694709.html" target="_blank" rel="noopener">他人书单1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/14/书单/" data-id="cjkphwhq20040byrjbwog3dom" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux操作常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/Linux操作常用命令/" class="article-date">
  <time datetime="2017-04-12T02:33:08.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/Linux操作常用命令/">Linux操作常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一些常用的技巧，隔一段时间不用又给淡忘了。</p>
<h3 id="打包压缩、解压"><a href="#打包压缩、解压" class="headerlink" title="打包压缩、解压"></a>打包压缩、解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// .tar.bz2 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jcv -f /root/<span class="built_in">test</span>/etc.tar.bz2 /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jxv -f  /root/<span class="built_in">test</span>/etc.tar.bz2  -C /tmp/</span></span><br><span class="line"></span><br><span class="line">// .tar.gz 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zcv -f /root/<span class="built_in">test</span>/etc.tar.gz /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zxv -f  /root/<span class="built_in">test</span>/etc.tar.gz  -C /tmp/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -sf /usr/local/postgresql-9.2.4 /usr/local/pgsql</span></span><br><span class="line"><span class="comment">## -s: symbole 软链接，-f: force 如果目标链接已经存在则删除重新建立</span></span><br><span class="line"><span class="comment">## 如果9.2.5的版本发布了，升级只需停掉数据库在这里改下软链接地址就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="当前目录-各文件夹-大小-linux"><a href="#当前目录-各文件夹-大小-linux" class="headerlink" title="当前目录 各文件夹 大小 linux"></a>当前目录 各文件夹 大小 linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find $1 -maxdepth 1 | xargs du -sh</span></span><br></pre></td></tr></table></figure>
<h3 id="强制停止应用的两种方式"><a href="#强制停止应用的两种方式" class="headerlink" title="强制停止应用的两种方式"></a>强制停止应用的两种方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;print $2&#125;'|xargs kill -9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;system("kill -9 " $2)&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="某次服务器中毒，删除与病毒文件同样大小字节的文件"><a href="#某次服务器中毒，删除与病毒文件同样大小字节的文件" class="headerlink" title="某次服务器中毒，删除与病毒文件同样大小字节的文件"></a>某次服务器中毒，删除与病毒文件同样大小字节的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -size 1223123c | xargs rm -rf</span></span><br></pre></td></tr></table></figure>
<h3 id="find类-其他"><a href="#find类-其他" class="headerlink" title="find类 其他"></a>find类 其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正则匹配删除</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "2016-12-1[2-7]"|xargs rm -rf</span></span><br><span class="line"></span><br><span class="line">// 反向匹配，找出名字不含 <span class="string">"tar"</span> 的文件/文件夹</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "tar" -v</span></span><br></pre></td></tr></table></figure>
<h3 id="根据进程获取进程号，打印进程的运行信息"><a href="#根据进程获取进程号，打印进程的运行信息" class="headerlink" title="根据进程获取进程号，打印进程的运行信息"></a>根据进程获取进程号，打印进程的运行信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pgrep mysql | xargs -I &#123;&#125; ls -l /proc/&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="crontab-同步时间，"><a href="#crontab-同步时间，" class="headerlink" title="crontab 同步时间，"></a>crontab 同步时间，</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// crontab 分、时、日、月、周</span><br><span class="line">// 10分钟同步一次</span><br><span class="line"><span class="comment"># */10 * * * * /usr/sbin/ntpdate time.windows.com &amp;&amp; hwclock -w</span></span><br></pre></td></tr></table></figure>
<h3 id="输出磁盘的读写情况"><a href="#输出磁盘的读写情况" class="headerlink" title="输出磁盘的读写情况"></a>输出磁盘的读写情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iostat -k 2</span></span><br></pre></td></tr></table></figure>
<h3 id="新增磁盘"><a href="#新增磁盘" class="headerlink" title="新增磁盘"></a>新增磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// fdisk: 操作磁盘分区表</span><br><span class="line">// mkfs：对磁盘分区进行文件系统格式化</span><br><span class="line"></span><br><span class="line">// 列出磁盘装置，找到我们要操作的装置名称，便于对其进行分区</span><br><span class="line"><span class="comment"># fdisk -l </span></span><br><span class="line"></span><br><span class="line">// 开始对磁盘进行分区处理，注意不要加上数字</span><br><span class="line"><span class="comment"># fdisk /dev/xvdb  </span></span><br><span class="line"></span><br><span class="line">// 对分区进行格式化</span><br><span class="line"><span class="comment"># mkfs -t ext4 -c /dev/xvdb1</span></span><br><span class="line"></span><br><span class="line">// 建立磁盘挂载目录</span><br><span class="line"><span class="comment"># mkdir /data</span></span><br><span class="line"></span><br><span class="line">// 手动挂载</span><br><span class="line"><span class="comment"># mount /dev/xvdb1 /data/</span></span><br><span class="line"></span><br><span class="line">// 开机自动挂载</span><br><span class="line"><span class="comment"># echo "/dev/xvdb1 /data/ ext4 defaults 0 0" &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>
<h3 id="看你在Linux下最常用的命令是哪些？"><a href="#看你在Linux下最常用的命令是哪些？" class="headerlink" title="看你在Linux下最常用的命令是哪些？"></a>看你在Linux下最常用的命令是哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | awk <span class="string">'&#123;CMD[$2]++;count++;&#125; END &#123; for (a in CMD )print CMD[ a ]" " CMD[ a ]/count*100 "% " a &#125;'</span> | grep -v <span class="string">"./"</span> | column -c3 -s <span class="string">" "</span> -t |sort -nr | nl | head -n10</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/12/Linux操作常用命令/" data-id="cjkphwhp0002bbyrjdwxuu0pr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/通信/">通信</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/PostgreSQL/">PostgreSQL</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Openresty/">Openresty</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/">PostgreSQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/数据库/">数据库</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全/">安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript语言/">javascript语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/英语/">英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMD/">AMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMD/">CMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Centos软件安装/">Centos软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL基础/">PostgreSQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript函数/">javascript函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript基础/">javascript基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/n2n/">n2n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/意志/">意志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/授权/">授权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/灰度发布/">灰度发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/英语/">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运动/">运动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/Centos软件安装/" style="font-size: 15px;">Centos软件安装</a> <a href="/tags/CommonJS/" style="font-size: 10px;">CommonJS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PostgreSQL基础/" style="font-size: 15px;">PostgreSQL基础</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript函数/" style="font-size: 15px;">javascript函数</a> <a href="/tags/javascript基础/" style="font-size: 15px;">javascript基础</a> <a href="/tags/n2n/" style="font-size: 10px;">n2n</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/多线程-锁/" style="font-size: 10px;">多线程 锁</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/意志/" style="font-size: 10px;">意志</a> <a href="/tags/授权/" style="font-size: 10px;">授权</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/灰度发布/" style="font-size: 10px;">灰度发布</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/编码/" style="font-size: 15px;">编码</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/英语/" style="font-size: 10px;">英语</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/运动/" style="font-size: 10px;">运动</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/09/Lua-OpenResty-开发环境搭建/">Lua OpenResty 开发环境搭建</a>
          </li>
        
          <li>
            <a href="/2018/08/05/Nginx-Lua-实现灰度发布/">Nginx+Lua 实现灰度发布</a>
          </li>
        
          <li>
            <a href="/2018/07/22/大白话简记TCP/">大白话简记TCP</a>
          </li>
        
          <li>
            <a href="/2018/07/22/再理一遍OAuth2.0/">再理一遍OAuth2.0</a>
          </li>
        
          <li>
            <a href="/2018/07/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 orh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>