<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的个人poxi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的个人poxi">
<meta property="og:url" content="http://blog.ouronghui.com/page/3/index.html">
<meta property="og:site_name" content="我的个人poxi">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的个人poxi">
  
    <link rel="alternate" href="/atom.xml" title="我的个人poxi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的个人poxi</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">种一棵树最好的时间是十年前，其次是现在。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.ouronghui.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-javascript模块化方式简记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/javascript模块化方式简记/" class="article-date">
  <time datetime="2017-05-23T03:19:46.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/javascript模块化方式简记/">javascript模块化方式简记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a><code>CommonJS</code> 规范</h5><p><code>node.js</code>是服务端的编程，需要与操作系统、其他应用互动，需要模块化，否则无法编程，而在浏览器其复杂性有限，没有模块化也不是特别大的问题。而<code>node.js</code>的模块系统就是操作<code>CommonJS</code>规范实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./A'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a><code>AMD</code> 规范</h5><p>有了服务端模块化后，很自然地，大家就想要客户端模块化。而且最好能与服务端兼容，模块都不用修改，在服务器和浏览器都可以运行。但是<strong>浏览器加载<code>模块文件</code>是跨网络的</strong>，加载可能会造成假死，后面的代码无法运行。而服务端是在本地硬盘的，这对服务端不是问题。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p><code>AMD</code>是”Asynchronous Module Definition”，意识就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响他后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等模块加载完成后，这个回调函数才会运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖前置，提前执行</span></span><br><span class="line">    a.xx();</span><br><span class="line">    b.xx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://requirejs.org/" target="_blank" rel="noopener"><code>require.js</code></a>是<code>AMD</code>规范的一个实现。</p>
<h5 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a><code>CMD</code> 规范</h5><p><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.xxx();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>); <span class="comment">//依赖就近书写</span></span><br><span class="line">    b.xxx();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="静态加载与动态加载"><a href="#静态加载与动态加载" class="headerlink" title="静态加载与动态加载"></a>静态加载与动态加载</h4><p><code>es6</code>之前模块加载的两种方式</p>
<ul>
<li>静态加载：在编译阶段进行，把所有需要的依赖打包到一个文件</li>
<li>动态加载：在运行时加载</li>
</ul>
<p><code>AMD</code>标准是动态加载的代表，而<code>CommonJS</code>是静态加载的代表。</p>
<p><code>AMD</code>主要用在浏览器上，是异步加载的，而<code>NodeJS</code>在服务端，同步加载的方式更易被接收，所以用的是<code>CommonJS</code>。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><code>ES6</code></h5><p><code>ES6</code>采用哪种加载机制了？ <code>ES6</code>既希望用简单的声明来完成静态加载，有不愿放弃动态加载的特性，而这两种方式几乎不能简单的同时实现，所以<code>ES6</code>提供了两种独立的模块加载方法。</p>
<ol>
<li><p>声明的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> some_module;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>System.import</code> API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.import(<span class="string">'some_module)</span></span><br><span class="line"><span class="string">    .then(some_module =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    .catch(error =&gt; &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>模块导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export 一个命名 function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// export default function</span></span><br><span class="line"><span class="keyword">export</span> num = <span class="number">123</span> <span class="comment">// export 一个数值</span></span><br><span class="line"><span class="keyword">export</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; obj <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// default export</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> myModule&#125; <span class="keyword">from</span> <span class="string">'some_module'</span> <span class="comment">// rename</span></span><br><span class="line"><span class="keyword">import</span> &#123;abc, num, obj&#125; <span class="keyword">from</span> <span class="string">'some_module'</span></span><br></pre></td></tr></table></figure></p>
<p>参考自：</p>
<ul>
<li><a href="https://blog.wilddog.com/?p=587" target="_blank" rel="noopener">写了十年JS却不知道模块化为何物？</a></li>
<li><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">Sea.js 与 RequireJS 的异同</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/23/javascript模块化方式简记/" data-id="cjk0gup900035a3rj1sl5axgd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AMD/">AMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CMD/">CMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字节序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/字节序/" class="article-date">
  <time datetime="2017-05-16T01:31:57.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/字节序/">字节序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实已经有几次写到过有关字节序的问题了，这里单独拎出来再写一次，是因为又淡忘了，特意抽象其根本问题再做一个简要的记录。</p>
<p>抽象出的两个概念：</p>
<ol>
<li>存储地址：内存地址“从左至右”递增，可以理解往左是低位地址，往右是高位地址</li>
<li>要存的值：比如1个数字 112233(十进制)、1个字符串 “112233”  —(这里两处的33都是尾巴)</li>
</ol>
<p>注意：1个xx需要多个字节表示的时候，才会有字节序的问题</p>
<h4 id="面临的问题：-尾巴放到高的位置还是低的位置？"><a href="#面临的问题：-尾巴放到高的位置还是低的位置？" class="headerlink" title="面临的问题： 尾巴放到高的位置还是低的位置？"></a>面临的问题： 尾巴放到高的位置还是低的位置？</h4><p><strong>高尾端：高的位置存尾巴</strong></p>
<p><strong>低尾端：低的位置存尾巴</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1ffmybwhwrwj20jm0ax0sr.jpg" alt="字节序"></p>
<h4 id="比拟"><a href="#比拟" class="headerlink" title="比拟"></a>比拟</h4><p>一个<code>词</code>中<code>字</code>的顺序 (普遍：从左至右念，牌匾：从右至左念)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">法语，公主，四十</span><br></pre></td></tr></table></figure></p>
<p>一行文字中字的读取顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严管妻是本；妇顺夫为实.</span><br></pre></td></tr></table></figure></p>
<p>解析的顺序不一样意义就大不一样咯。</p>
<h4 id="其他叫法"><a href="#其他叫法" class="headerlink" title="其他叫法"></a>其他叫法</h4><p><code>高尾端/大端序/大尾序</code></p>
<p><code>低尾端/小端序/小尾序</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/16/字节序/" data-id="cjk0gup9r004ja3rjspis1tth" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-事务及隔离级别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/事务及隔离级别/" class="article-date">
  <time datetime="2017-05-08T08:12:08.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/事务及隔离级别/">事务及隔离级别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><p>据库具有 <strong>ACID</strong>四个特性，分别指：</p>
<h5 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity - 原子性"></a>Atomicity - 原子性</h5><p>原子操作不可分割，内部要么全部成功，要么全部失败。</p>
<h5 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency - 一致性"></a>Consistency - 一致性</h5><p>系统从一个一致状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性，下面会详细提到。</p>
<h5 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation - 隔离性"></a>Isolation - 隔离性</h5><p>事务不被其他事务干扰，相互隔离。 每个事务都感觉不到其他事务在执行，下面为详细提到事务的隔离的级别。</p>
<h5 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability - 持久性"></a>Durability - 持久性</h5><p>事务一旦提交，那么数据的改变就是永久性的。</p>
<h4 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h4><p>此处主要参考: <a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>
<ul>
<li><strong>强一致性</strong>：读操作可以立即读到提交的更新操作。</li>
<li><strong>弱一致性</strong>: 提交的更新操作，不一定立即会被操作读取到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</li>
<li><strong>最终一致性</strong>: 是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li>
<li><strong>单调一致性</strong>: 如果一个进程已经读到一个值，那么后续不会读到更早的值。</li>
<li><strong>会话一致性</strong>: 保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li>
</ul>
<h4 id="事务隔离性"><a href="#事务隔离性" class="headerlink" title="事务隔离性"></a>事务隔离性</h4><p>如果不考虑隔离性，在事务并发操作时，可能出现的问题有：</p>
<ul>
<li><strong>脏读</strong>：<strong>一个事务读取了另一个事务未提交的数据</strong><blockquote>
<p>例如：公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。</p>
</blockquote>
</li>
<li><strong>不可重复读</strong>：<strong>一个事务内，单份数据多次读取结果不同</strong>，这是由于<strong>读取间隔，被别的事务修改并提交了</strong> （事务内重复读取会有问题，不重复读则没问题，则理解为<code>不可重复读</code>问题）<blockquote>
<p>例如：singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何……</p>
</blockquote>
</li>
<li><strong>幻读</strong>：<strong>一个事务内，多次读取数据的结果集合不同</strong>，幻读是由于<strong>读取间隔，被别的事务插入了数据</strong><blockquote>
<p>例如：singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了</p>
</blockquote>
</li>
</ul>
<p>针对上面的问题，一般定义有以下几种事务隔离级别：</p>
<ul>
<li><strong>READ UNCOMMITED</strong> (可以读取到未提交的数据)一个事务可以读到另一个事务未提交的结果，以上的<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>问题都可能会发生。</li>
<li><strong>READ COMMITED</strong>  (可以读取到已提交的数据)只有在事务提交后，其更新结果才会被其他事务看见。<strong>可以解决上面的脏读问题</strong></li>
<li><strong>Repeated Read</strong> (重复读取)在同一个事务中，对于同一份数据的读取结果总是相同的，无论其他事务对这份数据是否进行操作，以及整个事务是否提交。<strong>可以解决脏读、不可重复读问题</strong></li>
<li><strong>Serializable</strong> (串行化) 隔离级别最高，牺牲了系统的并发性。<strong>可以解决并发事务的所有问题</strong></li>
</ul>
<p>大多数数据库的默认级别就是<code>Read committed</code>，如<code>Oracle</code>、<code>SQL Server</code>; </p>
<p>注：<code>MySQL</code> 的默认隔离级别是<code>REPEATABLE-READ</code>，查看命令<code>select @@tx_isolation;</code></p>
<p>例子参考：</p>
<p><a href="http://singo107.iteye.com/blog/1175084" target="_blank" rel="noopener">数据库事务隔离级别</a></p>
<p><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">数据库事务的四大特性以及事务的隔离级别</a></p>
<p><a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">理解事务——原子性、一致性、隔离性和持久性</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/05/08/事务及隔离级别/" data-id="cjk0gup9g003ya3rjw4tw7agp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-书单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/书单/" class="article-date">
  <time datetime="2017-04-14T05:51:52.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/书单/">书单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>书是系统性的表达，相对单篇的博客、资讯，书内容更加完整富有体系。对于一些新流行的技术，网上的资讯快餐更及时，书的内容往往会跟不上潮流，但是经典的东西往往早已沉淀在书中了。
</code></pre><h2 id="正读"><a href="#正读" class="headerlink" title="正读"></a>正读</h2><ul>
<li>《编码-隐匿在计算机背后的软硬件语言》</li>
<li>《大话数据结构》</li>
<li>《大话设计模式》</li>
</ul>
<h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ul>
<li>《JavaScript高级程序设计（第3版）》</li>
<li>《Java多线程编程核心技术》</li>
<li><p>《鸟哥的Linux私房菜》</p>
</li>
<li><p>《把时间当作朋友》</p>
</li>
<li>《黑客与画家》</li>
<li>《一个人的朝圣》</li>
<li>《影响力》</li>
<li><p>《习惯的力量》</p>
</li>
<li><p>《潜规则》</p>
</li>
<li>《摆渡人》</li>
<li>《解读量化投资：西蒙斯用公式打败市场的故事》</li>
<li>《从你的全世界路过》</li>
<li>《我不是潘金莲》</li>
<li>《解忧杂货店》</li>
<li>《智齿》</li>
<li>《别做正常的傻瓜》</li>
<li>《别拿村长不当干部》</li>
<li>《老鼠仓》</li>
<li>《为奴十二年》</li>
<li>《追风筝的人》</li>
<li>《人性弱点》</li>
<li>《如何变得有思想？》</li>
</ul>
<h2 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h2><ul>
<li>《编写高质量代码：改善Java程序的151个建议》</li>
<li><p>《TCP-IP协议族(第4版)》</p>
</li>
<li><p>《岛上书店》</p>
</li>
<li>《无声告白》</li>
<li>《我的晃荡青春》</li>
<li>《白夜行》</li>
<li>《沉默的大多数》</li>
<li>《世界上的另一个你》</li>
<li>《不抱怨的世界》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://book.douban.com" target="_blank" rel="noopener">豆瓣读书</a></li>
<li><a href="http://www.cnblogs.com/xing901022/p/3694709.html" target="_blank" rel="noopener">他人书单1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/14/书单/" data-id="cjk0gup9e003ua3rjy5f4h1rt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux操作常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/Linux操作常用命令/" class="article-date">
  <time datetime="2017-04-12T02:33:08.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/Linux操作常用命令/">Linux操作常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一些常用的技巧，隔一段时间不用又给淡忘了。</p>
<h3 id="开机启动项"><a href="#开机启动项" class="headerlink" title="开机启动项"></a>开机启动项</h3><ol>
<li>创建服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/disk-space-check.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">After=network.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/disk-space-check.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建脚本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">date &gt; /root/disk_space_report.txt</span><br><span class="line">du -sh /home/ &gt;&gt; /root/disk_space_report.txt</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>设置脚本权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 744 /usr/<span class="built_in">local</span>/bin/disk-space-check.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 664 /etc/systemd/system/disk-space-check.service</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> disk-space-check.service</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启验证下吧</p>
</li>
</ol>
<h3 id="打包压缩、解压"><a href="#打包压缩、解压" class="headerlink" title="打包压缩、解压"></a>打包压缩、解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// .tar.bz2 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jcv -f /root/<span class="built_in">test</span>/etc.tar.bz2 /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -jxv -f  /root/<span class="built_in">test</span>/etc.tar.bz2  -C /tmp/</span></span><br><span class="line"></span><br><span class="line">// .tar.gz 包</span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zcv -f /root/<span class="built_in">test</span>/etc.tar.gz /etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -zxv -f  /root/<span class="built_in">test</span>/etc.tar.gz  -C /tmp/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -sf /usr/local/postgresql-9.2.4 /usr/local/pgsql</span></span><br><span class="line"><span class="comment">## -s: symbole 软链接，-f: force 如果目标链接已经存在则删除重新建立</span></span><br><span class="line"><span class="comment">## 如果9.2.5的版本发布了，升级只需停掉数据库在这里改下软链接地址就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="当前目录-各文件夹-大小-linux"><a href="#当前目录-各文件夹-大小-linux" class="headerlink" title="当前目录 各文件夹 大小 linux"></a>当前目录 各文件夹 大小 linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find $1 -maxdepth 1 | xargs du -sh</span></span><br></pre></td></tr></table></figure>
<h3 id="强制停止应用的两种方式"><a href="#强制停止应用的两种方式" class="headerlink" title="强制停止应用的两种方式"></a>强制停止应用的两种方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;print $2&#125;'|xargs kill -9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef|grep java|grep 'tomcat-web-api'|awk '&#123;system("kill -9 " $2)&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="某次服务器中毒，删除与病毒文件同样大小字节的文件"><a href="#某次服务器中毒，删除与病毒文件同样大小字节的文件" class="headerlink" title="某次服务器中毒，删除与病毒文件同样大小字节的文件"></a>某次服务器中毒，删除与病毒文件同样大小字节的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -size 1223123c | xargs rm -rf</span></span><br></pre></td></tr></table></figure>
<h3 id="find类-其他"><a href="#find类-其他" class="headerlink" title="find类 其他"></a>find类 其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正则匹配删除</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "2016-12-1[2-7]"|xargs rm -rf</span></span><br><span class="line"></span><br><span class="line">// 反向匹配，找出名字不含 <span class="string">"tar"</span> 的文件/文件夹</span><br><span class="line"><span class="comment"># find ./ -maxdepth 1|grep "tar" -v</span></span><br></pre></td></tr></table></figure>
<h3 id="根据进程获取进程号，打印进程的运行信息"><a href="#根据进程获取进程号，打印进程的运行信息" class="headerlink" title="根据进程获取进程号，打印进程的运行信息"></a>根据进程获取进程号，打印进程的运行信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pgrep mysql | xargs -I &#123;&#125; ls -l /proc/&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="crontab-同步时间，"><a href="#crontab-同步时间，" class="headerlink" title="crontab 同步时间，"></a>crontab 同步时间，</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// crontab 分、时、日、月、周</span><br><span class="line">// 10分钟同步一次</span><br><span class="line"><span class="comment"># */10 * * * * /usr/sbin/ntpdate time.windows.com &amp;&amp; hwclock -w</span></span><br></pre></td></tr></table></figure>
<h3 id="输出磁盘的读写情况"><a href="#输出磁盘的读写情况" class="headerlink" title="输出磁盘的读写情况"></a>输出磁盘的读写情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iostat -k 2</span></span><br></pre></td></tr></table></figure>
<h3 id="新增磁盘"><a href="#新增磁盘" class="headerlink" title="新增磁盘"></a>新增磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// fdisk: 操作磁盘分区表</span><br><span class="line">// mkfs：对磁盘分区进行文件系统格式化</span><br><span class="line"></span><br><span class="line">// 列出磁盘装置，找到我们要操作的装置名称，便于对其进行分区</span><br><span class="line"><span class="comment"># fdisk -l </span></span><br><span class="line"></span><br><span class="line">// 开始对磁盘进行分区处理，注意不要加上数字</span><br><span class="line"><span class="comment"># fdisk /dev/xvdb  </span></span><br><span class="line"></span><br><span class="line">// 对分区进行格式化</span><br><span class="line"><span class="comment"># mkfs -t ext4 -c /dev/xvdb1</span></span><br><span class="line"></span><br><span class="line">// 建立磁盘挂载目录</span><br><span class="line"><span class="comment"># mkdir /data</span></span><br><span class="line"></span><br><span class="line">// 手动挂载</span><br><span class="line"><span class="comment"># mount /dev/xvdb1 /data/</span></span><br><span class="line"></span><br><span class="line">// 开机自动挂载</span><br><span class="line"><span class="comment"># echo "/dev/xvdb1 /data/ ext4 defaults 0 0" &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>
<h3 id="看你在Linux下最常用的命令是哪些？"><a href="#看你在Linux下最常用的命令是哪些？" class="headerlink" title="看你在Linux下最常用的命令是哪些？"></a>看你在Linux下最常用的命令是哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | awk <span class="string">'&#123;CMD[$2]++;count++;&#125; END &#123; for (a in CMD )print CMD[ a ]" " CMD[ a ]/count*100 "% " a &#125;'</span> | grep -v <span class="string">"./"</span> | column -c3 -s <span class="string">" "</span> -t |sort -nr | nl | head -n10</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/12/Linux操作常用命令/" data-id="cjk0gup8h002aa3rj0l6b62w6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java多线程编程核心技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/06/java多线程编程核心技术/" class="article-date">
  <time datetime="2017-04-06T06:35:32.000Z" itemprop="datePublished">2017-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/06/java多线程编程核心技术/">java多线程编程核心技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果你认为多线程编程就是一堆的线程在运行一堆的代码，那将会一团糟。程序有时候正常，偶尔又异常，多线程的编程将变的困难。</p>
<p>但是如果你能将线程按需来分配，控制线程间的交互，那问题就变得简单多了。</p>
<p>多线程双刃剑：充分利用多核，复杂度提升，操作共享资源处理不好时会带来线程安全问题。</p>
<p>WEB编程普遍缺乏对多线程的理解：web容器实现，屏蔽了复杂的编程细节，多线程处理，（自己实现一款简单的web容器）</p>
<h2 id="一、Java多线程技能"><a href="#一、Java多线程技能" class="headerlink" title="一、Java多线程技能"></a>一、Java多线程技能</h2><p>Skills:</p>
<ul>
<li>线程的启动</li>
<li>如何使线程暂停</li>
<li>如何是线程停止</li>
<li>线程的优先级</li>
<li>线程安全相关的问题</li>
</ul>
<h3 id="1-1-进程和多线程的概念及线程的优点"><a href="#1-1-进程和多线程的概念及线程的优点" class="headerlink" title="1.1 进程和多线程的概念及线程的优点"></a>1.1 进程和多线程的概念及线程的优点</h3><p>进程是操作系统结构的基础，它是系统进行资源分配和调度的一个独立单位。可以将windows任务管理器的<code>.exe</code>理解成一个进程。<br>线程：线程就是进程中独立的子任务，比如QQ.exe运行时，有视频的线程、下载文件线程、传输数据线程等。<br>优点：在多任务操作系统中效率大大提升。</p>
<h3 id="1-2-使用多线程"><a href="#1-2-使用多线程" class="headerlink" title="1.2 使用多线程"></a>1.2 使用多线程</h3><p>一个进程中至少会有一个线程在运行，比如常见的<code>main</code>函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-1-继承Thread类"><a href="#1-2-1-继承Thread类" class="headerlink" title="1.2.1 继承Thread类"></a>1.2.1 继承Thread类</h4><p>实现多线程的主要方式有两种：一种是继承<code>Thread</code>类，另一种是实现<code>Runnable</code>接口。<br>前者与后者工作时的性质是一样的，继承<code>Thread</code>最大的局限就是不支持多继承.<br>继承实现的方式就是继承<code>Thread</code>类，重写<code>run</code>方法，然后创建线程类实例，调用其<code>start</code>方法即启动了一个线程<br><code>如果多次调用start()方法，则会出现异常 IllegalThreadStateException ..</code></p>
<h4 id="1-2-2-实现Runnable接口"><a href="#1-2-2-实现Runnable接口" class="headerlink" title="1.2.2 实现Runnable接口"></a>1.2.2 实现Runnable接口</h4><p>实现方式：实现<code>Runnable</code>接口并实现<code>run</code>方法</p>
<h4 id="1-2-3-实例变量与线程安全"><a href="#1-2-3-实例变量与线程安全" class="headerlink" title="1.2.3 实例变量与线程安全"></a>1.2.3 实例变量与线程安全</h4><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>; <span class="comment">//实例变量(非static)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">"由 "</span> + Thread.currentThread().getName() + <span class="string">" 计算， count="</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行方式一，不共享数据，运行类Run:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread a = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">        MyThread b = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">        MyThread c = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里共创建了3个线程，每个线程都有自己的count变量，不存在访问同一个实例变量的情况。</p>
<p>运行方式二，共享数据，运行了ShareRun:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareRun</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread threadRun = <span class="keyword">new</span> MyThread(); <span class="comment">// 使用同一个Runnable实现类的实例</span></span><br><span class="line">        </span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(threadRun, <span class="string">"A"</span>); <span class="comment">// 再通过Thread包装</span></span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(threadRun, <span class="string">"B"</span>);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(threadRun, <span class="string">"C"</span>);</span><br><span class="line">        Thread d = <span class="keyword">new</span> Thread(threadRun, <span class="string">"D"</span>);</span><br><span class="line">        Thread e = <span class="keyword">new</span> Thread(threadRun, <span class="string">"E"</span>);</span><br><span class="line">        </span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jvm的i–分3个步骤：</p>
<blockquote>
<ol>
<li>取i值</li>
<li>计算i-1</li>
<li>赋值i</li>
</ol>
</blockquote>
<p>此时多个线程访问<code>threadRun</code>实例的变量出现非线程安全问题，这就是典型的线程问题了。这时通过在<code>run</code>方法前添加<code>synchronized</code>可以解决这种问题。<br><code>synchronized</code>可以在任意对象及方法上加锁。<br>多个线程执行<code>run</code>时，以排队的方式执行，先判断<code>run</code>方法有没有上锁，如果有上锁说明其他线程正在执行，等待其他线程执行。线程尝试拿锁，如果没有<br>拿所锁，这个线程就会不断的尝试拿这把锁，直到拿到为止。</p>
<h4 id="1-2-4-注意count–与System-out-println-异常"><a href="#1-2-4-注意count–与System-out-println-异常" class="headerlink" title="1.2.4 注意count–与System.out.println()异常"></a>1.2.4 注意count–与System.out.println()异常</h4><p>将上面代码里面<code>count--</code> 放置到<code>System.out.println()</code>中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"由 "</span> + Thread.currentThread().getName() + <span class="string">" 计算， count="</span> + (count--));</span><br></pre></td></tr></table></figure></p>
<p>我们注意下在jdk的源码中<code>System.out.println()</code>这个方法内部是有<code>synchronized</code>的，说明这个方法是线程安全。<br>但是上面的代码也会发生非线程安全问题，因为<code>count--</code>这个计算是在<code>println</code>方法前执行的，这个有点类似<code>scala</code>的求值策略的<code>Call by Value</code>，<br>先会将形参计算出来 ，再进入方法中。</p>
<h3 id="1-3-currentThread-方法"><a href="#1-3-currentThread-方法" class="headerlink" title="1.3 currentThread()方法"></a>1.3 currentThread()方法</h3><p><code>currentThread()</code>方法可以返回代的段正被哪个线程所执行，可以在线程类的run方法打印执行线程的名称，然后在外部分别使用线程的<code>start</code>和<code>run</code>方法执行对比查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-isAlive-方法"><a href="#1-4-isAlive-方法" class="headerlink" title="1.4 isAlive()方法"></a>1.4 isAlive()方法</h3><p><code>isAlive()</code> 方法是用来判断线程是否属于活动状态，活动状态即<code>线程已经启动且位尚未终止</code></p>
<h3 id="1-5-sleep-方法"><a href="#1-5-sleep-方法" class="headerlink" title="1.5 sleep()方法"></a>1.5 sleep()方法</h3><p><code>sleep()</code>方法是用来让线程暂停指定的时间。</p>
<h3 id="1-6-getId-方法"><a href="#1-6-getId-方法" class="headerlink" title="1.6 getId()方法"></a>1.6 getId()方法</h3><p><code>getId()</code>方法用来获取线程的唯一标识。</p>
<h3 id="1-7-停止线程"><a href="#1-7-停止线程" class="headerlink" title="1.7 停止线程"></a>1.7 停止线程</h3><p>停止线程是在多线程开发时重要的技术点，它不想循环中的break简单粗暴，需要一些技巧性的处理，处理好一些身后事(关闭资源连接、事务)才停止线程。<br><code>Thread.stop()</code>可以停止一个线程，但不建议使用它，这个方法是不安全的。<br>大多数停止一个线程的操作使用的是<code>Thread.interrupt()</code>，尽管方法名称是终止、停止的意思，但这个方法不会终止一个正在运行的线程，需要加入一些判断才可以完成线程的停止。<br>3种终止正在运行的线程的方法：</p>
<ol>
<li>使用退出标志，使程序正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止，但是不推荐使用，stop、suspend、resume都是作废过期的方法，使用它们可能会产生意料不到的结果。（强制性停止可能使一些清理工作得不到完成。）</li>
<li>使用interrupt方法，程序判断isInterrupted，使用throw/return来中断线程，推荐“抛异常”方式</li>
</ol>
<h4 id="1-7-1-停止不了的线程"><a href="#1-7-1-停止不了的线程" class="headerlink" title="1.7.1 停止不了的线程"></a>1.7.1 停止不了的线程</h4><p>下面的例子演示了<code>interrupt</code>停止不了线程的现象：<br>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread  t = <span class="keyword">new</span> MyThread();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终控制台还是打印了50万行，没有停止住线程。</p>
<h4 id="1-7-2-判断线程是否是停止状态"><a href="#1-7-2-判断线程是否是停止状态" class="headerlink" title="1.7.2 判断线程是否是停止状态"></a>1.7.2 判断线程是否是停止状态</h4><p>我们来看下如何判断线程状态不是停止的。Thread提供了两种方法：</p>
<ol>
<li>Thread.interrupted: 测试当前线程是否已经中断，执行后将状态标识清除为false的功能。</li>
<li>this.isInterrupted: 测试当前线程是否已经中断，但不清除状态标志。</li>
</ol>
<p>可以参考: <a href="http://blog.csdn.net/z69183787/article/details/25076033" target="_blank" rel="noopener">interrupt、interrupted 、isInterrupted 区别</a></p>
<h4 id="1-7-3-能停止的线程——异常法"><a href="#1-7-3-能停止的线程——异常法" class="headerlink" title="1.7.3 能停止的线程——异常法"></a>1.7.3 能停止的线程——异常法</h4><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//每次获取标识判断</span></span><br><span class="line">                System.out.println(<span class="string">"已经有了停止标识，我要退出了！"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//手动break</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"for 循环后面的代码被输出，线程其实未被停止。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的线程其实未真正停止，下面在接着改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//每次获取标识判断</span></span><br><span class="line">                    System.out.println(<span class="string">"已经有了停止标识，我要退出了！"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 改为 抛出异常的方式</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"for 循环后面的代码被输出，线程其实未被停止。--不会再输出"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入线程类的catch，线程终止"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-8-暂停、恢复线程"><a href="#1-8-暂停、恢复线程" class="headerlink" title="1.8 暂停、恢复线程"></a>1.8 暂停、恢复线程</h3><p>使用<code>suspend()</code>方法暂停线程，使用<code>resume()</code>方法恢复线程执行。</p>
<h4 id="1-8-1-测试"><a href="#1-8-1-测试" class="headerlink" title="1.8.1 测试"></a>1.8.1 测试</h4><p>演示功能效果，起到暂停、恢复效果，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeTest.java" target="_blank" rel="noopener">SuspendResumeTest.java</a></p>
<h4 id="1-8-2-suspend与resume方法的缺点——独占"><a href="#1-8-2-suspend与resume方法的缺点——独占" class="headerlink" title="1.8.2 suspend与resume方法的缺点——独占"></a>1.8.2 suspend与resume方法的缺点——独占</h4><p>线程类内部锁，独占，此类的其他线程实例也被阻塞，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeDealLock.java" target="_blank" rel="noopener">SuspendResumeDealLock.java</a></p>
<p>公共锁同步对象被独占，造成主线程阻塞，例如<code>println</code>方法，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeLockStop.java" target="_blank" rel="noopener">SuspendResumeLockStop.java</a><br>注释掉除线程内部的<code>println</code>方法后面的代码即恢复执行。</p>
<h4 id="1-8-3-suspend与resume方法的缺点——不同步"><a href="#1-8-3-suspend与resume方法的缺点——不同步" class="headerlink" title="1.8.3 suspend与resume方法的缺点——不同步"></a>1.8.3 suspend与resume方法的缺点——不同步</h4><p>使用<code>suspend</code>与<code>resume</code>方法时容易出现因为线程的暂停而导致数据不同步的情况。</p>
<p>值不同步的情况，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SuspendResumeNoSameValue.java" target="_blank" rel="noopener">SuspendResumeNoSameValue.java</a> </p>
<h3 id="1-9-yiled-方法"><a href="#1-9-yiled-方法" class="headerlink" title="1.9 yiled 方法"></a>1.9 yiled 方法</h3><p><code>yield()</code>方法的作用是放弃当前<code>CPU</code>资源，放弃时间不确定，有可能刚放弃，马上又获得了CPU时间片。</p>
<p>去除注释前后对比测试下吧，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/YieldTest.java" target="_blank" rel="noopener">YieldTest.java</a> </p>
<h3 id="1-10-线程优先级"><a href="#1-10-线程优先级" class="headerlink" title="1.10 线程优先级"></a>1.10 线程优先级</h3><p>线程可以划分优先级，优先级高的线程得到的<code>CPU</code>资源角度，也就是CPU优先执行优先级较高的线程对象中的任务。<code>java</code>中优先级设置中定义的几个常量：<code>MIN_PRIORITY=1</code>、<code>NORM_PRIORITY=5</code>、<code>MAX_PRIORITY=10</code>，设置小于1或者大于10将会抛出<code>IllegalArgumentException</code></p>
<h4 id="1-10-1-优先级的继承性"><a href="#1-10-1-优先级的继承性" class="headerlink" title="1.10.1 优先级的继承性"></a>1.10.1 优先级的继承性</h4><p><code>java</code>中，线程的优先级具有有继承性，比如<code>A线程</code><del>启动</del><strong>创建了</strong>了<code>B线程</code>，则<code>B线程</code>的优先级与<code>A线程</code>是一样的。</p>
<p>继承特性，上面写道了<code>创建了</code>，可以将<code>创建 t1</code>调换值至<code>设置main优先级之前</code>测试下，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PriorityInheritanceTest.java" target="_blank" rel="noopener">PriorityInheritanceTest.java</a> </p>
<h4 id="1-10-1-优先级具有规则性"><a href="#1-10-1-优先级具有规则性" class="headerlink" title="1.10.1 优先级具有规则性"></a>1.10.1 优先级具有规则性</h4><p>高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部执行完。</p>
<h3 id="1-11-守护线程"><a href="#1-11-守护线程" class="headerlink" title="1.11 守护线程"></a>1.11 守护线程</h3><p>在<code>Java</code>进程中有两种线程，一种是用户线程，一种是守护线程。</p>
<p>守护线程的特性有“陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。</p>
<p>守护进程，测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/DaemonTest.java" target="_blank" rel="noopener">DaemonTest.java</a> , 理解：用户线程 main都结束了，守护线程们已经没有什么可守护的了，就结束了</p>
<h2 id="对象及变量的并发访问"><a href="#对象及变量的并发访问" class="headerlink" title="对象及变量的并发访问"></a>对象及变量的并发访问</h2><p>Skills:</p>
<ul>
<li><code>synchronized</code>监视<code>Object</code>的使用</li>
<li><code>synchronized</code>监视<code>Class</code>的使用</li>
<li>非线程安全是如何出现的</li>
<li>关键字<code>volatile</code>的主要作用</li>
<li>关键字<code>volatile</code>与<code>synchronized</code>的区别及使用情况</li>
</ul>
<h3 id="2-1-synchronized同步方法"><a href="#2-1-synchronized同步方法" class="headerlink" title="2.1 synchronized同步方法"></a>2.1 synchronized同步方法</h3><p>多线程并发访问共享资源，很可能发生“非线程安全”题，产生的后果就是”脏读”。而“线程安全”就是获得的资源是经过同步处理的，不会出现脏读现象。</p>
<h4 id="2-1-1-方法内的变量为线程安全"><a href="#2-1-1-方法内的变量为线程安全" class="headerlink" title="2.1.1 方法内的变量为线程安全"></a>2.1.1 方法内的变量为线程安全</h4><p>方法内的变量不存在线程安全问题，永远都是线程安全的，这是方法内部的变量私有的特性造成的。</p>
<h4 id="2-1-2-实例变量非线程安全"><a href="#2-1-2-实例变量非线程安全" class="headerlink" title="2.1.2 实例变量非线程安全"></a>2.1.2 实例变量非线程安全</h4><p>多个线程访问一个实例中变量发生线程安全问题, 测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadSafetyProblem.java" target="_blank" rel="noopener">ThreadSafetyProblem.java</a></p>
<h4 id="2-1-3-多个对象多个锁"><a href="#2-1-3-多个对象多个锁" class="headerlink" title="2.1.3 多个对象多个锁"></a>2.1.3 多个对象多个锁</h4><p><strong>关键字<code>synchronized</code>取的锁都是对象锁，而不是把一段代码或方法当作锁</strong></p>
<p>两个线程访问同一个类的的不同实例的相同同步方法，因为创建了不同的实例，系统将根据实例个数产生锁。测试类: <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoObjectTwoLock.java" target="_blank" rel="noopener">TwoObjectTwoLock.java</a></p>
<h4 id="2-1-4-synchronized-方法与锁对象"><a href="#2-1-4-synchronized-方法与锁对象" class="headerlink" title="2.1.4 synchronized 方法与锁对象"></a>2.1.4 synchronized 方法与锁对象</h4><ul>
<li><code>A线程</code>先持有<code>object</code>对象的<code>Lock</code>锁，<code>B线程</code>可以调用<code>object</code>对象中的非<code>synchronized</code>类型的方法。</li>
<li><code>A线程</code>先持有<code>object</code>对象的<code>Lock</code>锁，<code>B线程</code>调用<code>object</code>对象中的<code>synchronized</code>类型的方法则需等待，也就是同步。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SynchronizedMethodLockObject.java" target="_blank" rel="noopener">SynchronizedMethodLockObject.java</a></p>
<h4 id="2-1-5-脏读"><a href="#2-1-5-脏读" class="headerlink" title="2.1.5 脏读"></a>2.1.5 脏读</h4><p>脏读出现在不同线程“争抢”实例变量的结果，即<code>2.1.4</code>中非同步方法随时可取共享资源就会造成脏读。</p>
<h4 id="2-1-6-synchronized-锁重入"><a href="#2-1-6-synchronized-锁重入" class="headerlink" title="2.1.6 synchronized 锁重入"></a>2.1.6 synchronized 锁重入</h4><p>线程进入<code>synchronized</code>方法调用本对象的另一个<code>synchronized</code>方法时，是永远可以得到锁的。即进入<code>synchronized</code>方法后可以无阻塞畅游本实例的所有方法了(当然这里不包括访问其他实例的<code>synchronized</code>方法)</p>
<h4 id="2-1-7-出现异常，锁自动释放"><a href="#2-1-7-出现异常，锁自动释放" class="headerlink" title="2.1.7 出现异常，锁自动释放"></a>2.1.7 出现异常，锁自动释放</h4><p>当一个线程执行代码出现异常时，其所持有的锁会自动释放。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ExceptionAutoReleaseLock.java" target="_blank" rel="noopener">ExceptionAutoReleaseLock.java</a></p>
<h4 id="2-1-8-同步不具有继承性"><a href="#2-1-8-同步不具有继承性" class="headerlink" title="2.1.8 同步不具有继承性"></a>2.1.8 同步不具有继承性</h4><p>子类重写父类的<code>synchronized</code>方法，如果该方法不添加<code>synchronized</code>标识，此方法将不再具有同步的特性。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncNotExtends.java" target="_blank" rel="noopener">SyncNotExtends.java</a></p>
<h3 id="2-2-synchronized-同步语句块"><a href="#2-2-synchronized-同步语句块" class="headerlink" title="2.2 synchronized 同步语句块"></a>2.2 synchronized 同步语句块</h3><p>多个线程访问同一个对象中的<code>synchronized(this)</code>同步代码块时，一段时间内只能有一个线程被执行，其他线程需要等待当前线程完成这个代码块的执行。我们来对比下，同步方法与同步块</p>
<p>同步方法，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncMethod.java" target="_blank" rel="noopener">SyncMethod.java</a></p>
<p>我们分析可以发现<code>doLongTimeTask</code>方法里面，只是对<code>getData1</code>、<code>getData2</code>赋值做了对<strong>共享资源</strong>的操作，之前部分的耗时操作不依赖<strong>共享资源</strong>，这部分代码完全可以<code>非同步</code>率先执行，所以修改方法，可以让方法内部达到<code>一般异步，一半同步</code>的效果。</p>
<p>同步块，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncBlock.java" target="_blank" rel="noopener">SyncBlcok.java</a></p>
<p>完成同样的效果，后者花费的时间缩短了50%；</p>
<h4 id="2-2-1-synchronized-方法的弊端"><a href="#2-2-1-synchronized-方法的弊端" class="headerlink" title="2.2.1 synchronized 方法的弊端"></a>2.2.1 synchronized 方法的弊端</h4><h4 id="2-2-2-synchronized-同步代码块的使用"><a href="#2-2-2-synchronized-同步代码块的使用" class="headerlink" title="2.2.2 synchronized 同步代码块的使用"></a>2.2.2 synchronized 同步代码块的使用</h4><h4 id="2-2-3-用同步方法解决同步方法的弊端"><a href="#2-2-3-用同步方法解决同步方法的弊端" class="headerlink" title="2.2.3 用同步方法解决同步方法的弊端"></a>2.2.3 用同步方法解决同步方法的弊端</h4><h4 id="2-2-4-一半异步，一半同步"><a href="#2-2-4-一半异步，一半同步" class="headerlink" title="2.2.4 一半异步，一半同步"></a>2.2.4 一半异步，一半同步</h4><p>其实上面提到的几点，上面的例子都已经体现了</p>
<p>同步方法弊端：也就是方法内部的代码，眉毛胡子一把抓，不区分“必须同步”与“可以异步”的代码将其“同步”的方式来执行，这样方法持锁时间更长，耗时更久。</p>
<p>同步块代码的使用：分析代码，区分<code>必须同步</code>与<code>可以非同步</code>，将同步代码加上<code>synchronized</code>。</p>
<h4 id="2-2-5-synchronized-代码块的同步性"><a href="#2-2-5-synchronized-代码块的同步性" class="headerlink" title="2.2.5 synchronized 代码块的同步性"></a>2.2.5 synchronized 代码块的同步性</h4><p>使用<code>synchronized(this)</code>代码块时，当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>方法时，其他线程访问对<code>object</code>其他所有的<code>synchronized(this)</code>方法访问将会阻塞。</p>
<h4 id="2-2-6-synchronized-this-代码是锁定当前对象的"><a href="#2-2-6-synchronized-this-代码是锁定当前对象的" class="headerlink" title="2.2.6 synchronized(this) 代码是锁定当前对象的"></a>2.2.6 synchronized(this) 代码是锁定当前对象的</h4><h4 id="2-2-7-将任意对象作为对象监视器"><a href="#2-2-7-将任意对象作为对象监视器" class="headerlink" title="2.2.7 将任意对象作为对象监视器"></a>2.2.7 将任意对象作为对象监视器</h4><p><code>synchronized</code>方法与<code>synchronized(this)</code>都具有：</p>
<ol>
<li>对其他<code>synchronized</code>方法与<code>synchronized(this)</code>同步块调用呈阻塞状态</li>
<li>同一时间只有一个线程执行当前<code>synchronized</code>方法块或<code>synchronized(this)</code>中的代码</li>
</ol>
<p><code>java</code>中支持对<code>任意对象</code>(注意此处是对象，基础的值类型可是不行的哦)作为“对象监视器”来实现同步功能，使用格式 <code>synchronized(非this)</code></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncBlockString.java" target="_blank" rel="noopener">SyncBlockString.java</a></p>
<h4 id="2-2-8-细化验证3个结论"><a href="#2-2-8-细化验证3个结论" class="headerlink" title="2.2.8 细化验证3个结论"></a>2.2.8 细化验证3个结论</h4><p><code>synchronized(非this对象x)</code>即意味着将对象<code>x</code>作为<code>对象监视器</code>，可以得出以下3个结论：</p>
<ol>
<li>多个线程同时执行<code>synchronized(x)</code>代码块时呈同步效果</li>
<li>其他线程执行<code>x</code>对象中的<code>synchronized</code>同步方法时呈同步效果</li>
<li>其他线程执行<code>x</code>对象中的<code>synchronized(this)</code>代码块时呈同步效果 （2、3点是<code>x</code>对象中本身还有相关的同步方法）</li>
</ol>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncLockObjInsideSyncMethod.java" target="_blank" rel="noopener">SyncLockObjInsideSyncMethod.java</a></p>
<h4 id="2-2-9-静态同步synchronized方法与synchronized-class-代码块"><a href="#2-2-9-静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="2.2.9 静态同步synchronized方法与synchronized(class)代码块"></a>2.2.9 静态同步synchronized方法与synchronized(class)代码块</h4><p><code>synchronized</code>可以应用在<code>static</code>静态方法上，这样表示对当前的<code>XX.java</code>文件对应的<code>Class</code>类进行持锁，等同于<code>synchronized(XX.class)</code>，会从<code>class</code>级别全局阻塞<code>class</code>锁，但不会阻塞实例的同步方法（非静态同步方法）。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/SyncStaticMethod.java" target="_blank" rel="noopener">SyncStaticMethod.java</a></p>
<h4 id="2-2-10-数据类型String的常量池特性"><a href="#2-2-10-数据类型String的常量池特性" class="headerlink" title="2.2.10 数据类型String的常量池特性"></a>2.2.10 数据类型String的常量池特性</h4><p><code>JVM</code>具有<code>String</code>常量池缓存的功能，所以使用<code>String</code>作为监控锁对象不小心时可能会带来一些意外。所以一般<code>synchronized</code>代码块不使用<code>String</code>,改用其他如<code>new Object()</code>。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/StringConstantTrait.java" target="_blank" rel="noopener">StringConstantTrait.java</a></p>
<h4 id="2-2-11-同步sychronized方法无限等待与解决"><a href="#2-2-11-同步sychronized方法无限等待与解决" class="headerlink" title="2.2.11 同步sychronized方法无限等待与解决"></a>2.2.11 同步sychronized方法无限等待与解决</h4><p>同步方法容易造成死循环，让其他线程得不到运行机会。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoStop.java" target="_blank" rel="noopener">TwoStop.java</a></p>
<p>这个其实还得与具体的业务分析，不同的同步方法，是否涉及同一个资源访问的读写，如果不涉及则可以使用不同的”监控锁对象”（以上举例的测试类，在真正的业务场景中基本不会这样）</p>
<p>比如按业务不同，定义不同的锁对象，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoStopMultiLockObj.java" target="_blank" rel="noopener">TwoStopMultiLockObj.java</a></p>
<h4 id="2-2-12-多线程的死锁"><a href="#2-2-12-多线程的死锁" class="headerlink" title="2.2.12 多线程的死锁"></a>2.2.12 多线程的死锁</h4><p><code>java</code>线程死锁是一个经典的问题，造成的原因是不同的线程在等待不可能被释放的锁。</p>
<p>这里我自己脑补了一个来帮助理解死锁的例子:</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/DeadLockTest.java" target="_blank" rel="noopener">DeadLockTest.java</a></p>
<p>死锁是因为<code>阿毛</code>：<code>先锁坑位，再锁纸</code>不走寻常人的路，<code>阿毛他爹</code>、<code>阿毛麻麻</code>是：<code>先锁纸，再锁坑位</code>，导致<code>阿毛全家</code>都不能正常上厕所了。 如果注释掉<code>阿毛</code>，其他人都能正常排队的上厕所，反之注释掉其他人，<code>阿毛</code>一个人也玩的转，他们同时来就会发生死锁。</p>
<p>避免死锁：<strong>对多个资源(数据库表、对象)同时加锁时，需要保持一致的加锁顺序</strong></p>
<p>运行程序后可以看到应用<code>假死</code>了，这是我们可以用<code>jps</code> 查看下运行的<code>java</code>进程的信息，得到<code>pid</code>，然后使用 <code>jstack -l pid</code>，可以看出<code>线程</code>在等待哪个对象的锁，而这把锁现在正被哪个线程锁持有，可以看出这里的死锁就是两个线程互相持有了对方等待的锁。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps </span></span><br><span class="line">    -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</span><br><span class="line">    -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</span><br><span class="line">    -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</span><br><span class="line">    -v : 详细信息</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> jstack</span></span><br><span class="line">    -l</span><br></pre></td></tr></table></figure>
<h4 id="2-2-13-内置类与静态内置类"><a href="#2-2-13-内置类与静态内置类" class="headerlink" title="2.2.13 内置类与静态内置类"></a>2.2.13 内置类与静态内置类</h4><p>内部类依赖其外部类实例来实例化：<code>new External().new InnerClass()</code>， 静态内部类则可以直接：<code>new InnerStaticClass()</code>，实例化时不依赖外部类实例</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ExternalClass.java" target="_blank" rel="noopener">ExternalClass.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunTestExternalClass.java" target="_blank" rel="noopener">RunTestExternalClass.java</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 内部类， 把类比喻成一个鸡蛋，内部类是蛋黄，外部类是蛋壳</span><br><span class="line">// 普通内部类(非static) 那相当于生鸡蛋，没有鸡蛋壳（外部类没有实例化），蛋黄也就不复存在 ----- 生鸡蛋： 壳之不存，黄之焉附</span><br><span class="line">// 内部静态类 , 相当于熟鸡蛋，没有鸡蛋壳，蛋黄也可以是完好的（可以实例化）， -----  熟鸡蛋：唇亡齿寒 ，照样可以嚼东西（没有蛋壳，蛋黄可以用来做卤蛋呀...）</span><br><span class="line"></span><br><span class="line">// 内部类没有 `public`标识时，只有在同一个包的其他类可访问、实例化</span><br></pre></td></tr></table></figure>
<h4 id="2-2-14-内置类与同步：实验1"><a href="#2-2-14-内置类与同步：实验1" class="headerlink" title="2.2.14 内置类与同步：实验1"></a>2.2.14 内置类与同步：实验1</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/OutClzSyncTest.java" target="_blank" rel="noopener">OutClzSyncTest.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunOutClzSyncTest.java" target="_blank" rel="noopener">RunOutClzSyncTest.java</a></p>
<p>这里很好理解，由于<code>method1</code>与<code>method2</code>持有不同的“对象监视器”，所以他们是异步非阻塞，打印结果是乱序的。</p>
<h4 id="2-2-15-内置类与同步：实验2"><a href="#2-2-15-内置类与同步：实验2" class="headerlink" title="2.2.15 内置类与同步：实验2"></a>2.2.15 内置类与同步：实验2</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/OutClzSyncTest2.java" target="_blank" rel="noopener">OutClzSyncTest2.java</a> 、<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/RunOutClzSyncTest2.java" target="_blank" rel="noopener">RunOutClzSyncTest2.java</a></p>
<p>这里用我们上面学到知识就可以理解了，A1、A2 使用了不同锁，非阻塞异步执行，A1、B1争抢一把锁，A1释放锁后B1才可拿锁执行。</p>
<h4 id="2-2-16-锁对象的改变"><a href="#2-2-16-锁对象的改变" class="headerlink" title="2.2.16 锁对象的改变"></a>2.2.16 锁对象的改变</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ChangeLockString.java" target="_blank" rel="noopener">ChangeLockString.java</a></p>
<p>从测试类发现：A、B线程锁对象<code>lock</code>，就算值发生了改变，他们持有的锁都是“123”，还是起到了同步的效果，C、D线程进一步验证了只要对象不变，即使对象的属性被改变，其运行结果还是同步的。</p>
<h3 id="2-3-volatile-关键字"><a href="#2-3-volatile-关键字" class="headerlink" title="2.3 volatile 关键字"></a>2.3 volatile 关键字</h3><p><code>volatile</code>关键字的主要作用是使变量在多个线程间可见。强制从<strong>公共堆栈</strong>中取得变量值，而不是从<strong>线程私有数据</strong>取得变量的值</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/VolatileCompare.java" target="_blank" rel="noopener">VolatileCompare.java</a></p>
<p>测试类输出结果可以看出，没有<code>volatile</code>标识的变量，<code>threadA</code>根本不理会主线程对这个变量的修改，线程会一直运行；而依赖<code>volatile</code>修饰变量运行的线程，可以得到主线程的修改，线程得以正常退出。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fecy1qtlzuj20aq06igll.jpg" alt="-server为了线程效率，从私有堆栈中取值"></p>
<p><img src="http://wx2.sinaimg.cn/mw690/929194b4gy1fecy1qe6l5j206w056jrc.jpg" alt="volate强制从公共堆栈中取值"></p>
<h4 id="2-3-1-关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行"><a href="#2-3-1-关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行" class="headerlink" title="2.3.1 关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行"></a>2.3.1 关键字volatile与死循环–单线程死循环，下一步的停止标识设置没有机会执行</h4><h4 id="2-3-2-解决同步死循环–-多线程解决，新启线程来设置停止标识"><a href="#2-3-2-解决同步死循环–-多线程解决，新启线程来设置停止标识" class="headerlink" title="2.3.2 解决同步死循环–(多线程解决，新启线程来设置停止标识)"></a>2.3.2 解决同步死循环–(多线程解决，新启线程来设置停止标识)</h4><h4 id="2-3-3-解决异步死循环–-server-不读取主堆栈问题，使用volatile解决，强制读主堆栈内存"><a href="#2-3-3-解决异步死循环–-server-不读取主堆栈问题，使用volatile解决，强制读主堆栈内存" class="headerlink" title="2.3.3 解决异步死循环–(-server 不读取主堆栈问题，使用volatile解决，强制读主堆栈内存)"></a>2.3.3 解决异步死循环–(-server 不读取主堆栈问题，使用volatile解决，强制读主堆栈内存)</h4><h4 id="2-3-4-volatile-非原子的特性"><a href="#2-3-4-volatile-非原子的特性" class="headerlink" title="2.3.4 volatile 非原子的特性"></a>2.3.4 volatile 非原子的特性</h4><p>虽然<code>volatile</code>虽然实现了共享资源在多个线程间的可见性，但它却不具备同步性，那么也就不具备原子性(个人理解：变量本身没有原子性，对变量的操作才有原子性一说)。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/CounterVolatileUnsafe.java" target="_blank" rel="noopener">CounterVolatileUnsafe.java</a></p>
<p><code>volatile</code>只是增加了多线程间共享资源的透明度，上面的执行结果有可能出现的是你的期望值<code>10000</code>，这只是提高了他出现的几率，这也体现了线程安全问题的难以测试和问题偶发性。</p>
<h4 id="2-3-5-使用原子类进行i-操作"><a href="#2-3-5-使用原子类进行i-操作" class="headerlink" title="2.3.5 使用原子类进行i++ 操作"></a>2.3.5 使用原子类进行i++ 操作</h4><p>从jdk1.5起开始提供了<code>AtomicXX</code>的一些原子类，这些类是乐观锁的一种CAS(Compare And Swap)的实现，其利用JNI调用CPU指令实现。</p>
<p>主要提供了：<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>供基础数据类型的操作，<code>AtomicReference&lt;V&gt;</code>对象数据操作，<code>AtomicStampedRefrence&lt;V&gt;</code>来操作对象并解决<code>ABA</code>的问题</p>
<p><code>AtomicInteger</code>完成i++, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/AtomicIntegerTest.java" target="_blank" rel="noopener">AtomicIntegerTest.java</a><br><code>AtomicReference&lt;V&gt;</code>模拟栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/stackAtomVsSync/AtomicStack.java" target="_blank" rel="noopener">AtomicStack.java</a><br><code>AtomicStampedRefrence&lt;V&gt;</code>解决ABA问题，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/CAS/ABA.java" target="_blank" rel="noopener">ABA.java</a></p>
<h4 id="2-3-6-原子类也并不完全安全"><a href="#2-3-6-原子类也并不完全安全" class="headerlink" title="2.3.6 原子类也并不完全安全"></a>2.3.6 原子类也并不完全安全</h4><p>这里其实主要说明的是多个原子类方法间是不安全的，单个原子类方法没有问题。</p>
<h4 id="2-3-7-synchronized-代码块有volatile同步的功能"><a href="#2-3-7-synchronized-代码块有volatile同步的功能" class="headerlink" title="2.3.7 synchronized 代码块有volatile同步的功能"></a>2.3.7 synchronized 代码块有volatile同步的功能</h4><p>关键字<code>synchronized</code>可以使多个线程访问同一个资源具有同步性，而且还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Skills:</p>
<ul>
<li>使用<code>wait/notify</code> 实现线程间的通信</li>
<li>生产者/消费者模式的实现</li>
<li>方法<code>join</code>的使用</li>
<li><code>ThreadLocal</code>的使用</li>
</ul>
<h3 id="3-1-等待-通知机制"><a href="#3-1-等待-通知机制" class="headerlink" title="3.1 等待/通知机制"></a>3.1 等待/通知机制</h3><p>线程与线程之间不是独立的个体，他们彼此之间可以互相通信和协作。</p>
<h4 id="3-1-1-不使用等待-通知机制实现线程间通信"><a href="#3-1-1-不使用等待-通知机制实现线程间通信" class="headerlink" title="3.1.1 不使用等待/通知机制实现线程间通信"></a>3.1.1 不使用等待/通知机制实现线程间通信</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TwoThreadTransData.java" target="_blank" rel="noopener">TwoThreadTransData.java</a></p>
<p>线程<code>thread-b</code>循环中不断检测一个条件，轮循时间小，会造成浪费CPU资源，轮循间隔大时，响应不会实时。 所以要出现了<code>wait/notify</code>机制。</p>
<h4 id="3-1-2-什么是等待-通知机制"><a href="#3-1-2-什么是等待-通知机制" class="headerlink" title="3.1.2 什么是等待/通知机制"></a>3.1.2 什么是等待/通知机制</h4><p>比如：<code>厨师</code>完成一道菜的时间不确定，<code>服务员</code>需要将这道菜，送给就餐者。</p>
<p>如果不是“等待/通知”机制：<code>服务员</code>不断的询问<code>厨师</code>菜完成了没…</p>
<p>有了“等待/通知”机制择时：<code>服务员</code>坐等(wait)，<code>厨师</code>完成菜品即告诉(notify)<code>服务员</code>。</p>
<h4 id="3-1-3-等待-通知机制的实现"><a href="#3-1-3-等待-通知机制的实现" class="headerlink" title="3.1.3 等待/通知机制的实现"></a>3.1.3 等待/通知机制的实现</h4><p><strong><code>wait</code>使线程暂停执行，而<code>notify</code>唤醒其他线程继续执行</strong></p>
<p><code>wait()</code>方法使当前执行代码的线程进行等待，<code>wait()</code>方法是<code>Object</code>类的方法，该方法将当前线程置入“预执行队列中”，并且在<code>wait()</code>所在代码处停止，直到接到通知或被中断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用`wait()`方法前必须获得该对象实例的锁，即只能再锁对象实例的同步代码内中调用`wait()`方法，否则将抛出`IllegalMonitorStateException`，`wait()`方法后，当前线程释放该对象实例的锁。</span><br></pre></td></tr></table></figure></p>
<p><code>notify()</code>方法也需要或得对象实例的锁，该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则有线程规划器随机挑出一个呈<code>wait</code>状态的线程，对其发出通知notify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行`notify()`方法后，当前线程不会马上释放该对象的锁，呈wait状态的锁不会马上获得锁，而是要等执行`notify()`方法所在同步块执行完。</span><br></pre></td></tr></table></figure></p>
<p>简单体现<code>wait/notify</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/TestWaitNotify.java" target="_blank" rel="noopener">TestWaitNotify.java</a></p>
<p>实现之前提到的<code>当公共变量==5时退出一个线程</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitNotifyWhen5.java" target="_blank" rel="noopener">WaitNotifyWhen5.java</a></p>
<p><strong>`运行–就绪–等待</strong>  （用单核cpu的方式去立即：同一时刻只有一个线程被执行，所以有了就绪队列）`:<br><strong>每个锁对象都有两个队列，一个是就绪队列(竞争锁)，一个是阻塞队列(wait待唤醒)。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒</strong></p>
<p>关于<code>就绪队列</code>与<code>阻塞队列</code>顺序相关</p>
<ol>
<li>就绪队列，进入方法的顺序与竞争得到锁的顺序，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/CompeteOrder.java" target="_blank" rel="noopener">CompeteOrder.java</a></li>
<li>阻塞队列，wait触发的顺序与被唤醒的顺序，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitOrder.java" target="_blank" rel="noopener">WaitOrder.java</a></li>
</ol>
<h4 id="3-1-4-方法wait-锁释放与notify-方法锁不释放"><a href="#3-1-4-方法wait-锁释放与notify-方法锁不释放" class="headerlink" title="3.1.4 方法wait()锁释放与notify()方法锁不释放"></a>3.1.4 方法wait()锁释放与notify()方法锁不释放</h4><p>当方法<code>wait()</code>被执行后，锁自动释放，但执行完<code>notify()</code>方法，锁是不自动释放的，还有在同步代码块内<code>sleep()</code>方法也是不会释放锁的。 这些其实在上面的例子中都已经有体现了。</p>
<h4 id="3-1-5-当interrup方法遇到wait方法"><a href="#3-1-5-当interrup方法遇到wait方法" class="headerlink" title="3.1.5 当interrup方法遇到wait方法"></a>3.1.5 当interrup方法遇到wait方法</h4><p>当线程呈<code>wait</code>状态时，调用线程对象的<code>interrupt()</code>方法会出现<code>InterruptedException</code>异常。</p>
<h4 id="3-1-6-只通知一个线程"><a href="#3-1-6-只通知一个线程" class="headerlink" title="3.1.6 只通知一个线程"></a>3.1.6 只通知一个线程</h4><p>调用<code>notify()</code>方法一次只<del>随机</del>(wait队列poll出一个)通知一个线程进行唤醒。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/NotifyOne.java" target="_blank" rel="noopener">NotifyOne.java</a></p>
<h4 id="3-1-7-唤醒所有线程"><a href="#3-1-7-唤醒所有线程" class="headerlink" title="3.1.7 唤醒所有线程"></a>3.1.7 唤醒所有线程</h4><p>调用<code>notifyAll()</code>方法将唤醒wait队列中的所有线程。</p>
<h4 id="3-1-8-方法wait-long-的使用"><a href="#3-1-8-方法wait-long-的使用" class="headerlink" title="3.1.8 方法wait(long)的使用"></a>3.1.8 方法wait(long)的使用</h4><p>带一个参数<code>wait(long)</code>方法的功能是等待指定的时间，如果指定时间内没有被<code>notify</code>将自动苏醒。</p>
<p>无人唤醒，自动苏醒，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitHasParamMethod.java" target="_blank" rel="noopener">WaitHasParamMethod.java</a></p>
<h4 id="3-1-9-通知过早"><a href="#3-1-9-通知过早" class="headerlink" title="3.1.9 通知过早"></a>3.1.9 通知过早</h4><p>“服务员”还没过来等待，“厨师”做完菜就发出了通知。也就是 一个线程notify 发生在另外一个线程wait之前。解决这种问题是在调用wait方法前判断，如果先通知了，则wait方法就没必要执行了。</p>
<h4 id="3-1-10-等待wait的条件发生变化"><a href="#3-1-10-等待wait的条件发生变化" class="headerlink" title="3.1.10 等待wait的条件发生变化"></a>3.1.10 等待wait的条件发生变化</h4><p>要注意wait所依赖的条件变化，多个线程在wait，有可能条件检验已经过期，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitOld.java" target="_blank" rel="noopener">WaitOld.java</a></p>
<h4 id="3-1-11-生产者-消费者模式实现"><a href="#3-1-11-生产者-消费者模式实现" class="headerlink" title="3.1.11 生产者/消费者模式实现"></a>3.1.11 生产者/消费者模式实现</h4><p><code>生产者消费者：互相通知，互相等待</code></p>
<ol>
<li>一生产者与一消费者：操作值，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerTest.java" target="_blank" rel="noopener">ProducerConsumerTest.java</a></li>
<li>多生产者与多消费：操作值-假死，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerAllWait.java" target="_blank" rel="noopener">ProducerConsumerAllWait.java</a></li>
<li>多生产者与多消费：操作值，将上面中的<code>notify</code>改为<code>notifyAll</code>，唤醒所有。</li>
<li>一生产与一消费：操作栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerConsumerStack.java" target="_blank" rel="noopener">ProducerConsumerStack.java</a></li>
<li>一生产与多消费：操作栈，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ProducerMulConsumerStack.java" target="_blank" rel="noopener">ProducerMulConsumerStack.java</a></li>
</ol>
<h4 id="3-1-12-通过管道进行线程间通信：字节流"><a href="#3-1-12-通过管道进行线程间通信：字节流" class="headerlink" title="3.1.12 通过管道进行线程间通信：字节流"></a>3.1.12 通过管道进行线程间通信：字节流</h4><p><code>Java</code>语言中提供了各种各样的<code>输入/输出</code> 流<code>Stream</code>，能方便的对数据进行操作，其中<code>管道流</code>(<code>pipeStream</code>)是一种特殊的流，用于在不同线程间直接传送数据。</p>
<p>字节流通信，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PipedInputOutput.java" target="_blank" rel="noopener">PipedInputOutput.java</a></p>
<h4 id="3-1-13-通过管道进行线程间通信：字符流"><a href="#3-1-13-通过管道进行线程间通信：字符流" class="headerlink" title="3.1.13 通过管道进行线程间通信：字符流"></a>3.1.13 通过管道进行线程间通信：字符流</h4><p>字符流通信，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/PipedReaderWriter.java" target="_blank" rel="noopener">PipedReaderWriter.java</a></p>
<h4 id="3-1-14-实战：等待-通知之交叉备份"><a href="#3-1-14-实战：等待-通知之交叉备份" class="headerlink" title="3.1.14 实战：等待/通知之交叉备份"></a>3.1.14 实战：等待/通知之交叉备份</h4><p>创建20个线程，其中10个线程将数据备份至A数据库，另外10个线程将数据备份至B数据库，并且备份A数据库和备份B数据库交叉进行。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/WaitNotifyInsert.java" target="_blank" rel="noopener">WaitNotifyInsert.java</a></p>
<h3 id="3-2-方法join的使用"><a href="#3-2-方法join的使用" class="headerlink" title="3.2 方法join的使用"></a>3.2 方法join的使用</h3><p>在很多情况下，主线程创建并启动子线程，如果子线程耗时较久，主线程往往将早于子线程结束。这这时如果主线程想等待子线程完成之后做操作，就可以使用<code>join()</code>方法了。</p>
<h4 id="3-2-1-学习方法join前的铺垫"><a href="#3-2-1-学习方法join前的铺垫" class="headerlink" title="3.2.1 学习方法join前的铺垫"></a>3.2.1 学习方法join前的铺垫</h4><p>比如我们需要 T1、T2、T3 三个线程按先后顺序执行，没有join方法可以尝试这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1.start();  T1.sleep(xxx);</span><br><span class="line">T2.start();  T2.sleep(xxx);</span><br><span class="line">T3.start();</span><br></pre></td></tr></table></figure></p>
<p>问题就在于 上面的xxx时间我们无法确定，因为每个线程运行多久我们不能确定， 设值长了，程序会浪费等待时间，设值短了，可能出现顺序不对。</p>
<h4 id="3-2-2-用join方法解决"><a href="#3-2-2-用join方法解决" class="headerlink" title="3.2.2 用join方法解决"></a>3.2.2 用join方法解决</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1.start();  T1.join();</span><br><span class="line">T2.start();  T2.join();</span><br><span class="line">T3.start();</span><br></pre></td></tr></table></figure>
<p>这样就能保证三个线程依次执行了。</p>
<p>另外注意：<strong>如果<code>T1</code>内部启动了新的线程，<code>T1.join()</code>方法后面的代码不会等待<code>T1</code>新启的线程</strong></p>
<h4 id="3-2-3-方法join与异常"><a href="#3-2-3-方法join与异常" class="headerlink" title="3.2.3 方法join与异常"></a>3.2.3 方法join与异常</h4><h4 id="3-2-4-方法join-long-的使用"><a href="#3-2-4-方法join-long-的使用" class="headerlink" title="3.2.4 方法join(long)的使用"></a>3.2.4 方法join(long)的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">childThread.join(<span class="number">1000</span>); <span class="comment">//执行这个方法所在的线程最多等待 1000ms，</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个方法会无论如何等待 1000ms</span></span><br><span class="line">如果子线程执行的时间超过<span class="number">1000</span>ms，那么他们所看起来的效果是一致的。</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-方法-join-long-与-sleep-long-的异同"><a href="#3-2-5-方法-join-long-与-sleep-long-的异同" class="headerlink" title="3.2.5 方法 join(long) 与 sleep(long)的异同"></a>3.2.5 方法 join(long) 与 sleep(long)的异同</h4><p><code>join(long)</code>方法内部是使用<code>wait(long)</code>实现的，所以<code>join(long)</code>方法也具有释放锁的特点， 而<code>sleep(long)</code>方法不会释放锁。</p>
<p>相同：</p>
<ol>
<li>调用<code>sleep</code>与<code>join</code>方法来达到阻塞当前线程的目的</li>
</ol>
<p>不同：</p>
<ol>
<li><code>sleep(long)</code>为<code>Thread类static</code>方法，<code>join(long)</code>为<code>Thread实例的方法</code>，故需要注意他们作用于的线程区别</li>
<li>作用于普通的非同步方法中区别就是：<code>sleep(long)</code>等待固定时间、<code>join(long)</code>最多等待这么久的时间</li>
</ol>
<p>具体深入对比可以查看: <a href="http://blog.ouronghui.com/2017/03/23/Thread%E7%B1%BBjoin%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%20wait(0">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a>%20%E8%83%BD%E7%94%A8%20sleep(0)%20%E6%9D%A5%E6%9B%BF%E4%BB%A3%E6%A8%A1%E6%8B%9F%E5%90%97/)</p>
<h3 id="3-3-类ThreadLocal的使用"><a href="#3-3-类ThreadLocal的使用" class="headerlink" title="3.3 类ThreadLocal的使用"></a>3.3 类ThreadLocal的使用</h3><p>类变量的共享可以采用<code>public static</code>形式，所有线程都使用同一个<code>public static</code>变量。 如果想要实现每个线程都有自己的共享变量呢？ <code>JDK</code>提供的类<code>ThreadLocal</code>正是为了解决这个问题的。</p>
<ul>
<li>局部变量：方法内，不同享，与实例和线程都无关。</li>
<li>全局变量：类内，共享实例变量，在不同的线程、或方法间达到共享</li>
<li>全局静态：类内，共享静态变量，不同线程间访问达到共享，<code>静态</code>与实例无关。</li>
</ul>
<h4 id="3-3-1-方法-get-与-null"><a href="#3-3-1-方法-get-与-null" class="headerlink" title="3.3.1 方法 get() 与 null"></a>3.3.1 方法 get() 与 null</h4><h4 id="3-3-2-验证变量的隔离性"><a href="#3-3-2-验证变量的隔离性" class="headerlink" title="3.3.2 验证变量的隔离性"></a>3.3.2 验证变量的隔离性</h4><h4 id="3-3-3-解决-get-返回-null问题"><a href="#3-3-3-解决-get-返回-null问题" class="headerlink" title="3.3.3 解决 get() 返回 null问题"></a>3.3.3 解决 get() 返回 null问题</h4><h4 id="3-3-4-再次验证线程变量的隔离性"><a href="#3-3-4-再次验证线程变量的隔离性" class="headerlink" title="3.3.4 再次验证线程变量的隔离性"></a>3.3.4 再次验证线程变量的隔离性</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/VerifyIsolation.java" target="_blank" rel="noopener">VerifyIsolation.java</a></p>
<h3 id="3-4-类-InheritableThreadLocal-的使用"><a href="#3-4-类-InheritableThreadLocal-的使用" class="headerlink" title="3.4 类 InheritableThreadLocal 的使用"></a>3.4 类 InheritableThreadLocal 的使用</h3><p>使用<code>InheritableThreadLocal</code>可以在子线程取得父线程继承下来的值。</p>
<h4 id="3-4-1-值继承"><a href="#3-4-1-值继承" class="headerlink" title="3.4.1 值继承"></a>3.4.1 值继承</h4><h4 id="3-4-2-值继承再修改"><a href="#3-4-2-值继承再修改" class="headerlink" title="3.4.2 值继承再修改"></a>3.4.2 值继承再修改</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/InheritableThreadLocalTest.java" target="_blank" rel="noopener">InheritableThreadLocalTest.java</a></p>
<h2 id="4-Lock的使用"><a href="#4-Lock的使用" class="headerlink" title="4. Lock的使用"></a>4. Lock的使用</h2><p>Skills:</p>
<ul>
<li><code>ReentrantLock</code>类的使用</li>
<li><code>ReentrantReadWriteLock</code>类的使用</li>
</ul>
<h3 id="4-1-使用-ReentrantLock类"><a href="#4-1-使用-ReentrantLock类" class="headerlink" title="4.1 使用 ReentrantLock类"></a>4.1 使用 ReentrantLock类</h3><p>在<code>java</code>多线程中，可以使用<code>synchronized</code>关键字来实现线程之间同步互斥，但在<code>jdk1.5</code>中新增了<code>ReentrantLock</code>类也能达到同样的效果，并且在扩展功能上也更加强大，比如有嗅探锁定、多路分支通知等功能，使用上比<code>synchronized</code>更加灵活。</p>
<h4 id="4-1-1-使用-ReentrantLock类实现同步"><a href="#4-1-1-使用-ReentrantLock类实现同步" class="headerlink" title="4.1.1 使用 ReentrantLock类实现同步"></a>4.1.1 使用 ReentrantLock类实现同步</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReentrantLockTest.java" target="_blank" rel="noopener">ReentrantLockTest.java</a></p>
<h4 id="4-1-2-使用-ReentrantLock类实现同步-测试2"><a href="#4-1-2-使用-ReentrantLock类实现同步-测试2" class="headerlink" title="4.1.2 使用 ReentrantLock类实现同步: 测试2"></a>4.1.2 使用 ReentrantLock类实现同步: 测试2</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReentrantLockTest2.java" target="_blank" rel="noopener">ReentrantLockTest2.java</a></p>
<h4 id="4-1-3-使用Condition-实现等待-通知：错误用法与解决"><a href="#4-1-3-使用Condition-实现等待-通知：错误用法与解决" class="headerlink" title="4.1.3 使用Condition 实现等待/通知：错误用法与解决"></a>4.1.3 使用Condition 实现等待/通知：错误用法与解决</h4><p>关键字 <code>synchronized</code>与<code>wait()</code>和<code>notify()/notifyAll()</code>方法结合可以实现等待/通知模式，类<code>ReentrantLock</code>实现同样的功能是借助于<code>Condition</code>对象。<code>Condition</code>是JDK5中出现的技术，使用它有更好的灵活性，比如实现多路通知的功能，也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>对象实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/UseConditionWaitNotifyError.java" target="_blank" rel="noopener">UseConditionWaitNotifyError.java</a></p>
<h4 id="4-1-4-正确使用Condition实现等待-通知"><a href="#4-1-4-正确使用Condition实现等待-通知" class="headerlink" title="4.1.4 正确使用Condition实现等待/通知"></a>4.1.4 正确使用Condition实现等待/通知</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/UseConditionWaitNotifyOK.java" target="_blank" rel="noopener">UseConditionWaitNotifyOK.java</a></p>
<p>成功的实现了等待/通知模式。</p>
<ul>
<li><code>Object</code>类中的<code>wait()</code>相当于<code>Condition</code>类中的<code>await()</code>方法， 线程进入<code>WAITING</code>状态。</li>
<li><code>Object</code>类中的<code>wait(long timeout)</code>相当于<code>Condition</code>类中的<code>await(long time, TimeUnit unit)</code>方法， 线程进入<code>TIMED_WAITING</code>状态。</li>
<li><code>Object</code>类中的<code>notify()</code>相当于<code>Condition</code>类中的<code>signal()</code>方法</li>
<li><code>Object</code>类中的<code>notifyAll()</code>相当于<code>Condition</code>类中的<code>signalAll()</code>方法</li>
</ul>
<h4 id="4-1-5-使用Condition实现通知部分线程：错误用法"><a href="#4-1-5-使用Condition实现通知部分线程：错误用法" class="headerlink" title="4.1.5 使用Condition实现通知部分线程：错误用法"></a>4.1.5 使用Condition实现通知部分线程：错误用法</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/MustUseMoreConditionError.java" target="_blank" rel="noopener">MustUseMoreConditionError.java</a></p>
<p>两个方法共用一个<code>Condition</code>，不能体现区别唤醒，<code>thread-A</code>、<code>thread-B</code>两个线程启动分别调用了同一个<code>condition</code>的<code>await()</code>方法，线程都进入了<code>WAITING</code>状态，最后主线程同时唤醒的是两个线程。</p>
<h4 id="4-1-6-使用多个Condition实现通知部分线程：正确用法"><a href="#4-1-6-使用多个Condition实现通知部分线程：正确用法" class="headerlink" title="4.1.6 使用多个Condition实现通知部分线程：正确用法"></a>4.1.6 使用多个Condition实现通知部分线程：正确用法</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/MustUseMoreConditionOK.java" target="_blank" rel="noopener">MustUseMoreConditionOK.java</a></p>
<p>此时两个方法分别使用了<code>conditionA</code>、<code>conditionB</code>，主线程调用了<code>conditoinA.signalAll()</code>达到了只唤醒<code>thread-A</code>的效果，<code>thread-B</code>继续<code>WAITING</code></p>
<h4 id="4-1-7-实现生产者-消费者：一对一交替打印"><a href="#4-1-7-实现生产者-消费者：一对一交替打印" class="headerlink" title="4.1.7 实现生产者/消费者：一对一交替打印"></a>4.1.7 实现生产者/消费者：一对一交替打印</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionTest.java" target="_blank" rel="noopener">ConditionTest.java</a></p>
<h4 id="4-1-8-实现生产者-消费者：多对多交替打印"><a href="#4-1-8-实现生产者-消费者：多对多交替打印" class="headerlink" title="4.1.8 实现生产者/消费者：多对多交替打印"></a>4.1.8 实现生产者/消费者：多对多交替打印</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionTestManyToMany.java" target="_blank" rel="noopener">ConditionTestManyToMany.java</a></p>
<p>类似<code>Object</code>的<code>notify()</code>方法，<code>signal()</code>方法同样也会造成假死的现象，这是因为<code>生产者</code>与<code>消费者</code>使用的是同一个<code>Condition</code>，<code>signal()</code>方法在我们期望通知<code>消费者</code>时，可能通知到的是<code>另一个消费者</code>，反之消费者发出的通知也是一样的。所以这里也采取了<code>signalAll()</code>方法发出信号一并唤醒。</p>
<h4 id="4-1-9-公平锁与非公平锁"><a href="#4-1-9-公平锁与非公平锁" class="headerlink" title="4.1.9 公平锁与非公平锁"></a>4.1.9 公平锁与非公平锁</h4><p>公平与非公平锁：锁<code>Lock</code>分为<code>公平锁</code>和<code>非公平锁</code>, 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的<code>FIFO</code>先进先出的顺序。 而非公平锁就是一种获取锁的抢占机制，是随机获得锁的。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/FairNoFairTest.java" target="_blank" rel="noopener">FairNoFairTest.java</a></p>
<ul>
<li>公平锁 ，开始运行与得锁顺序呈有序</li>
<li>非公平锁， 开始运行与得锁顺序基本上是乱序的</li>
</ul>
<h4 id="4-1-10-方法getHoldCount-、getQueueLength-、getWaitQueueLength"><a href="#4-1-10-方法getHoldCount-、getQueueLength-、getWaitQueueLength" class="headerlink" title="4.1.10 方法getHoldCount()、getQueueLength()、getWaitQueueLength()"></a>4.1.10 方法getHoldCount()、getQueueLength()、getWaitQueueLength()</h4><ul>
<li><code>int getHoldCount()</code> 方法是<strong>查询当前线程保持此锁的个数</strong>，也就是调用 <code>lock()</code>方法的次数。测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHoldCount.java" target="_blank" rel="noopener">LockMethodHoldCount.java</a></li>
<li><code>int getQueueLength()</code> 方法是返回<strong>等待获取此锁的线程估计数</strong> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodQueueLength.java" target="_blank" rel="noopener">LockMethodQueueLength.java</a></li>
<li><code>int getWaitQueueLength(Condition condition)</code> 方法是返回<strong>等待此锁相关条件Condition的线程估计数</strong> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodWaitQueueLength.java" target="_blank" rel="noopener">LockMethodWaitQueueLength.java</a></li>
</ul>
<p>这里的体现其实与之前<code>synchronized</code>内部锁达一致：锁的两个队列，getQueueLength() 取的是针对此锁 在<code>BLOCKED</code> 就绪阻塞线程，<code>getWaitQueueLength(Condition condition)</code> 则是<code>WAITING</code>睡眠等待唤醒的线程</p>
<h4 id="4-1-11-方法-hasQueuedThread-、hasQueuedThreads-和-hasWaiters-的测试"><a href="#4-1-11-方法-hasQueuedThread-、hasQueuedThreads-和-hasWaiters-的测试" class="headerlink" title="4.1.11 方法 hasQueuedThread()、hasQueuedThreads() 和 hasWaiters()的测试"></a>4.1.11 方法 hasQueuedThread()、hasQueuedThreads() 和 hasWaiters()的测试</h4><ul>
<li><code>boolean hasQueuedThread(Thread thread)</code> 查询指定的线程是否等待获取此锁。</li>
<li><code>boolean hasQueuedThreads()</code> 查询是否有线程正在等待获取此锁。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHasQueued.java" target="_blank" rel="noopener">LockMethodHasQueued.java</a></p>
<ul>
<li><code>boolean hasWaiters(Condition condition)</code> 查询是否有线程正在等待此锁有关的<code>condition</code>条件,测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodHasWaiters.java" target="_blank" rel="noopener">LockMethodHasWaiters.java</a></li>
</ul>
<h4 id="4-1-12-方法-isFair-、isHeldByCurrentThread-和-isLocked-的测试"><a href="#4-1-12-方法-isFair-、isHeldByCurrentThread-和-isLocked-的测试" class="headerlink" title="4.1.12 方法 isFair()、isHeldByCurrentThread() 和 isLocked() 的测试"></a>4.1.12 方法 isFair()、isHeldByCurrentThread() 和 isLocked() 的测试</h4><ul>
<li><code>boolean isFair()</code> 判断锁是不是公平锁，默认情况下<code>ReentrantLock</code>是<code>非公平锁</code></li>
<li><code>boolean isHeldByCurrentThread()</code> 查询当前线程是否保持此锁定。</li>
<li><code>boolean isLocked()</code> 查询此锁是否有线程保持锁定。</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodIsHeldByCurrentThread.java" target="_blank" rel="noopener">LockMethodIsHeldByCurrentThread.java</a></p>
<h4 id="4-1-13-方法-lockInterruptibly-、tryLock-和-tryLock-long-timeout-TiemUnit-unit-的测试"><a href="#4-1-13-方法-lockInterruptibly-、tryLock-和-tryLock-long-timeout-TiemUnit-unit-的测试" class="headerlink" title="4.1.13 方法 lockInterruptibly()、tryLock() 和 tryLock(long timeout, TiemUnit unit) 的测试"></a>4.1.13 方法 lockInterruptibly()、tryLock() 和 tryLock(long timeout, TiemUnit unit) 的测试</h4><ul>
<li><code>void lockInterruptibly()</code> ：取锁，如果当前线程未被中断，则获取锁定，如果已经被终端则出现异常。测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodInterruptiblyTest.java" target="_blank" rel="noopener">LockMethodInterruptiblyTest.java</a></li>
<li><code>boolean tryLock()</code> : 取锁，尝试取锁，如未取得则返回false。</li>
<li><code>boolean tryLock(long timeout, TimeUnit unit)</code>：取锁，指定时间内如未取得锁，取锁失败返回false</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodTryLock.java" target="_blank" rel="noopener">LockMethodTryLock.java</a></p>
<h4 id="4-1-14-方法-awaitUninterruptibly-的使用"><a href="#4-1-14-方法-awaitUninterruptibly-的使用" class="headerlink" title="4.1.14 方法 awaitUninterruptibly() 的使用"></a>4.1.14 方法 awaitUninterruptibly() 的使用</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodAwaitUninterruptibly.java" target="_blank" rel="noopener">LockMethodAwaitUninterruptibly.java</a></p>
<p><code>awaitUninterruptibly()</code>方法不同于<code>await()</code>，前者将不理会<code>interrupt()</code>动作，继续执行，而<code>await()</code>在线程触发<code>interrupt()</code>动作时将正常抛出异常。</p>
<h4 id="4-1-15-方法-awaitUntil-的使用"><a href="#4-1-15-方法-awaitUntil-的使用" class="headerlink" title="4.1.15 方法 awaitUntil() 的使用"></a>4.1.15 方法 awaitUntil() 的使用</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/LockMethodAwaitUntil.java" target="_blank" rel="noopener">LockMethodAwaitUntil.java</a></p>
<h4 id="4-1-16-使用-Condition-实现顺序执行"><a href="#4-1-16-使用-Condition-实现顺序执行" class="headerlink" title="4.1.16 使用 Condition 实现顺序执行"></a>4.1.16 使用 Condition 实现顺序执行</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ConditionABC.java" target="_blank" rel="noopener">ConditionABC.java</a></p>
<h3 id="4-2-使用-ReentrantReadWriteLock-类"><a href="#4-2-使用-ReentrantReadWriteLock-类" class="headerlink" title="4.2 使用 ReentrantReadWriteLock 类"></a>4.2 使用 ReentrantReadWriteLock 类</h3><p>类<code>ReentrantLock</code>具有完全互斥排他的效果，即同一时间只有一个线程在执行<code>ReentrantLock.lock()</code>方法后的任务。这样虽然保证了实例变量的线程安全性，但效率确实低下的。所以<code>JDK</code>提供了一种读写锁<code>ReentrantReadWriteLock</code>类，使他可以加快运行效率，在某些不需要操作实例变量的方法中，完全可以使用读写锁<code>ReentrantReadWriteLock</code>来提升该方法的代码运行速度。</p>
<p>读写锁表示有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。</p>
<p>多个读锁之间不互斥，读写与写锁互斥，写锁与写锁互斥。 在没有线程进行写操作时，进行读取操作的多个线程都可以获取读锁，而写操作的线程只有在获取写锁后才能进行写操作。</p>
<p>即多个线程可以同时进行读取操作，但是同一时刻只允许一个线程进行写操作。</p>
<h3 id="4-2-1-类-ReentrantLockReadWriteLock-的使用：读读共享"><a href="#4-2-1-类-ReentrantLockReadWriteLock-的使用：读读共享" class="headerlink" title="4.2.1 类 ReentrantLockReadWriteLock 的使用：读读共享"></a>4.2.1 类 ReentrantLockReadWriteLock 的使用：读读共享</h3><p>可以看出多个线程都获得了读锁<code>readLock</code>, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin1.java" target="_blank" rel="noopener">ReadWriteLockBegin1.java</a></p>
<h3 id="4-2-1-类-ReentrantLockReadWriteLock-的使用：写写互斥"><a href="#4-2-1-类-ReentrantLockReadWriteLock-的使用：写写互斥" class="headerlink" title="4.2.1 类 ReentrantLockReadWriteLock 的使用：写写互斥"></a>4.2.1 类 ReentrantLockReadWriteLock 的使用：写写互斥</h3><p>同意时刻，只有一个线程获得锁，写锁阻塞等待前一个线程释放锁, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin2.java" target="_blank" rel="noopener">ReadWriteLockBegin2.java</a></p>
<h3 id="4-2-3-类-ReentrantLockReadWriteLock-的使用：读写互斥"><a href="#4-2-3-类-ReentrantLockReadWriteLock-的使用：读写互斥" class="headerlink" title="4.2.3 类 ReentrantLockReadWriteLock 的使用：读写互斥"></a>4.2.3 类 ReentrantLockReadWriteLock 的使用：读写互斥</h3><h3 id="4-2-4-类-ReentrantLockReadWriteLock-的使用：写读互斥"><a href="#4-2-4-类-ReentrantLockReadWriteLock-的使用：写读互斥" class="headerlink" title="4.2.4 类 ReentrantLockReadWriteLock 的使用：写读互斥"></a>4.2.4 类 ReentrantLockReadWriteLock 的使用：写读互斥</h3><p><strong>获得读锁未释放，写锁也会被阻塞，获得写锁未释放，读锁也会被阻塞</strong>：测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/lock/reentrantLock/ReadWriteLockBegin3.java" target="_blank" rel="noopener">ReadWriteLockBegin3.java</a></p>
<h3 id="4-3-Lock-本章总结"><a href="#4-3-Lock-本章总结" class="headerlink" title="4.3 Lock 本章总结"></a>4.3 Lock 本章总结</h3><p>完全可以使用<code>Lock</code>对象将<code>synchronized</code>关键字替换掉，而且其具有的功能是<code>synchronized</code>不具有的，<code>Lock</code>是<code>synchronized</code>的进阶。</p>
<h2 id="5-定时器-Timer"><a href="#5-定时器-Timer" class="headerlink" title="5 定时器 Timer"></a>5 定时器 Timer</h2><p>Skills:</p>
<ul>
<li>如何实现指定时间执行任务</li>
<li>如何实现按指定周期执行任务</li>
</ul>
<h3 id="5-1-定时器-Timer-的使用"><a href="#5-1-定时器-Timer-的使用" class="headerlink" title="5.1 定时器 Timer 的使用"></a>5.1 定时器 Timer 的使用</h3><p><code>JDK</code>中<code>Timer</code>类主要负责计划任务的功能，也就是在指定时间开始执行某一任务。<code>Timer</code>的作用是设置计划任务，但是封装任务的类是<code>TimerTask</code>抽象类，所以具体要计划执行的任务继承<code>TimerTask</code>类即可。</p>
<h4 id="5-1-1-方法-schedule-TimeTask-task-Date-time"><a href="#5-1-1-方法-schedule-TimeTask-task-Date-time" class="headerlink" title="5.1.1 方法 schedule(TimeTask task, Date time)"></a>5.1.1 方法 schedule(TimeTask task, Date time)</h4><p>指定的日期的时间执行一次任务。</p>
<ol>
<li>执行任务的时间晚于当前时间：在未来的某个时间点执行 — timer内部的TimerThread 在实例化时start，默认非守护线程，意味任务完成后，即使没有其他线程，程序不会结束，如果设定为守护线程，如果任务运行之前，其他非守护都已经结束，那么有可能任务还未执行，程序就已经结束。</li>
<li><p>计划时间早于当前时间：设定的时间点是已经过去 – 时间点是过去，则会立即执行task任务</p>
<p> 1,2 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest1.java" target="_blank" rel="noopener">TimerTest1.java</a></p>
</li>
<li><p>一个<code>Timer</code>中多个<code>TimerTask</code> 任务及延时的测试 – 以计划执行的时间排队成队列，前者执行完后者再执行，当前者执行时间较长时会阻塞后面队列中的任务。<br> 3 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerMultiTask.java" target="_blank" rel="noopener">TimerMultiTask.java</a></p>
</li>
</ol>
<h4 id="5-1-2-方法-schedule-TimerTask-task-Date-firstTime-long-period"><a href="#5-1-2-方法-schedule-TimerTask-task-Date-firstTime-long-period" class="headerlink" title="5.1.2 方法 schedule(TimerTask task, Date firstTime, long period)"></a>5.1.2 方法 schedule(TimerTask task, Date firstTime, long period)</h4><p>指定日期的时间后，按指定间隔周期性的执行某一任务。</p>
<ol>
<li>计划时间晚于当前时间：在未来某个时间点开始</li>
<li>计划时间早于当前时间：设定的开始时间是已经过去的 – 立即开始周期任务</li>
<li><p>任务执行时间被延迟 – 当间隔时间小于任务单次执行所要的时间时，后面的任务都被延时堆压，会越积越多，但还是一个一个顺序执行</p>
<p> 1,2,3 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest2.java" target="_blank" rel="noopener">TimerTest2.java</a></p>
</li>
<li><p><code>TimerTask</code>类的<code>cancel</code>方法 – 将自身任务从<code>Timer</code>任务队列中移除，其他任务不受影响<br> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTaskCancel.java" target="_blank" rel="noopener">TimerTaskCancel.java</a></p>
</li>
<li><code>Timer</code>类的<code>cancel</code>方法 – timer中的任务全部清除，timer内部线程销毁，程序退出<br> 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerCancel.java" target="_blank" rel="noopener">TimerCancel.java</a></li>
<li><code>Timer</code>的<code>cancel()</code> 方法注意事项 – 调用<code>cancel()</code> 方法不一定会停止任务，当<code>cancel()</code>方法没有竞争到内部的<code>queue</code>锁时。</li>
</ol>
<h4 id="5-1-3-方法-schedule-TimerTask-task-long-delay"><a href="#5-1-3-方法-schedule-TimerTask-task-long-delay" class="headerlink" title="5.1.3 方法 schedule(TimerTask task, long delay)"></a>5.1.3 方法 schedule(TimerTask task, long delay)</h4><p>以当前时间为基准，延迟指定的毫秒数执行某一任务。<br>    测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest3.java" target="_blank" rel="noopener">TimerTest3.java</a></p>
<h4 id="5-1-4-方法-schedule-TimerTask-task-long-delay-long-period"><a href="#5-1-4-方法-schedule-TimerTask-task-long-delay-long-period" class="headerlink" title="5.1.4 方法 schedule(TimerTask task, long delay, long period)"></a>5.1.4 方法 schedule(TimerTask task, long delay, long period)</h4><p>以当前时间为基准，延迟指定的毫秒数开始周期性的执行某一任务。<br>    当前时间往后推3秒开始执行， 每3秒 执行一次myTask ,测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest4.java" target="_blank" rel="noopener">TimerTest4.java</a></p>
<h4 id="5-1-5-方法-scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period"><a href="#5-1-5-方法-scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period" class="headerlink" title="5.1.5 方法 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)"></a>5.1.5 方法 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</h4><p>  “单次执行任务的时间”一般小于”间隔时间<code>period</code>“，比如你<code>完成一次仰卧起坐的时间是2秒</code>，那么你就不会制定一个<code>每隔1秒做1个仰卧起坐</code>执行计划,你有可能制定一个：<strong>每隔3秒做1个仰卧起做</strong>执行计划，基于这个计划我们来对比下各种情况，schedule/scheduleAtFixedRate的表现：</p>
<p>情况1：<strong>中途出现4秒完成一个的情况</strong> – 认定为意外</p>
<p>此时<code>schedule/scheduleAtFixedRate</code>都会认为这是一个意外，为了不让这个意外继续扩散，他们都会在这个情况出现后马上开始下一次。</p>
<p>情况2：<strong>昨天忘记按这个计划执行了</strong> – 区别在这里</p>
<p>schedule: 按period周期，不追赶；马上开始做仰卧起做，按period周期做。</p>
<p>scheduleAtFixedRate: 追赶执行；马上开始做仰卧起坐，做完一个紧接着做下一个，直到赶上，完成昨天的量。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/timer/TimerTest5.java" target="_blank" rel="noopener">TimerTest5.java</a></p>
<h2 id="6-单例模式与多线程"><a href="#6-单例模式与多线程" class="headerlink" title="6. 单例模式与多线程"></a>6. 单例模式与多线程</h2><p>通过单例与多线程技术的结合，在这个过程中发现很多以前为考虑的问题，学习如何使单例模式遇到多线程时安全的。</p>
<h3 id="6-1-立即加载-“饿汉模式”"><a href="#6-1-立即加载-“饿汉模式”" class="headerlink" title="6.1 立即加载/“饿汉模式”"></a>6.1 立即加载/“饿汉模式”</h3><p>在使用类之前类的对象就已经创建好了，中文语境来看，就是饿的迫不及待，有着急迫切的含义。实现的一般做法是：私有化构造方法，声明类全局静态变量，并实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</span><br></pre></td></tr></table></figure></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest1.java" target="_blank" rel="noopener">SigletonTest1.java</a></p>
<p>注意看下上面例子不单是单例相关的演示，而且包括：静态资源初始化的问题，<strong>会有一个奇怪的现象，多线程访问类的普通静态方法，不是立马返回结果，而是线程被“阻塞了”</strong></p>
<ul>
<li>静态资源初始化本身就是 单线程的(同步阻塞)，在类内部资源被初次访问时，触发静态初始化,初始化的顺序 是从上往下.</li>
<li>被静态初始化“阻塞”的方法，不是阻塞”BLOCKD”状态，而是 “RUNNABLE” 状态</li>
</ul>
<p>其实这里应该也是<code>JVM</code>的一个编译优化，类如果被使用到，其静态的资源也不会被初始化加载。</p>
<h3 id="6-2-延迟加载-懒汉模式"><a href="#6-2-延迟加载-懒汉模式" class="headerlink" title="6.2 延迟加载/懒汉模式"></a>6.2 延迟加载/懒汉模式</h3><p>只有在<code>get()</code>时才被创建，从语境上看是“缓慢”、“不急迫”的含义。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest2.java" target="_blank" rel="noopener">SigletonTest2.java</a></p>
<p>以上代码帮助理解”懒汉模式” + “DCL” 方式实现的单例，应对的绝大多数场景：<code>高并发取单例，低并发初始化实例</code>，巧妙的避免了<code>synchronized</code>的阻塞，又使用<code>synchronized</code>来保证单次实例化。</p>
<p>进阶理解，对比测试：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SyncDclMethodCompare.java" target="_blank" rel="noopener">SyncDclMethodCompare.java</a></p>
<p><code>剧情再次反转，在我的上面的测试环境，就用 synchronized 方法就好，不会有什么性能影响</code></p>
<h3 id="6-3-静态内置类实现单例"><a href="#6-3-静态内置类实现单例" class="headerlink" title="6.3 静态内置类实现单例"></a>6.3 静态内置类实现单例</h3><p>静态内部类实现 <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest3.java" target="_blank" rel="noopener">SigletonTest3.java</a></p>
<h3 id="6-4-序列化反序列化实现单例"><a href="#6-4-序列化反序列化实现单例" class="headerlink" title="6.4 序列化反序列化实现单例"></a>6.4 序列化反序列化实现单例</h3><p>反序列化生成对象时，不通过对象的构造方法，所以会造成有另外的实例被生成，出现非单例的情况，但是反序列化内部会判断对象是否有<code>readResolve</code>方法，有就会自动调用，来达到单例的目的。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest4.java" target="_blank" rel="noopener">SigletonTest4.java</a></p>
<h3 id="6-5-使用-static-代码块实现单例"><a href="#6-5-使用-static-代码块实现单例" class="headerlink" title="6.5 使用 static 代码块实现单例"></a>6.5 使用 static 代码块实现单例</h3><p>其实这种和<code>饿汉模式</code>类似，都类被访问，静态资源自动初始化。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest5.java" target="_blank" rel="noopener">SigletonTest5.java</a></p>
<h3 id="6-6-使用枚举-enum-数据类型实现单例"><a href="#6-6-使用枚举-enum-数据类型实现单例" class="headerlink" title="6.6 使用枚举 enum 数据类型实现单例"></a>6.6 使用枚举 enum 数据类型实现单例</h3><p>利用枚举类中枚举元素自动实例化的特点，定义几个枚举元素，产生几个实例，定义一个枚举元素，就是单个实例。</p>
<p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest6.java" target="_blank" rel="noopener">SigletonTest6.java</a></p>
<h3 id="6-7-完善使用-enum-枚举实现单例模式"><a href="#6-7-完善使用-enum-枚举实现单例模式" class="headerlink" title="6.7 完善使用 enum 枚举实现单例模式"></a>6.7 完善使用 enum 枚举实现单例模式</h3><p>上面<code>6.6</code>的例子中违反了“职责单一原则”，完善测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest7.java" target="_blank" rel="noopener">SigletonTest7.java</a></p>
<h2 id="7-拾遗增补"><a href="#7-拾遗增补" class="headerlink" title="7. 拾遗增补"></a>7. 拾遗增补</h2><p>Skills:</p>
<ul>
<li>线程组的使用</li>
<li>如何切换线程状态</li>
<li>SimpleDateFormat 类与多线程的解决办法</li>
<li>如何处理线程异常</li>
</ul>
<h3 id="7-1-线程的状态"><a href="#7-1-线程的状态" class="headerlink" title="7.1 线程的状态"></a>7.1 线程的状态</h3><p>线程状态枚举类：<code>Thread.State</code></p>
<h4 id="7-1-1-验证-NEW、RUNNABLE、TERMINATED"><a href="#7-1-1-验证-NEW、RUNNABLE、TERMINATED" class="headerlink" title="7.1.1 验证 NEW、RUNNABLE、TERMINATED"></a>7.1.1 验证 NEW、RUNNABLE、TERMINATED</h4><h4 id="7-1-2-验证-TIMED-WAITING"><a href="#7-1-2-验证-TIMED-WAITING" class="headerlink" title="7.1.2 验证 TIMED_WAITING"></a>7.1.2 验证 TIMED_WAITING</h4><h4 id="7-1-3-验证-BLOCKED"><a href="#7-1-3-验证-BLOCKED" class="headerlink" title="7.1.3 验证 BLOCKED"></a>7.1.3 验证 BLOCKED</h4><h4 id="7-1-4-验证-WAITING"><a href="#7-1-4-验证-WAITING" class="headerlink" title="7.1.4 验证 WAITING"></a>7.1.4 验证 WAITING</h4><p><a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadStateTest.java" target="_blank" rel="noopener">演示以上1-4状态的例子</a></p>
<h3 id="7-2-线程组"><a href="#7-2-线程组" class="headerlink" title="7.2 线程组"></a>7.2 线程组</h3><p>可以把线程归属到某一个线程组中，线程组中可以有线程对象、也可以有线程组，组中还可以有线程。就类似于一颗节点树，树分支是线程组，叶子节点就是线程，树分支上可以有更小的树分支。</p>
<p>线程组的作用是批量管理线程或线程组对象，有效的对线程或线程组对象进行组织。</p>
<h4 id="7-2-1-线程对象管理线程组：-1级关联"><a href="#7-2-1-线程对象管理线程组：-1级关联" class="headerlink" title="7.2.1 线程对象管理线程组： 1级关联"></a>7.2.1 线程对象管理线程组： 1级关联</h4><p>测试类： <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddThread.java" target="_blank" rel="noopener">GroupAddThread.java</a></p>
<h4 id="7-2-2-线程对象管理线程组：-多级关联"><a href="#7-2-2-线程对象管理线程组：-多级关联" class="headerlink" title="7.2.2 线程对象管理线程组： 多级关联"></a>7.2.2 线程对象管理线程组： 多级关联</h4><p>多级分组, 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddThreadMoreLevel.java" target="_blank" rel="noopener">GroupAddThreadMoreLevel.java</a></p>
<h4 id="7-2-3-线程组自动归属特性"><a href="#7-2-3-线程组自动归属特性" class="headerlink" title="7.2.3 线程组自动归属特性"></a>7.2.3 线程组自动归属特性</h4><p>自动归属就是自动归到当前线程组中。<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/AutoAddGroup.java" target="_blank" rel="noopener">AutoAddGroup.java</a></p>
<h4 id="7-2-4-获取根线程组"><a href="#7-2-4-获取根线程组" class="headerlink" title="7.2.4 获取根线程组"></a>7.2.4 获取根线程组</h4><p>通过线程<code>getThreadGroup().getParent()</code>获取线程所在组的父级线程组，得到为null时则已经是最根级别的组了。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GetParentGroup.java" target="_blank" rel="noopener">GetParentGroup.java</a></p>
<h4 id="7-2-5-线程组里加线程组"><a href="#7-2-5-线程组里加线程组" class="headerlink" title="7.2.5 线程组里加线程组"></a>7.2.5 线程组里加线程组</h4><p>利用<code>ThreadGroup</code>构造函数显示指定父线程组，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupAddGroup.java" target="_blank" rel="noopener">GroupAddGroup.java</a></p>
<h4 id="7-2-6-组内的线程批量停止"><a href="#7-2-6-组内的线程批量停止" class="headerlink" title="7.2.6 组内的线程批量停止"></a>7.2.6 组内的线程批量停止</h4><p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupInnerStop.java" target="_blank" rel="noopener">GroupInnerStop.java</a></p>
<h4 id="7-2-7-递归与非递归取的组内对象"><a href="#7-2-7-递归与非递归取的组内对象" class="headerlink" title="7.2.7 递归与非递归取的组内对象"></a>7.2.7 递归与非递归取的组内对象</h4><ul>
<li><code>getThreadGroup().enumerate(putList, isRecurse)</code> 可以指定是否递归子孙组</li>
<li><code>activeGroupCount()</code> 取的数量是包括子孙组的</li>
</ul>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/group/GroupRecurse.java" target="_blank" rel="noopener">GroupRecurse.java</a></p>
<h3 id="7-3-使线程具有有序性"><a href="#7-3-使线程具有有序性" class="headerlink" title="7.3 使线程具有有序性"></a>7.3 使线程具有有序性</h3><p>正常情况下，多个线程执行任务的时机是无序的。可通过改造代码使他们具有有序性。</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/ThreadRunSync.java" target="_blank" rel="noopener">ThreadRunSync.java</a></p>
<p>这里的顺序控制逻辑其实可以利用其它方式，如指定<code>nextFlag</code>，或者使用<code>ReentrantLock</code>的多个<code>Condition</code>来指定唤醒执行。</p>
<h3 id="7-4-SimpleDateFormat-非线程安全"><a href="#7-4-SimpleDateFormat-非线程安全" class="headerlink" title="7.4 SimpleDateFormat 非线程安全"></a>7.4 SimpleDateFormat 非线程安全</h3><p><code>SimpleDateFormat</code>主要负责日期的转换和格式化，但在多线程环境中容易误用，比如全局静态化实例、全局实例多线程访问造成转换不准确。</p>
<h4 id="7-4-1-出现异常"><a href="#7-4-1-出现异常" class="headerlink" title="7.4.1 出现异常"></a>7.4.1 出现异常</h4><p>发生异常的原因：跟踪<code>SimpleDateFormat</code> 源码可以发现 内部 存储了全局变量： <code>Calendar</code>，也就是单个实例，多线程 都会访问操作 这个<code>Calendar</code>，造成混乱，最终转换错误或出现转换异常<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/FormatError.java" target="_blank" rel="noopener">FormatError.java</a></p>
<h4 id="7-4-2-解决异常方法1"><a href="#7-4-2-解决异常方法1" class="headerlink" title="7.4.2 解决异常方法1"></a>7.4.2 解决异常方法1</h4><h4 id="7-4-3-解决异常方法2"><a href="#7-4-3-解决异常方法2" class="headerlink" title="7.4.3 解决异常方法2"></a>7.4.3 解决异常方法2</h4><p>其实都是同理，不可避免每次调用都需要新的实例。一般做法是 封装工具类，实现静态方法内部实例化<code>SimpleDateFormat</code>。或者使用现有的三方工具类。</p>
<h3 id="7-5-线程中出现异常的处理"><a href="#7-5-线程中出现异常的处理" class="headerlink" title="7.5 线程中出现异常的处理"></a>7.5 线程中出现异常的处理</h3><p><code>Thread</code>实例方法：<code>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code>，与<code>Thread</code>静态方法：<code>setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code></p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadExceptionHandler.java" target="_blank" rel="noopener">ThreadExceptionHandler.java</a>，测试中在这里发现了另外一个神奇的地方:<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/NewThreadForThread.java" target="_blank" rel="noopener">new Thread(existsThread)</a></p>
<h3 id="7-6-线程组内异常"><a href="#7-6-线程组内异常" class="headerlink" title="7.6 线程组内异常"></a>7.6 线程组内异常</h3><p>新建<code>MyThreadGroup</code> 重写其<code>uncaughtException(Thread t, Throwable e)</code>方法<br>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadGroupInnerException.java" target="_blank" rel="noopener">ThreadGroupInnerException.java</a></p>
<h3 id="7-7-线程异常处理的传递"><a href="#7-7-线程异常处理的传递" class="headerlink" title="7.7 线程异常处理的传递"></a>7.7 线程异常处理的传递</h3><p>前面介绍涉及了3中异常处理的方式，如果将这些方式一起用上，会有什么效果呢？</p>
<p>测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/ThreadExceptionMultiHandler.java" target="_blank" rel="noopener">ThreadExceptionMultiHandler.java</a></p>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><h3 id="8-1-1-Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）"><a href="#8-1-1-Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）" class="headerlink" title="8.1 1. Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）"></a>8.1 1. Synchronized底层优化（偏向锁、轻量级锁、重量级锁、自旋锁）</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。参考：<a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></p>
<ul>
<li>偏向锁： 适用于<code>低竞争</code>情况，其核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。可以理解为：当只有一个线程操作带有同步方法的Vector对象的时候，此时对Vector的操作就转变成了对ArrayList的操作。jvm参数:<code>-XX:+UseBiasedLocking</code></li>
<li>重量级锁：对象监视锁(monitor)实现，依赖于操作系统<code>Mutex Lock</code>实现，操作系统线程间状态切换相对耗时长，这就是<code>synchronized</code>效率低的原因。</li>
<li>自旋锁： 空转避免线程进入<code>BLOCKED</code>，适用于<code>锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义</code>,对于竞争激烈、单线程持锁时间长的不仅仅浪费CPU，最终避免不了进入<code>BLOCKED</code>状态。在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</li>
</ul>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><ul>
<li><p>锁存在的意义  <a href="http://www.cnblogs.com/paddix/p/5374810.html" target="_blank" rel="noopener">Java 并发编程：核心理论</a></p>
</li>
<li><p>Thread类</p>
</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecxy9fgeuj20dm1p4793.jpg" alt="Thread"></p>
<ul>
<li><code>synchronized</code> ,内部锁， 锁对象， Object() 类方法：截图  wait()/wait(long)、notify()、notifyAll()</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/929194b4gy1fecumm3jxlj20ld09rjs1.jpg" alt="Object"></p>
<ul>
<li><code>Lock</code>接口方法，<code>ReentrantLock</code>类方法，<code>ReentrantReadWriteLock</code>类方法 读、写锁特性</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecummi8pwj20sp0i00v1.jpg" alt="ReentrantLock"></p>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecumlrh4ij20tk0akdgn.jpg" alt="Condition"></p>
<ul>
<li><code>Timer</code>类方法</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/929194b4gy1fecvjt4roej20xd0djq5x.jpg" alt="Timer"></p>
<ul>
<li>补充 <code>LockSupport</code> <a href="http://www.tuicool.com/articles/MveUNzF" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a>、<a href="https://www.zhihu.com/question/26471972/answer/74773092" target="_blank" rel="noopener">Java中Lock和LockSupport的区别到底是什么</a></li>
<li>补充 管理类：ThreadPoolExcutor 等</li>
<li><a href="http://www.linmuxi.com/2016/06/02/jvm-note-concurrent/" target="_blank" rel="noopener">内存模型/高效并发</a></li>
</ul>
<h4 id="实验碰到的几个问题"><a href="#实验碰到的几个问题" class="headerlink" title="实验碰到的几个问题"></a>实验碰到的几个问题</h4><h5 id="1-类内部的public-static-xxMethod-有可能被阻塞吗？"><a href="#1-类内部的public-static-xxMethod-有可能被阻塞吗？" class="headerlink" title="1. 类内部的public static xxMethod() {} 有可能被阻塞吗？"></a>1. 类内部的<code>public static xxMethod() {}</code> 有可能被阻塞吗？</h5><p>静态资源初始化造成“阻塞”，但是线程其实是呈<code>RUNNABLE</code>状态的，静态资源初始化本身就是 单线程的(同步阻塞)，在类内部资源被初次访问时，触发静态初始化,初始化的顺序 是从上往下. 测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest1.java" target="_blank" rel="noopener">SigletonTest1.java</a></p>
<h5 id="2-thead-join-方法内的wait-0-可以用sleep-0-代替实现吗？"><a href="#2-thead-join-方法内的wait-0-可以用sleep-0-代替实现吗？" class="headerlink" title="2. thead.join()方法内的wait(0)可以用sleep(0)代替实现吗？"></a>2. <code>thead.join()</code>方法内的<code>wait(0)</code>可以用<code>sleep(0)</code>代替实现吗？</h5><p>具体查看：<a href="http://blog.ouronghui.com/2017/03/23/Thread%E7%B1%BBjoin%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%20wait(0)%20%E8%83%BD%E7%94%A8%20sleep(0)%20%E6%9D%A5%E6%9B%BF%E4%BB%A3%E6%A8%A1%E6%8B%9F%E5%90%97/">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a></p>
<h5 id="3-thread-join-如果thread内部启动了新的线程，那么thread-join-后的代码会等待thread内部线程再执行吗？"><a href="#3-thread-join-如果thread内部启动了新的线程，那么thread-join-后的代码会等待thread内部线程再执行吗？" class="headerlink" title="3. thread.join() 如果thread内部启动了新的线程，那么thread.join()后的代码会等待thread内部线程再执行吗？"></a>3. <code>thread.join()</code> 如果<code>thread</code>内部启动了新的线程，那么<code>thread.join()</code>后的代码会等待<code>thread</code>内部线程再执行吗？</h5><p><code>thread.join()</code>方法不会理会，<code>thread</code>新启动的线程，只会根据<code>thread</code>的<code>isAlive</code>返回来判断。可以利用线程组<code>ThreadGroup</code>来判断<code>thread</code>内部新建立的线程是否都已经运行完毕。</p>
<h5 id="4-线程基础-Object-wait-与-Object-notify-都是干什么用的，怎么用的？"><a href="#4-线程基础-Object-wait-与-Object-notify-都是干什么用的，怎么用的？" class="headerlink" title="4. 线程基础 Object.wait()与 Object.notify() 都是干什么用的，怎么用的？"></a>4. 线程基础 <code>Object.wait()</code>与 <code>Object.notify()</code> 都是干什么用的，怎么用的？</h5><p>线程同步中用到，执行<code>wait/notify</code>时都需要已经持有该对象的监视锁，<code>wait()</code>方法使线程释放锁并进入<code>WAITING</code>状态，<code>notify()</code>方法是唤醒该锁阻塞队列中的一个线程，<code>notify()</code>方法不会释放锁，同步代码块结束后才释放锁。</p>
<h5 id="5-怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？"><a href="#5-怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？" class="headerlink" title="5. 怎么看待单例模式中懒汉模式结合DCL的方式解决线程安全问题？"></a>5. 怎么看待单例模式中懒汉模式结合<code>DCL</code>的方式解决线程安全问题？</h5><p>初期理解，以高并发初次实例化的场景看待问题，觉得存在几处浪费工作，代码结构更加不清晰。 </p>
<p>不过后来发现，其实应该“乐观”看待，<code>高并发初始化</code>场景少，<code>高并发取实例</code>场景多</p>
<p>理解代码：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/sigleton/SigletonTest2.java" target="_blank" rel="noopener">SigletonTest2.java</a></p>
<h5 id="6-发生线程安全问题一般有哪几种情况？-方法内定义的变量，可能引起线程安全问题吗？"><a href="#6-发生线程安全问题一般有哪几种情况？-方法内定义的变量，可能引起线程安全问题吗？" class="headerlink" title="6. 发生线程安全问题一般有哪几种情况？ 方法内定义的变量，可能引起线程安全问题吗？"></a>6. 发生线程安全问题一般有哪几种情况？ 方法内定义的变量，可能引起线程安全问题吗？</h5><p>容易出现问题的一般有这几中情况：</p>
<ol>
<li>全局的静态变量， 问题的发生点在于<code>全部线程都能访问这个静态变量</code>，少有的web下应用也常见的场景：定义一个全局静态的<code>map</code>来缓存数据  <code>public static HashMap&lt;String, String&gt; cacheMap = new HashMap&lt;String, String&gt;();</code>、定义一个全局</li>
<li>全局的实例变量， 问题的发生点就在于<code>单个实例会被多个线程访问到</code>，web下其实遇到的较少，一般不同的线程会建立不同的实例，但是也有单个实例被多个线程访问到的情况，比如网上看到的一个利用<code>i++</code>全局变量作为<code>sessionId</code> <a href="http://www.blogjava.net/aoxj/archive/2012/06/16/380926.html" target="_blank" rel="noopener">链接</a>。</li>
<li>方法内的”局部”变量，这种在实际中发生的较少，问题发生在：<code>方法内定义变量，方法内部再启动多个Thread，此时&quot;局部&quot;变量就成了新启动的几个线程的共享变量了</code>，测试类：<a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/MethodVaribleSecurity.java" target="_blank" rel="noopener">MethodVaribleSecurity.java</a></li>
</ol>
<h5 id="7-变量到底怎样的规则存储堆、栈中？"><a href="#7-变量到底怎样的规则存储堆、栈中？" class="headerlink" title="7. 变量到底怎样的规则存储堆、栈中？"></a>7. 变量到底怎样的规则存储堆、栈中？</h5><p> 一般的说法：基础值类型存栈中，对象在堆中。 不管怎样 基础类型、对象不都是定义在class内么，整个实例化后也是对象，那岂不是都在堆中了？<br>比如:<code>Person</code>类，有属性：<code>int age</code>、<code>String name</code>、<code>Array&lt;Person&gt; friends</code>，分析下这个类的实例时如何存储的吧。<br><a href="http://blog.csdn.net/ghost_programmer/article/details/40891735" target="_blank" rel="noopener">java中数据的5种存储位置(堆与栈)</a><br><a href="http://www.linmuxi.com/2016/06/13/jvm-note-javamemoryarea/" target="_blank" rel="noopener">《深入理解Java虚拟机》-Java内存区域</a></p>
<h5 id="8-Thread-threaNew-new-Thread-existsThread-中-existsThread-的状态-对threadNew有什么影响？"><a href="#8-Thread-threaNew-new-Thread-existsThread-中-existsThread-的状态-对threadNew有什么影响？" class="headerlink" title="8. Thread threaNew = new Thread(existsThread) 中 existsThread 的状态 对threadNew有什么影响？"></a>8. <code>Thread threaNew = new Thread(existsThread)</code> 中 <code>existsThread</code> 的状态 对<code>threadNew</code>有什么影响？</h5><p><a href="https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/thread/exception/NewThreadForThread.java" target="_blank" rel="noopener">new Thread(existsThread)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/04/06/java多线程编程核心技术/" data-id="cjk0gupad005pa3rjdr56olha" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/" class="article-date">
  <time datetime="2017-03-23T05:41:15.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/">Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Thread-线程类-join方法实现如下"><a href="#Thread-线程类-join方法实现如下" class="headerlink" title="Thread 线程类 join方法实现如下"></a>Thread 线程类 <code>join</code>方法实现如下</h4><p>都知道<code>join()</code> 经常用于等待前一个线程执行完毕，再执行后面的任务，那<code>join()</code>方法是如何做到这个”等待”的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>                                                                                                                        </span></span><br><span class="line"><span class="function"> 2 <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="number">3</span> |   <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line"> <span class="number">4</span> |   <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> |   <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">7</span> |   |   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line"> <span class="number">8</span> |   &#125;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> |   <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="number">11</span> |   |   <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line"><span class="number">12</span> |   |   |   wait(<span class="number">0</span>);</span><br><span class="line"><span class="number">13</span> |   |   &#125;</span><br><span class="line"><span class="number">14</span> |   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">15</span> |   |   <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line"><span class="number">16</span> |   |   |   <span class="keyword">long</span> delay = millis - now;</span><br><span class="line"><span class="number">17</span> |   |   |   <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">18</span> |   |   |   |   <span class="keyword">break</span>;</span><br><span class="line"><span class="number">19</span> |   |   |   &#125;</span><br><span class="line"><span class="number">20</span> |   |   |   wait(delay);</span><br><span class="line"><span class="number">21</span> |   |   |   now = System.currentTimeMillis() - base;</span><br><span class="line"><span class="number">22</span> |   |   &#125;</span><br><span class="line"><span class="number">23</span> |   &#125;</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<ol>
<li>方法无<code>static</code>修饰，说明其为<strong>线程实例</strong>的方法</li>
<li>方法有<code>syncrhonized</code>修饰，意味着可能需要竞争锁才能进入方法，进入这个方法后将锁住<strong>线程实例</strong>这个对象</li>
<li>第<code>10</code>行<code>if</code>代码块内的即是<code>join()</code>的实现</li>
<li>逻辑：<code>判断 线程实例 isAlive()返回的是 true，则 wait(0)， 然后再次进入前面的判断，否则退出</code>，也就是在目标线程执行完毕前，这里会不断循环取状态判断、wait(0)， 这里的<code>不断</code>即起到了<code>当前线程等待目标线程执行完毕的作用了</code></li>
</ol>
<p>这里的做法看起来就像这个思路，<code>比如需要等某人做完了一些事，我们再去做另外一件事，那么我们可不断的去问这个人他是不是做完了那些事</code></p>
<h4 id="那么我们能将join方法中的wait-0-用sleep-0-替代吗？"><a href="#那么我们能将join方法中的wait-0-用sleep-0-替代吗？" class="headerlink" title="那么我们能将join方法中的wait(0)用sleep(0)替代吗？"></a>那么我们能将<code>join</code>方法中的<code>wait(0)</code>用<code>sleep(0)</code>替代吗？</h4><p>实验一下吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSyncMethodLockAlive</span> </span>&#123;                                                                                                                                  </span><br><span class="line"> <span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="number">3</span>         Thread targetThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> <span class="number">4</span>             System.out.println(<span class="string">"target begin run state="</span> + Thread.currentThread().getState());</span><br><span class="line"> <span class="number">5</span>             sleep(<span class="number">1000</span>); <span class="comment">// 模拟目标线程做某些事情，比如查询数据库</span></span><br><span class="line"> <span class="number">6</span>             System.out.println(<span class="string">"target end  run state="</span> + Thread.currentThread().getState());</span><br><span class="line"> <span class="number">7</span>         &#125;, <span class="string">"target-thread"</span>);</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>         <span class="comment">// 定时输出 目标线程的状态 与 isAlive 值</span></span><br><span class="line"><span class="number">10</span>         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="number">12</span>                 System.out.printf(<span class="string">"### log ### targetThread: state=%s, isAlvie=%s\n"</span>, targetThread.getState(), targetThread.isAlive());</span><br><span class="line"><span class="number">13</span>                 <span class="keyword">if</span> (!targetThread.isAlive() &amp;&amp; !targetThread.getState().equals(Thread.State.NEW)) &#123;</span><br><span class="line"><span class="number">14</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">15</span>                 &#125;</span><br><span class="line"><span class="number">16</span>                 sleep(<span class="number">500</span>);</span><br><span class="line"><span class="number">17</span>             &#125;</span><br><span class="line"><span class="number">18</span>             System.out.printf(<span class="string">"### log ### targetThread: state=%s, isAlvie=%s\n"</span>, targetThread.getState(), targetThread.isAlive());</span><br><span class="line"><span class="number">19</span>         &#125;).start();</span><br><span class="line"><span class="number">20</span>         targetThread.start();</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>         <span class="comment">// 模拟 Thread 的 join 方法</span></span><br><span class="line"><span class="number">23</span>         <span class="keyword">synchronized</span> (targetThread) &#123;</span><br><span class="line"><span class="number">24</span>             <span class="keyword">while</span> (targetThread.isAlive()) &#123; <span class="comment">// 取线程状态</span></span><br><span class="line"><span class="number">25</span>                 targetThread.wait(<span class="number">0</span>);</span><br><span class="line"><span class="number">26</span>             &#125;</span><br><span class="line"><span class="number">27</span>             System.out.println(<span class="string">"synchronized anlog join over."</span>);</span><br><span class="line"><span class="number">28</span>         &#125;   </span><br><span class="line"><span class="number">29</span>     &#125;   </span><br><span class="line"><span class="number">30</span>     </span><br><span class="line"><span class="number">31</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">33</span>             Thread.sleep(millis);</span><br><span class="line"><span class="number">34</span>         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="number">35</span>             e.printStackTrace();</span><br><span class="line"><span class="number">36</span>         &#125;   </span><br><span class="line"><span class="number">37</span>     &#125;   </span><br><span class="line"><span class="number">38</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们用<code>23-28</code>行<code>wait(0)</code>的模式模拟了<code>Thread</code>的<code>join</code>方法，运行测试下，没有问题。 下面我们尝试把<code>25</code>行替换为<code>Thread.sleep(0);</code>测试下，发现控制台打印没有停止,输出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target begin run state=RUNNABLE</span><br><span class="line">### log ### targetThread: state=RUNNABLE, isAlvie=true</span><br><span class="line">### log ### targetThread: state=TIMED_WAITING, isAlvie=true</span><br><span class="line">target end  run state=RUNNABLE</span><br><span class="line">### log ### targetThread: state=BLOCKED, isAlvie=true</span><br><span class="line">### log ### targetThread: state=BLOCKED, isAlvie=true</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>分析下：</p>
<ol>
<li><code>taget end run</code> 的输出意味着线程内部的代码已经运行结束了，但是目标线程状态的<code>isAlvie()</code>返回的true，所以我们期盼的<code>27</code>行也不会打印</li>
<li>为什么线程内部代码执行完了，还是alive的呢？ 我们发现：线程状态由<code>RUNNABLE</code>转为<code>BLOCKED</code>状态，而不是期望值<code>TERMINATED</code></li>
<li>状态为<code>BLOCKED</code> 意味着线程阻塞，线程等待某个锁 ，死锁了？ 我们一起来分析下堆栈内存</li>
</ol>
<h5 id="分析堆栈内存"><a href="#分析堆栈内存" class="headerlink" title="分析堆栈内存"></a>分析堆栈内存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps <span class="comment"># 拿到进程 pid</span></span><br><span class="line">$ jstack -l pid <span class="comment"># 直接查看下 堆栈信息，可以发现："target-thread" BLOCKED ，但是好像没有发现 "deadlock" 的信息，没有发现死锁那为什么还会一直等待呢？</span></span><br><span class="line"><span class="comment"># jconsole.exe 也可以查看</span></span><br><span class="line"><span class="comment"># $ jmap -dump:live,format=b,file=heap.bin pid # 将堆栈信息导出至文件，离线分析下</span></span><br></pre></td></tr></table></figure>
<p>可以看以下信息(截取了部分)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 &quot;target-thread&quot; #10 prio=5 os_prio=0 tid=0x000000001d5f4000 nid=0x24140 waiting for monitor entry [0x0000000000000000]                                                  </span><br><span class="line"> 2    java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> 3 &quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x000000001bf06800 nid=0x21a24 in Object.wait() [0x000000001d15f000]</span><br><span class="line"> 4    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"> 5         at java.lang.Object.wait(Native Method)</span><br><span class="line"> 6         - waiting on &lt;0x000000076b406f58&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"> 7         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line"> 8             - locked &lt;0x000000076b406f58&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"> 9         at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">10         at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line">11 &quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002458000 nid=0x244ec runnable [0x000000000293f000]</span><br><span class="line">12    java.lang.Thread.State: RUNNABLE</span><br><span class="line">13         at java.lang.Thread.sleep(Native Method)</span><br><span class="line">14         at commu.TestSyncMethodLockAlive.main(TestSyncMethodLockAlive.java:31)</span><br><span class="line">15         - locked &lt;0x000000076b4b1c40&gt; (a java.lang.Thread)</span><br></pre></td></tr></table></figure></p>
<p>内容分析</p>
<ol>
<li>第<code>1-2</code>行: <code>target-thread</code> waiting for monitor entry ` 意味“在等待进入一个临界区， ”，这里的信息没有期望的”-waiting to lock<0xx>“ 不能看出来到底是被哪个锁阻塞。 (jconsole中都看不到此线程了)</0xx></li>
<li>第<code>11-15</code>行: <code>main</code>方法运行的主线程<code>，主线程一直处于</code>RUNNABLE<code>状态，并且持有锁</code>- locked <0x764b1c40>`</0x764b1c40></li>
<li>第<code>3-10</code>行：daemon类型，一般为jvm守护线程，这里的<code>Finalizer</code>线程主要是给执行完<code>run</code>的线程处理一些<code>身后事</code>，比如将线程移除引用队列。可以看出这里等待的锁，不是直接<code>main</code>线程持有的锁，而是线程本身在此前<code>locked</code>的一个锁，只是这里在等待外部调用某个方法来<code>notify</code>唤醒线程，而间接的在外部依赖了<code>main</code>一直持有的锁，而这个外部可能是在<code>native</code>中而无法跟踪了。</li>
</ol>
<p>思考弯路：</p>
<ol>
<li><code>synchronized</code> 不是一直持有 线程对象的锁么， 为何 “target-thread”线程在等待锁？  —-&gt;   <code>synchronized</code>是main方法持有了锁, “target-thread” 是线程内部需要这个锁</li>
</ol>
<p>总结：</p>
<ol>
<li>创建的线程运行完<code>run</code>方法后，线程调度器对其还有<code>身后事</code>要处理的，并且间接同步的使用到“线程实例”，并且这个”间接”不好追踪，所以最好不要再线程实例外部来将线程实例作为同步条件来使用。</li>
<li>线程内做的操作影响线程本身的状态</li>
<li>将“线程实例”作为锁与“普通对象”作为锁本质一样，将其普通看待不要受到干扰，所以不要把<code>targetThread.wait()</code>方法看的特殊了，理解为<code>lock.wait()</code>就好</li>
</ol>
<h4 id="回到之前的问题“我们能将wait-0-用sleep-0-替代吗？”"><a href="#回到之前的问题“我们能将wait-0-用sleep-0-替代吗？”" class="headerlink" title="回到之前的问题“我们能将wait(0)用sleep(0)替代吗？”"></a>回到之前的问题“我们能将<code>wait(0)</code>用<code>sleep(0)</code>替代吗？”</h4><p>其实从控制台打印信息，可以看出<code>isAlive返回的一直为true，因为&quot;身后事&quot;的处理被阻塞，所以线程还是alive的，但是线程状态已经由&quot;RUNNABLE&quot;转变为&quot;BLOCKED&quot;了</code>.</p>
<p><img src="/images/xbq/idea.gif" alt="">那么我们可以将我们的<code>while (targetThread.isAlive())</code> 的判断条件修改下<code>while (!targetThread.getState().equals(Thread.State.BLOCKED))</code> 修改好了接着测试看下控制台的输出吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### log ### targetThread: state=TIMED_WAITING, isAlvie=true</span><br><span class="line">target end  run state=RUNNABLE</span><br><span class="line">synchronized anlog join over.</span><br></pre></td></tr></table></figure></p>
<p>bingo! 按我们期盼的顺序输出了 <img src="/images/xbq/big-laugh.gif" alt=""></p>
<p>高兴的有些早了，多运行几次发现有时候会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synchronized anlog join over.BLOCKED</span><br><span class="line">target begin run state=RUNNABLE</span><br></pre></td></tr></table></figure></p>
<p>main先结束，target才开始，再次证明多线程问题的偶发性，一不小心就以为万事大吉，其实已经暗藏危机了。其实我们这里的根本原因是<code>忽略了除了NEW/TERMINATED状态，其它的几个线程状态都有可能随意切换</code>。 我们这里单纯认为<code>BLOCKED</code>就是由处理“身后事”造成的，是不严谨的，这里多种其他的情况情况要处理比如:</p>
<ol>
<li><code>targetThread.start()</code>是<code>synchronized</code>方法，如果它比main<code>synchronized</code>块后拿到锁，会造成线程<code>BLOCKED</code></li>
<li><code>run</code>方法内部的<code>System.out.println</code>方法为同步方法也有可能造成线程 <code>BLOCKED</code> [这也是为什么在打包的代码里最好不要出现<code>System.out.println</code>的原因]</li>
<li><code>run</code>方法内部的<code>Thread.sleep(1000)</code> 是<code>native</code>的，经测试这里暂时<code>不会造成BLOCKED</code>，但是这里是模拟的业务，如果真实业务访问数据库、读写文件等操作其他资源都有可能造成<code>BLOCKED</code></li>
</ol>
<p>现有情况的解决方式：</p>
<ol>
<li>基于<code>1</code>的问题，可以在<code>targetThread.start()后再 sleep(50)</code></li>
<li><code>2</code>的问题，将打印信息的方式改为<code>logger</code>方式输出，比如<code>java.util.logging.Logger.getGlobal().info</code>非阻塞来替代</li>
<li><code>3</code>如果只是基于我们现有的模拟任务，不用修改可以暂时满足。</li>
</ol>
<p>结论：<strong>基于上面的测试代码</strong>，可以用<code>sleep(0)</code>代替<code>wait(0)</code>的方式来达到<code>join()</code>的效果。</p>
<p>我们根据日志结果做了不科学的事情：利用判断 thread.getState() 尝试代替 thread.isAlvie() 。只有状态<code>NEW</code>与<code>TERMINATED</code>时isAlive()为false，其他状态对应的都是true;</p>
<p><strong>不科学的使用，将给你带来各种意外，需要步步跟踪测试才能做出严谨的判断，除非你只是本着探索的心在学习，否则不建议这样使用</strong></p>
<h4 id="技能点："><a href="#技能点：" class="headerlink" title="技能点："></a>技能点：</h4><ol>
<li>线程状态 - <a href="https://github.com/elegance/dev-demo/blob/master/java-demo/thread/ThreadStateTest.java" target="_blank" rel="noopener">帮助理解线程状态的例子</a><ul>
<li><code>NEW</code> 创建了未 start</li>
<li><code>RUNNABLE</code> 有可能正在运行(RUNNING)，也有可能在就绪队列中(Ready)，这个取决于 线程调度器</li>
<li><code>TIMED_WAITING</code> 挂起，等待指定的时间后自动恢复</li>
<li><code>WATING</code> 挂起，被动恢复，依赖其他线程的操作才会唤醒</li>
<li><code>BLOCKED</code> 阻塞，被动恢复执行，依赖其他线程释放相关资源的锁</li>
<li><code>TERMINATED</code> 执行完毕的线程</li>
</ul>
</li>
<li><code>wait()</code>、<code>wait(long)</code><ul>
<li><code>wait()</code>释放锁，线程进入<code>WAITING</code>状态，无限期等待另一个线程执行某一操作，如在锁对象上执行<code>notify()</code>/<code>notifyAll()</code></li>
<li><code>wait(long)</code>释放锁，线程进入<code>TIMED_WAITING</code>，等待指定的时间<strong>自动</strong>结束指定</li>
</ul>
</li>
<li><code>sleep(long)</code><ul>
<li><code>sleep(long)</code> 如果在同步块内，线程将不会释放锁，一直持有，线程进入<code>TIMED_WAITING</code>，等待指定的时间<strong>自动</strong>往下执行</li>
</ul>
</li>
<li>java dump 分析：<ul>
<li><a href="http://www.blogjava.net/freeman1984/archive/2015/12/14/428645.html" target="_blank" rel="noopener">JAVA Thread Dump 分析综述</a></li>
<li><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a></li>
<li><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/03/23/Thread类join方法中的 wait(0) 能用 sleep(0) 来替代模拟吗/" data-id="cjk0gup8o002ja3rj1rc2dnac" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vim-技巧手记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/22/vim-技巧手记/" class="article-date">
  <time datetime="2017-03-22T03:28:00.000Z" itemprop="datePublished">2017-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/22/vim-技巧手记/">vim 技巧手记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>根据文件内容查找文件：<code>vimgrep</code></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">vimgrep</span> /Exception/ *.<span class="built_in">log</span>    #查找目录下  所有含Exception 的 .<span class="built_in">log</span>文件</span><br><span class="line">:<span class="keyword">vimgrep</span> /Exception/ */*.<span class="built_in">log</span> # 遍历子目录</span><br><span class="line">#搜索到的文件列表会加入到quickfix中去，执行:</span><br><span class="line">:<span class="keyword">copen</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序，删除重复行</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">sort</span>   //可以直接排序，这个太好用了</span><br><span class="line">:g/^\(.*\)$\n\<span class="number">1</span>$/d                      #去除重复行</span><br><span class="line">:g/\%(^\<span class="number">1</span>$\n\)\@&lt;=\(.*\)$/d     #功能同上，也是去除重复行</span><br><span class="line">:g/\%(^\<span class="number">1</span>\&gt;.*$\n\)\@&lt;=\(\<span class="keyword">k</span>\+\).*$/d  #功能同上，也是去除重复行</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找忽略大小写</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> ic  #忽略大小写 <span class="keyword">set</span> ignorecase</span><br><span class="line">:<span class="keyword">set</span> noic #不忽略大小写</span><br></pre></td></tr></table></figure>
</li>
<li><p>标记复制、粘贴</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">"ay</span></span><br><span class="line"><span class="comment">"ap</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数字递增</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入模式下：Ctrl+r  ===&gt; =(等号) ===&gt; <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>)  回车</span><br><span class="line"># 格式化补齐 <span class="number">4</span> 位，<span class="number">0001</span>,<span class="number">0002</span>....</span><br><span class="line">=<span class="keyword">map</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>), <span class="string">'printf('</span><span class="string">'%04d'</span><span class="string">', v:val)'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多文件内容查找替换</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">args</span> *.jsp  #第一步：择定范围 *.jsp</span><br><span class="line">:<span class="keyword">argdo</span> %s#<span class="symbol">&lt;title&gt;</span>光大保德信&lt;/title&gt;#<span class="symbol">&lt;title&gt;</span>光大保德信基金&lt;/title&gt;#gc|<span class="keyword">update</span>   #替换内容“|<span class="keyword">update</span>”执行替换后并且存盘。</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除/保留匹配的行</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:g/pattern/d # 用于删除带有指定搜索内容的行</span><br><span class="line">:g!/pattern/d 用于删除不带指定搜索内容的行</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除空白行</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^\s*$/d</span><br></pre></td></tr></table></figure>
</li>
<li><p>html标签选中、内容选中</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vat #整个标签</span><br><span class="line">vit #标签的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则替换</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:%s#(<span class="string">"\([A-Z_]\+\)"</span>)#<span class="string">'\1'</span>#g</span><br><span class="line">-- 功能将  (<span class="string">"BIT"</span>) 替换为 <span class="string">'BIT'</span>，将两边的括号去除了，将双引号改为了单引号</span><br><span class="line">-- %s 表示在所有行中搜索替换，若要指定范围可以写成：<span class="number">1</span>,<span class="number">10</span>s、<span class="number">10</span>s、<span class="number">1</span>,$s 分别表示：<span class="number">1</span>-<span class="number">10</span>行、只在第<span class="number">10</span>行、<span class="number">1</span>-最后一行</span><br><span class="line">-- # 跟在上面的s后面，表示使用其作为分隔符，因为/分隔符经常会用于替换内容，使用到就得转义比较麻烦</span><br><span class="line">-- \(、\)、\+、\<span class="number">1</span> 这些是正则表达式的内容，前面两个表示分组捕获，\+ 表示表达式的匹配次数还有*、?等等，\<span class="number">1</span> 则是取前面捕获的第一个分组的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>粘贴时取消小自动缩进</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> paste # 开启paste模式</span><br><span class="line">:<span class="keyword">set</span> nopaste # 粘贴完毕关闭paste模式</span><br></pre></td></tr></table></figure>
</li>
<li><p>BOM标记相关</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> nobomb #去掉BOM标记</span><br><span class="line">:<span class="keyword">set</span> bomb #加上BOM标记</span><br><span class="line">:<span class="keyword">set</span> bomb? # 查询当前是否有BOM标记</span><br><span class="line">:%!xxd #以<span class="number">16</span>进制模式打开文件，可以看到具体的大端标记或小端标记</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回符合查找条件的个数（下面返回yes出现的次数）</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/yes//gn</span><br></pre></td></tr></table></figure>
</li>
<li><p>大小写替换 (<a href="https://github.com/wsdjeg/vim-galore-zh_cn#%E5%8A%A8%E4%BD%9C%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">动作，操作符，文本对象</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ # swap case: Upercase/lowercase</span><br><span class="line">U # Upcase</span><br><span class="line">u # lowercase</span><br><span class="line">gU$ # go Upcase line end</span><br><span class="line">gu$ # go lowercase line end</span><br><span class="line">gUU # 类似 dd,  UU, uu, ~~ 都具有“双击”整行生效的特性</span><br><span class="line"># all operation see: :h operation</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/03/22/vim-技巧手记/" data-id="cjk0gup9a003oa3rj2fntlrt8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Read-Later" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/10/Read-Later/" class="article-date">
  <time datetime="2017-03-10T07:54:02.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/10/Read-Later/">Read Later</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>建立这个<code>Read Later</code>的初衷：一些好的资料没有吸收完全，用其它闲暇的时间来继续吸收，手机、其他PC都可访问。</p>
<hr>

<h3 id="2017年8月4日09-03-44"><a href="#2017年8月4日09-03-44" class="headerlink" title="2017年8月4日09:03:44"></a>2017年8月4日09:03:44</h3><ol>
<li><a href="http://ifeve.com/use-bean-validation/" target="_blank" rel="noopener">java Bean Validation</a></li>
</ol>
<h3 id="2017年7月5日13-51-38"><a href="#2017年7月5日13-51-38" class="headerlink" title="2017年7月5日13:51:38"></a>2017年7月5日13:51:38</h3><ol>
<li><a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html" target="_blank" rel="noopener">幂等性的应用</a></li>
</ol>
<h3 id="2017年5月23日15-30-51"><a href="#2017年5月23日15-30-51" class="headerlink" title="2017年5月23日15:30:51"></a>2017年5月23日15:30:51</h3><ol>
<li><a href="https://blog.oyanglul.us/javascript/functional-javascript.html#sec-2-2" target="_blank" rel="noopener">js之 函数式编程、柯里化、组合等</a></li>
<li><a href="https://blog.oyanglul.us/javascript/react-transdux-the-clojure-approach-of-flux.html" target="_blank" rel="noopener">react、flux-看我们3天 hackday 都干了些什么</a></li>
<li><a href="https://github.com/jasonslyvia/a-cartoon-intro-to-redux-cn" target="_blank" rel="noopener">看漫画，学 Redux</a></li>
</ol>
<h3 id="2017年5月3日10-17-04"><a href="#2017年5月3日10-17-04" class="headerlink" title="2017年5月3日10:17:04"></a>2017年5月3日10:17:04</h3><ol>
<li>线程池文章：<ol>
<li><a href="http://www.kuqin.com/shuoit/20160714/352643.html" target="_blank" rel="noopener">Java 线程池框架核心代码分析</a></li>
<li><a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener"> Java并发编程与技术内幕:线程池深入理解</a></li>
</ol>
</li>
</ol>
<h3 id="2017年4月14日15-05-05"><a href="#2017年4月14日15-05-05" class="headerlink" title="2017年4月14日15:05:05"></a>2017年4月14日15:05:05</h3><ol>
<li><a href="http://daily.zhihu.com/story/4369215" target="_blank" rel="noopener">旧文重读-有哪些生活小习惯，慢慢地可以改变一个人的性格或者生活</a></li>
<li><a href="http://www.read.org.cn/" target="_blank" rel="noopener">非技术-战隼的学习探索</a></li>
<li><a href="https://www.zhihu.com/people/warfalcon/answers" target="_blank" rel="noopener">知乎-每天一本书的人-经典回答</a></li>
</ol>
<h3 id="2017年4月1日09-07-00"><a href="#2017年4月1日09-07-00" class="headerlink" title="2017年4月1日09:07:00"></a>2017年4月1日09:07:00</h3><ol>
<li>javap 反汇编器，查看java编译器生成的字节码<ol>
<li><a href="http://blog.csdn.net/junsure2012/article/details/7099222" target="_blank" rel="noopener">javap -c命令详解</a></li>
<li><a href="http://www.cnblogs.com/luyanliang/p/5498584.html" target="_blank" rel="noopener">JVM字节码之整型入栈指令(iconst、bipush、sipush、ldc)</a></li>
<li><a href="http://www.linmuxi.com/2016/06/27/jvm-note-classfile/" target="_blank" rel="noopener">读《深入理解Java虚拟机》-类文件结构</a></li>
</ol>
</li>
<li><a href="https://www.zhihu.com/question/51534501" target="_blank" rel="noopener">有什么相见恨晚的小知识？</a></li>
<li><a href="https://www.zhihu.com/question/26677313/answer/34173739" target="_blank" rel="noopener">你有什么相见恨晚的英语学习方法？</a></li>
</ol>
<h3 id="2017年3月31日13-24-12"><a href="#2017年3月31日13-24-12" class="headerlink" title="2017年3月31日13:24:12"></a>2017年3月31日13:24:12</h3><ol>
<li><a href="http://blog.csdn.net/Evankaka/article/details/58265019" target="_blank" rel="noopener">Java的Spi机制研究</a></li>
</ol>
<h3 id="2017年3月24日09-59-55"><a href="#2017年3月24日09-59-55" class="headerlink" title="2017年3月24日09:59:55"></a>2017年3月24日09:59:55</h3><ol>
<li><a href="http://blog.csdn.net/yunnysunny/article/details/17482175" target="_blank" rel="noopener">oauth2简单原理描述</a></li>
</ol>
<h3 id="2017年3月17日10-56-38-（java性能调优）"><a href="#2017年3月17日10-56-38-（java性能调优）" class="headerlink" title="2017年3月17日10:56:38 （java性能调优）"></a>2017年3月17日10:56:38 （java性能调优）</h3><ol>
<li>jps、jstack等工具排查问题、微信收藏java 排查问题文章的整理<ol>
<li><a href="http://www.cnblogs.com/chengJAVA/p/5821218.html" target="_blank" rel="noopener">JVM调优之jstack找出最耗cpu的线程并定位代码</a></li>
<li><a href="http://blog.csdn.net/feihong247/article/details/7874063" target="_blank" rel="noopener"> Java自带的性能监测工具用法简介——jstack、jconsole、jinfo、jmap、jdb、jsta、jvisualvm</a></li>
</ol>
</li>
<li>javap 查看编译版本信息，主要用于<code>Bad version</code>错误，<a href="http://www.blogjava.net/aoxj/archive/2013/02/17/395349.html" target="_blank" rel="noopener">使用javap命令查看编译版本信息</a></li>
<li><a href="http://www.blogjava.net/aoxj/MyPosts.html" target="_blank" rel="noopener">编码最佳实践</a><ol>
<li><a href="http://www.blogjava.net/aoxj/archive/2012/09/06/387170.html" target="_blank" rel="noopener">编码最佳实践(5)–小心！这只是冰山一角</a> - 意想不到的保留了原始对象的引用</li>
</ol>
</li>
<li><a href="http://www.iteye.com/topic/806990" target="_blank" rel="noopener">java线程安全总结</a> 其中有<code>有序性</code>相关，待消化</li>
<li>好文<a href="http://www.blogjava.net/aoxj/archive/2007/12/05/165536.html" target="_blank" rel="noopener">sun的java编译器对string常量表达式的处理和优化</a> - 关键字：编译器优化、运行时、基本类型、常量优化、final、final 方法</li>
<li><a href="http://www.blogjava.net/aoxj/archive/2008/01/11/174728.html" target="_blank" rel="noopener">浅谈spring和依赖注入的价值</a> - 关键字：解耦、抽象、分离、provider，扩展思考：依赖注入–对比–内部接口实现、容器IOC</li>
<li><a href="http://blog.csdn.net/Soft_Po/article/details/53761198" target="_blank" rel="noopener">java常见面试题</a></li>
</ol>
<h3 id="2017年3月14日09-27-57（构师-类图-设计）"><a href="#2017年3月14日09-27-57（构师-类图-设计）" class="headerlink" title="2017年3月14日09:27:57（构师-类图-设计）"></a>2017年3月14日09:27:57（构师-类图-设计）</h3><ol>
<li><a href="http://blog.csdn.net/wqewq19/article/details/52931890" target="_blank" rel="noopener"> 架构师之UML类别图，顺序图，用例图，活动图</a></li>
</ol>
<h3 id="2017年3月13日13-56-26"><a href="#2017年3月13日13-56-26" class="headerlink" title="2017年3月13日13:56:26"></a>2017年3月13日13:56:26</h3><ol>
<li><a href="http://www.tuicool.com/articles/yiyy6bI" target="_blank" rel="noopener">乐观锁的一种实现方式——CAS</a></li>
<li><a href="http://www.tuicool.com/articles/ru6vUvn" target="_blank" rel="noopener">深入理解Java虚拟机笔记—原子性、可见性、有序性</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/index.html" target="_blank" rel="noopener">Java 理论与实践: 流行的原子</a><br>Q1: 乐观锁的CAS Atomic类的应用<br>Q2: jdk 5.0 由锁方案改为 原子变量实现 和 需要时进行锁定<br>Q3: 原子性、可见性、有序性的理解</li>
</ol>
<h3 id="2017年3月10日16-31-43"><a href="#2017年3月10日16-31-43" class="headerlink" title="2017年3月10日16:31:43"></a>2017年3月10日16:31:43</h3><ol>
<li><a href="http://www.cnblogs.com/iliuyuet/p/5603618.html" target="_blank" rel="noopener">java堆、栈、堆栈的区别</a>  </li>
<li><a href="http://blog.csdn.net/ghost_programmer/article/details/40891735" target="_blank" rel="noopener">java中数据的5种存储位置(堆与栈)-生命周期</a></li>
<li><a href="http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html" target="_blank" rel="noopener">git reset revert 回退回滚取消提交返回上一版本</a> 整理入=&gt; <a href="../_drafts/git常用命令.md">git常用命令</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/03/10/Read-Later/" data-id="cjk0gup8l002da3rjx0rtmlod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-svn-分支管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/svn-分支管理/" class="article-date">
  <time datetime="2017-03-08T09:20:15.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/svn-分支管理/">svn 分支管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.iteye.com/topic/28013" target="_blank" rel="noopener">参考</a></p>
<h2 id="1-svn-初始目录结构"><a href="#1-svn-初始目录结构" class="headerlink" title="1. svn 初始目录结构"></a>1. svn 初始目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\pro-repo</span><br><span class="line">├─branches</span><br><span class="line">├─tags</span><br><span class="line">└─trunk</span><br></pre></td></tr></table></figure>
<p>如果没有对应的结构目录，可以使用以下命令来创建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn mkdir branches</span><br></pre></td></tr></table></figure></p>
<h2 id="2-branchs-tags-的建立"><a href="#2-branchs-tags-的建立" class="headerlink" title="2. branchs/tags 的建立"></a>2. branchs/tags 的建立</h2><p>需求一：产品开发已经基本完成，并且通过很严格的测试，这时候我们就想发布给客户使用，发布我们的1.0版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy svn://server/trunk svn://server/tags/release-1.0 -m <span class="string">"1.0 released"</span></span><br></pre></td></tr></table></figure>
<p>需求二: 需要开发一个新的功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy svn://server/trunk svn://server/branches/fea-01 -m <span class="string">"新开分支开发01新需求"</span></span><br></pre></td></tr></table></figure></p>
<p>咦，这个和branches有什么区别，好像啥区别也没有？<br>是的，branches和tags是一样的，都是目录，只是我们不会对这个release-1.0的tag做修改了，不再提交了，如果提交那么就是branches </p>
<p>需求三：有一天，突然在线上发现一个致命的bug,那么所有的branches一定也一样了，该怎么办？<br>首先我们是从线上发现的，那么我第一步先：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy svn://server/tags/release-1.0 svn://server/branches/bugfix-01 -m <span class="string">"1.0 线上bug (copy from tags/release-1.0) "</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们拉去分支<code>bugfix-01</code>代码到本地，开发、测试，如果没有问题的话，合并分支到<code>在生命周期</code>的分支，这里是：<code>branches/fea-01</code>、<code>trunk/</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn -r 6:7 merge  https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-01 trunk <span class="comment"># bug 合并至主干</span></span><br><span class="line">$ svn -r 0:HEAD merge https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/trunk branches/fea-01 <span class="comment"># 主干合并至需求分支</span></span><br><span class="line">$ svn delete  https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-01 -m <span class="string">"删除-bug-01"</span></span><br></pre></td></tr></table></figure></p>
<p>新的bug产生时(上次升级没有打tag，直接取trunk):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ svn copy https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/trunk https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-02 -m <span class="string">"1.0 线上bug (copy from trunk) "</span></span><br><span class="line">$ <span class="built_in">cd</span> trunk/</span><br><span class="line">$ svn mergeinfo https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-02  --show-revs eligible <span class="comment"># 查看Branch中那些改动还未合并 </span></span><br><span class="line">$ svn merge https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-02 <span class="comment"># bug 合并至主干 （和上面的指定版本功能效果一样，这里省去了指定版本的麻烦）</span></span><br><span class="line">$ svn mergeinfo https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-02 <span class="comment"># 查看当前Branch中已经有那些改动已经被合并到Trunk中</span></span><br><span class="line">$ <span class="built_in">cd</span> ../branches/fea-01</span><br><span class="line">$ svn merge https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/trunk <span class="comment"># 主干合并至分支fea-01</span></span><br></pre></td></tr></table></figure></p>
<p>合并后对 trunk 严格测试没问题的话，就可以发布<code>release-1.1</code>了。</p>
<h2 id="3-几个问题"><a href="#3-几个问题" class="headerlink" title="3. 几个问题"></a>3. 几个问题</h2><h4 id="1-考虑到部署release时，每次都要打上tag，会略显繁琐，-tags-不一定非得有，也就是上面用trunk作为线上分支"><a href="#1-考虑到部署release时，每次都要打上tag，会略显繁琐，-tags-不一定非得有，也就是上面用trunk作为线上分支" class="headerlink" title="1. 考虑到部署release时，每次都要打上tag，会略显繁琐， tags 不一定非得有，也就是上面用trunk作为线上分支"></a>1. 考虑到部署release时，每次都要打上tag，会略显繁琐， <code>tags</code> 不一定非得有，也就是上面用<code>trunk</code>作为线上分支</h4><h4 id="2-上面有提到在生命周期的分支，这是为了强调branchs下的分支尽可能缩短其生命周期，因为在生命周期的分支都得维护，线上bug、其他分支新功能这些代码所有修改都得合并入在生命周期的分支"><a href="#2-上面有提到在生命周期的分支，这是为了强调branchs下的分支尽可能缩短其生命周期，因为在生命周期的分支都得维护，线上bug、其他分支新功能这些代码所有修改都得合并入在生命周期的分支" class="headerlink" title="2. 上面有提到在生命周期的分支，这是为了强调branchs下的分支尽可能缩短其生命周期，因为在生命周期的分支都得维护，线上bug、其他分支新功能这些代码所有修改都得合并入在生命周期的分支"></a>2. 上面有提到<code>在生命周期</code>的分支，这是为了强调<code>branchs</code>下的分支尽可能缩短其生命周期，因为在生命周期的分支都得维护，线上bug、其他分支新功能这些代码所有修改都得合并入<code>在生命周期</code>的分支</h4><p>在生命周期的分支，一般有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trunk/</span><br><span class="line"></span><br><span class="line">branches/fea-01</span><br><span class="line">branches/fea-02</span><br><span class="line">branches/fea-....</span><br><span class="line"></span><br><span class="line">branches/bugfix-01</span><br></pre></td></tr></table></figure></p>
<p>同时开发的需求<code>fea-n</code>可能有几个，<code>bugfix</code>线上bug通常就作为一个了。</p>
<h4 id="3-冲突解决"><a href="#3-冲突解决" class="headerlink" title="3. 冲突解决"></a>3. 冲突解决</h4><p>如果一个文件在两个分支上都被修改，那么合并两个分支时将可能发生冲突。</p>
<p>之所以说可能发生冲突，是因为如果两个分支修改的文件明显不同，<code>merge</code>会自动的帮我们处理好。比如一端对文件第一行修改了内容，一端对文件增加了一行内容这种情况。</p>
<p>当文件发生冲突时可以有以下方式来处理：</p>
<h4 id="工具设置"><a href="#工具设置" class="headerlink" title="工具设置"></a>工具设置</h4><p>我们可以使用<code>TortoiseSVN</code>设置下对比工具来方便我们compare和merge，比如<code>BeyondCompare</code></p>
<p>操作步骤：<code>项目目录-右键</code>  —&gt; <code>TortoiseSVN</code> —&gt; <code>Settings</code> —&gt; <code>Diff Viewer</code><br><img src="http://ww1.sinaimg.cn/large/929194b4gy1ftlvm6ch10j20jf0c03zt.jpg" alt="Diff-tool-set"><br>其中代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\tools\BeyondCompare\Beyond Compare\BCompare.exe&quot; %base %mine /title1=%bname /title2=%yname /leftreadonly</span><br><span class="line">&quot;D:\tools\BeyondCompare\Beyond Compare\BCompare.exe&quot;</span><br></pre></td></tr></table></figure></p>
<p>合并工具设置：<br><img src="http://ww1.sinaimg.cn/large/929194b4gy1ftlvn97kt0j20jf0c0gmg.jpg" alt="merge-tool-set"><br>其中代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\tools\BeyondCompare\Beyond Compare\BCompare.exe&quot;  %mine %theirs %base %merged /title1=%yname /title2=%tname /title3=%bname /title4=%mname</span><br></pre></td></tr></table></figure></p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src="http://ww1.sinaimg.cn/large/929194b4gy1ftlvnmj1ohj20gg0c1wf8.jpg" alt="edit-conflict"><br><img src="http://ww1.sinaimg.cn/large/929194b4gy1ftlvo2po9vj21gc0qojvz.jpg" alt="merging"><br>在上一步合并完后，就可以标记解决完冲突了：<br><img src="http://ww1.sinaimg.cn/large/929194b4gy1ftlvogcfolj20fq0ep0tp.jpg" alt="resolve"></p>
<p><del>#### 3. <code>merge</code>的几种方式及应用场景， 参考<a href="http://chunanyong.iteye.com/blog/697255" target="_blank" rel="noopener">svn分支合并类型</a></del></p>
<h4 id="3-merge-我使用merge的两种方式"><a href="#3-merge-我使用merge的两种方式" class="headerlink" title="3. merge 我使用merge的两种方式"></a>3. <code>merge</code> 我使用merge的两种方式</h4><ol>
<li><p>指定分支地址，合并至当前目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 `bug-01`分支 合并到 `trunk`</span></span><br><span class="line">$ <span class="built_in">cd</span> trunk/</span><br><span class="line">$ svn merge https://server/svn/pro/branches/bug-01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 `trunk` 合并至 分支 `fea-01`</span></span><br><span class="line">$ <span class="built_in">cd</span> ../branches/fea-01</span><br><span class="line">$ svn merge https://server/svn/pro/trunk</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定分支地址和版本，合并至指定分支目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 bugfix-01 分支 合并至trunk</span></span><br><span class="line">$ svn -r 6:7 merge  https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/branches/bugfix-01 trunk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强 trunk 合并至 需求分支</span></span><br><span class="line">$ svn -r 0:HEAD merge https://orh-vm-pc/svn/<span class="built_in">test</span>-tzbms/trunk branches/fea-01</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li><p><strong>以上的<code>svn copy -m &quot;comment&quot;</code>命令会直接发给服务端执行，也就是说操作即时生效，无需手动commit，所以copy时最好加上<code>-m 注释内容</code></strong></p>
</li>
<li><p>一般分支分为两种：需求分支、bug修复分支(暂时撇开tags、trunk)，一般约定其命名规则：<code>fea-xxx</code>、<code>bugfix-xxx</code>，这其实都属于临时性分支，使用完应该删除（为了方便开发，不用每次签出新的bug分支，有时会把把bug作为一个长期性的分支，但要注意与trunk保持同步）。<br>同名分支，重建(同名分支，前bug已经delete)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn copy https://orh-vm-pc/svn/test-tzbms/trunk https://orh-vm-pc/svn/test-tzbms/branches/bugfix-live -m &quot;bug长期分支（完成后delete，需要时同名重建）&quot;</span><br><span class="line">... 修改、测试、合并后</span><br><span class="line">$ svn delete https://orh-vm-pc/svn/test-tzbms/branches/bugfix-live -m &quot;bug长期分支（完成后delete，需要时同名重建）&quot;</span><br><span class="line">... 下次有新的bug时</span><br><span class="line">$ svn copy https://orh-vm-pc/svn/test-tzbms/trunk https://orh-vm-pc/svn/test-tzbms/branches/bugfix-live -m &quot;bug长期分支（完成后delete，需要时同名重建）&quot;</span><br><span class="line">... 重复上面的步骤</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>svn merge</code> merge动作是在本地执行的，所以可以放心执行，如果有出现失误，不提交，使用<code>$ svn revert . -R</code>回滚工作区， 再重新<code>merge</code>分支即可。</p>
</li>
<li><p>合并前保证<code>目标分支</code>是clean的，不要忘记<code>来源分支</code>都提交了</p>
</li>
<li><p>合并完分之后，<strong>切记维护<code>生命周期</code>还未结束的分支</strong>。一般分支的合并都是基于<code>trunk</code>来交互的，这就是说的<strong>经常的与主干保持同步</strong>，比如有以下情况</p>
<ol>
<li>新开分支解决了<code>bug</code>, 新的分支<code>bug-02</code>开发测试完，合入<code>trunk</code>。此时别的分支代码应该也是存在bug的，解决同样的bug我们当然<strong>不需要再在其他分支上手动去修复bug</strong>了，而是把<code>trunk</code>上的修改<strong>尽快</strong><code>merge</code>到其他分支，有冲突就在此时解决，不然隔的时间长了，鬼还记得修改了什么。</li>
<li>新开分支完成了<code>某个功能</code>, 新的分支<code>fea-02</code>开发测试完，合入<code>trunk</code>。此时其他分支应尽快的与<code>trunk</code>同步，将<code>trunk</code>分支<code>merge</code>至其他分支，如果<code>bug</code>分支作为长期分支，也需要同步，否则bug分支应该已经delete掉了。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.ouronghui.com/2017/03/08/svn-分支管理/" data-id="cjk0gup99003ma3rjxe57fsh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/版本控制/">版本控制</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/通信/">通信</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/数据库/PostgreSQL/">PostgreSQL</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/Openresty/">Openresty</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/">PostgreSQL</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PostgreSQL/数据库/">数据库</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/安全/">安全</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript语言/">javascript语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/测试/">测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/英语/">英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMD/">AMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMD/">CMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Centos软件安装/">Centos软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CommonJS/">CommonJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL基础/">PostgreSQL基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cassandra/">cassandra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript函数/">javascript函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript基础/">javascript基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/n2n/">n2n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/压力测试/">压力测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程-锁/">多线程 锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/意志/">意志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/授权/">授权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务/">服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/灰度发布/">灰度发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/英语/">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运动/">运动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程/">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/CMD/" style="font-size: 10px;">CMD</a> <a href="/tags/Centos软件安装/" style="font-size: 15px;">Centos软件安装</a> <a href="/tags/CommonJS/" style="font-size: 10px;">CommonJS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PostgreSQL基础/" style="font-size: 15px;">PostgreSQL基础</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/cassandra/" style="font-size: 10px;">cassandra</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript函数/" style="font-size: 15px;">javascript函数</a> <a href="/tags/javascript基础/" style="font-size: 15px;">javascript基础</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/n2n/" style="font-size: 10px;">n2n</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/压力测试/" style="font-size: 10px;">压力测试</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/多线程-锁/" style="font-size: 10px;">多线程 锁</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/意志/" style="font-size: 10px;">意志</a> <a href="/tags/授权/" style="font-size: 10px;">授权</a> <a href="/tags/服务/" style="font-size: 10px;">服务</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/灰度发布/" style="font-size: 10px;">灰度发布</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/编码/" style="font-size: 15px;">编码</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/英语/" style="font-size: 10px;">英语</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/运动/" style="font-size: 10px;">运动</a> <a href="/tags/进程/" style="font-size: 10px;">进程</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/19/ConnectTimeout、SocketTimeout/">ConnectTimeout、SocketTimeout</a>
          </li>
        
          <li>
            <a href="/2019/11/27/Idea简记/">Idea </a>
          </li>
        
          <li>
            <a href="/2018/08/31/Cassandra-数据库使用小记/">Cassandra 数据库使用小记</a>
          </li>
        
          <li>
            <a href="/2018/08/30/wrk-压力测试/">wrk 压力测试</a>
          </li>
        
          <li>
            <a href="/2018/08/22/Supervisor的使用/">Supervisor的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 orh<br>
      湘ICP备16002846号 <a href="http://www.beian.miit.gov.cn" target="_blank"> 湘ICP备16002846号</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>